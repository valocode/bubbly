package integrations

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
)

func fetchVulnerabilities() ([]VCVuln, error) {
	// note that this is limited to 20 vulnerabilities until VC updates their searching
	// If vc is running as a docker container, you will just need to change localhost -> dockerhost, port 8000 is default either way
	resp, err := http.Get("http://localhost:8000/api/vulnerabilities?limit=20")
	if err != nil {
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var v VCResponse
	err = json.Unmarshal(body, &v)
	if err != nil {
		return nil, err
	}
	// release components -> rvulns
	// check is matching purls, if edge is new,

	// grab components, and it's perl from codescan, match it from VC perl

	// fullList is a list of all the returned vulnerabilities that have a purl attached
	var fullList []VCVuln
	for _, vulnerability := range v.Results {
		for _, unresolved := range vulnerability.UnresolvedPackages {
			// check for any unresolved packages that have a purl
			if unresolved.Purl != "" {
				fullList = append(fullList, vulnerability)
			}
		}
	}

	return fullList, nil
}

// VCResponse is the result of calling GET vulnerablecode/vulnerabilities
type VCResponse struct {
	Results []VCVuln `json:"results"`
}

// VCVuln is how we store the vulnerabilities returned from vulnerablecode
type VCVuln struct {
	Vid                string        `json:"vulnerability_id"`
	References         []VCReference `json:"references"`
	Summary            string        `json:"summary"`
	UnresolvedPackages []VCPackage   `json:"unresolved_packages"`
}

type VCPackage struct {
	Purl string
}

type VCReference struct {
	Url string `json:"url"`
}
