package schema

import (
	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
)

type VulnerabilityReview struct {
	ent.Schema
}

func (VulnerabilityReview) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entsql.Annotation{Table: "vulnerability_review"},
	}
}

func (VulnerabilityReview) Fields() []ent.Field {
	return []ent.Field{
		field.Text("name").Optional().
			Annotations(
				entgql.OrderField("name"),
			),
		field.Enum("decision").
			Values("exploitable", "in_progress", "invalid", "mitigated", "ineffective"),
	}
}

func (VulnerabilityReview) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("vulnerability", Vulnerability.Type).Unique().Required(),
		edge.To("projects", Project.Type),
		edge.To("repos", Repo.Type),
		edge.To("releases", Release.Type),

		edge.From("instances", ReleaseVulnerability.Type).Ref("reviews"),
	}
}

// func (VulnerabilityReview) Indexes() []ent.Index {
// 	return []ent.Index{
// 		index.Fields("name").
// 			Edges("cve", "project", "repo").
// 			Unique(),
// 	}
// }

func (VulnerabilityReview) Hooks() []ent.Hook {
	return []ent.Hook{
		// hook.On(
		// 	func(next ent.Mutator) ent.Mutator {
		// 		return hook.VulnerabilityReviewFunc(func(ctx context.Context, m *gen.VulnerabilityReviewMutation) (ent.Value, error) {
		// 			if n, ok := m.Name(); ok {
		// 				if n == "" {
		// 					if cveID, ok := m.CveID(); ok {
		// 						cve, err := m.Client().CVE.Get(ctx, cveID)
		// 						if err == nil {
		// 							m.SetName("Rule for " + cve.CveID)
		// 						}
		// 					}
		// 				}
		// 			}
		// 			return next.Mutate(ctx, m)
		// 		})
		// 	},
		// 	ent.OpCreate,
		// ),
	}
}
