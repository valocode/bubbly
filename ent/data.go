// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/componentuse"
	"github.com/valocode/bubbly/ent/cve"
	"github.com/valocode/bubbly/ent/cverule"
	"github.com/valocode/bubbly/ent/cwe"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licenseuse"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
)

type GenericMutator interface {
	SetDataNode(node *DataNode) error
	SaveData(context.Context) (interface{}, error)
}

func CreateNode(tx *Tx, node *DataNode) error {
	ctx := context.Background()
	switch node.Name {
	case artifact.Table:
		nodeCreate := tx.Artifact.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case cve.Table:
		nodeCreate := tx.CVE.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case cverule.Table:
		nodeCreate := tx.CVERule.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case cwe.Table:
		nodeCreate := tx.CWE.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case codeissue.Table:
		nodeCreate := tx.CodeIssue.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case codescan.Table:
		nodeCreate := tx.CodeScan.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case component.Table:
		nodeCreate := tx.Component.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case componentuse.Table:
		nodeCreate := tx.ComponentUse.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case gitcommit.Table:
		nodeCreate := tx.GitCommit.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case license.Table:
		nodeCreate := tx.License.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case licenseuse.Table:
		nodeCreate := tx.LicenseUse.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case project.Table:
		nodeCreate := tx.Project.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case release.Table:
		nodeCreate := tx.Release.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case releaseentry.Table:
		nodeCreate := tx.ReleaseEntry.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case repo.Table:
		nodeCreate := tx.Repo.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case testcase.Table:
		nodeCreate := tx.TestCase.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case testrun.Table:
		nodeCreate := tx.TestRun.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case vulnerability.Table:
		nodeCreate := tx.Vulnerability.Create()
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	default:
		return fmt.Errorf("unknown type \"%s\"", node.Name)
	}
	return nil
}

func UpdateNode(tx *Tx, node *DataNode) error {
	ctx := context.Background()
	switch node.Name {
	case artifact.Table:
		nodeCreate := tx.Artifact.UpdateOne(node.Value.(*Artifact))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case cve.Table:
		nodeCreate := tx.CVE.UpdateOne(node.Value.(*CVE))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case cverule.Table:
		nodeCreate := tx.CVERule.UpdateOne(node.Value.(*CVERule))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case cwe.Table:
		nodeCreate := tx.CWE.UpdateOne(node.Value.(*CWE))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case codeissue.Table:
		nodeCreate := tx.CodeIssue.UpdateOne(node.Value.(*CodeIssue))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case codescan.Table:
		nodeCreate := tx.CodeScan.UpdateOne(node.Value.(*CodeScan))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case component.Table:
		nodeCreate := tx.Component.UpdateOne(node.Value.(*Component))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case componentuse.Table:
		nodeCreate := tx.ComponentUse.UpdateOne(node.Value.(*ComponentUse))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case gitcommit.Table:
		nodeCreate := tx.GitCommit.UpdateOne(node.Value.(*GitCommit))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case license.Table:
		nodeCreate := tx.License.UpdateOne(node.Value.(*License))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case licenseuse.Table:
		nodeCreate := tx.LicenseUse.UpdateOne(node.Value.(*LicenseUse))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case project.Table:
		nodeCreate := tx.Project.UpdateOne(node.Value.(*Project))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case release.Table:
		nodeCreate := tx.Release.UpdateOne(node.Value.(*Release))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case releaseentry.Table:
		nodeCreate := tx.ReleaseEntry.UpdateOne(node.Value.(*ReleaseEntry))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case repo.Table:
		nodeCreate := tx.Repo.UpdateOne(node.Value.(*Repo))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case testcase.Table:
		nodeCreate := tx.TestCase.UpdateOne(node.Value.(*TestCase))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case testrun.Table:
		nodeCreate := tx.TestRun.UpdateOne(node.Value.(*TestRun))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	case vulnerability.Table:
		nodeCreate := tx.Vulnerability.UpdateOne(node.Value.(*Vulnerability))
		if err := nodeCreate.SetDataNode(node); err != nil {
			return err
		}
		value, err := nodeCreate.Save(ctx)
		if err != nil {
			return err
		}
		node.Value = value
	default:
		return fmt.Errorf("unknown type \"%s\"", node.Name)
	}
	return nil
}

// QueryNode takes a node and generates a query (SELECT) based on the node.
// The query is influenced by the operation. If create or create_update we query
// for uniqueness (based on the table index) to know whether a create will succeed
// and in the case of create_update, whether we should create or update
func QueryNode(tx *Tx, node *DataNode) error {
	ctx := context.Background()
	switch node.Name {
	case artifact.Table:
		query := tx.Artifact.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case cve.Table:
		query := tx.CVE.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case cverule.Table:
		query := tx.CVERule.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case cwe.Table:
		query := tx.CWE.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case codeissue.Table:
		query := tx.CodeIssue.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case codescan.Table:
		query := tx.CodeScan.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case component.Table:
		query := tx.Component.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case componentuse.Table:
		query := tx.ComponentUse.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case gitcommit.Table:
		query := tx.GitCommit.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case license.Table:
		query := tx.License.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case licenseuse.Table:
		query := tx.LicenseUse.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case project.Table:
		query := tx.Project.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case release.Table:
		query := tx.Release.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case releaseentry.Table:
		query := tx.ReleaseEntry.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case repo.Table:
		query := tx.Repo.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case testcase.Table:
		query := tx.TestCase.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case testrun.Table:
		query := tx.TestRun.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	case vulnerability.Table:
		query := tx.Vulnerability.Query()
		switch node.Operation {
		case NodeOperationCreate, NodeOperationCreateUpdate, NodeOperationDefault:
			if err := query.WhereNodeUnique(node); err != nil {
				return err
			}
		case NodeOperationQuery, NodeOperationUpdate:
			if err := query.WhereNode(node); err != nil {
				return err
			}
		default:
			return fmt.Errorf("unknown node operation: %s", string(node.Operation))
		}
		// Check if there are any predicates, otherwise we want to return nil
		// TODO: this is kinda hacky and needs to be more thoughtout -- how to
		// check if a unique contraint will be violated or not
		if len(query.predicates) == 0 {
			return nil
		}
		query.Limit(2)
		values, err := query.All(ctx)
		if err != nil {
			return err
		}
		if len(values) > 1 {
			return errors.New("query returned more than 1 result")
		}
		if len(values) == 1 {
			node.Value = values[0]
		}
	default:
		return fmt.Errorf("unknown type %s", node.Name)
	}
	return nil
}

func (a *ArtifactCreate) SetDataNode(node *DataNode) error {
	if err := a.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := a.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (a *ArtifactUpdateOne) SetDataNode(node *DataNode) error {
	if err := a.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := a.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (a *ArtifactMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case artifact.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"artifact\" field \"name\": %w", err)
			}
			a.SetName(value)
		case artifact.FieldSha256:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"artifact\" field \"sha256\": %w", err)
			}
			a.SetSha256(value)
		case artifact.FieldType:
			var value artifact.Type
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"artifact\" field \"type\": %w", err)
			}
			a.SetType(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "artifact", field.Name)
		}
	}
	return nil
}

func (a *ArtifactMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + artifact.EdgeRelease:
			a.SetReleaseID(edge.Node.Value.(*Release).ID)
		case releaseentry.Table + artifact.EdgeEntry:
			a.SetEntryID(edge.Node.Value.(*ReleaseEntry).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "artifact", edge.Name)
		}
	}
	return nil
}

func (a *ArtifactUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + artifact.EdgeRelease:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// a.SetReleaseID(edge.Node.Value.(*Release).ID)
		case releaseentry.Table + artifact.EdgeEntry:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// a.SetEntryID(edge.Node.Value.(*ReleaseEntry).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "artifact", edge.Name)
		}
	}
	return nil
}

func (a *ArtifactQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case artifact.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"artifact\" field \"name\": %w", err)
			}
			a.Where(artifact.NameEQ(value))
		case artifact.FieldSha256:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"artifact\" field \"sha256\": %w", err)
			}
			a.Where(artifact.Sha256EQ(value))
		case artifact.FieldType:
			var value artifact.Type
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"artifact\" field \"type\": %w", err)
			}
			a.Where(artifact.TypeEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "artifact", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + artifact.EdgeRelease:
			a.Where(artifact.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case releaseentry.Table + artifact.EdgeEntry:
			a.Where(artifact.HasEntryWith(releaseentry.IDEQ(edge.Node.Value.(*ReleaseEntry).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "artifact", edge.Name)
		}
	}
	return nil
}

func (a *ArtifactQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case artifact.FieldSha256:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"artifact\" field \"sha256\": %w", err)
			}
			a.Where(artifact.Sha256EQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		}
	}
	return nil
}

func (c *CVECreate) SetDataNode(node *DataNode) error {
	if err := c.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := c.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (c *CVEUpdateOne) SetDataNode(node *DataNode) error {
	if err := c.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := c.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (c *CVEMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case cve.FieldCveID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"cve_id\": %w", err)
			}
			c.SetCveID(value)
		case cve.FieldDescription:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"description\": %w", err)
			}
			c.SetDescription(value)
		case cve.FieldSeverityScore:
			var value float64
			if err := ctyToEntValue(field.Value, 20, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"severity_score\": %w", err)
			}
			c.SetSeverityScore(value)
		case cve.FieldSeverity:
			var value cve.Severity
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"severity\": %w", err)
			}
			c.SetSeverity(value)
		case cve.FieldPublishedData:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"published_data\": %w", err)
			}
			c.SetPublishedData(value)
		case cve.FieldModifiedData:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"modified_data\": %w", err)
			}
			c.SetModifiedData(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "cve", field.Name)
		}
	}
	return nil
}

func (c *CVEMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case component.Table + cve.EdgeComponents:
			c.AddComponentIDs(edge.Node.Value.(*Component).ID)
		case vulnerability.Table + cve.EdgeVulnerabilities:
			c.AddVulnerabilityIDs(edge.Node.Value.(*Vulnerability).ID)
		case cverule.Table + cve.EdgeRules:
			c.AddRuleIDs(edge.Node.Value.(*CVERule).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cve", edge.Name)
		}
	}
	return nil
}

func (c *CVEUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case component.Table + cve.EdgeComponents:
			c.AddComponentIDs(edge.Node.Value.(*Component).ID)
		case vulnerability.Table + cve.EdgeVulnerabilities:
			c.AddVulnerabilityIDs(edge.Node.Value.(*Vulnerability).ID)
		case cverule.Table + cve.EdgeRules:
			c.AddRuleIDs(edge.Node.Value.(*CVERule).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cve", edge.Name)
		}
	}
	return nil
}

func (c *CVEQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case cve.FieldCveID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"cve_id\": %w", err)
			}
			c.Where(cve.CveIDEQ(value))
		case cve.FieldDescription:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"description\": %w", err)
			}
			c.Where(cve.DescriptionEQ(value))
		case cve.FieldSeverityScore:
			var value float64
			if err := ctyToEntValue(field.Value, 20, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"severity_score\": %w", err)
			}
			c.Where(cve.SeverityScoreEQ(value))
		case cve.FieldSeverity:
			var value cve.Severity
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"severity\": %w", err)
			}
			c.Where(cve.SeverityEQ(value))
		case cve.FieldPublishedData:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"published_data\": %w", err)
			}
			c.Where(cve.PublishedDataEQ(value))
		case cve.FieldModifiedData:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"modified_data\": %w", err)
			}
			c.Where(cve.ModifiedDataEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "cve", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case component.Table + cve.EdgeComponents:
			c.Where(cve.HasComponentsWith(component.IDEQ(edge.Node.Value.(*Component).ID)))
		case vulnerability.Table + cve.EdgeVulnerabilities:
			c.Where(cve.HasVulnerabilitiesWith(vulnerability.IDEQ(edge.Node.Value.(*Vulnerability).ID)))
		case cverule.Table + cve.EdgeRules:
			c.Where(cve.HasRulesWith(cverule.IDEQ(edge.Node.Value.(*CVERule).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cve", edge.Name)
		}
	}
	return nil
}

func (c *CVEQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case cve.FieldCveID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve\" field \"cve_id\": %w", err)
			}
			c.Where(cve.CveIDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		}
	}
	return nil
}

func (cr *CVERuleCreate) SetDataNode(node *DataNode) error {
	if err := cr.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := cr.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (cr *CVERuleUpdateOne) SetDataNode(node *DataNode) error {
	if err := cr.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := cr.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (cr *CVERuleMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case cverule.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve_rule\" field \"name\": %w", err)
			}
			cr.SetName(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "cve_rule", field.Name)
		}
	}
	return nil
}

func (cr *CVERuleMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cve.Table + cverule.EdgeCve:
			cr.SetCveID(edge.Node.Value.(*CVE).ID)
		case project.Table + cverule.EdgeProject:
			cr.AddProjectIDs(edge.Node.Value.(*Project).ID)
		case repo.Table + cverule.EdgeRepo:
			cr.AddRepoIDs(edge.Node.Value.(*Repo).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cve_rule", edge.Name)
		}
	}
	return nil
}

func (cr *CVERuleUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cve.Table + cverule.EdgeCve:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// cr.SetCveID(edge.Node.Value.(*CVE).ID)
		case project.Table + cverule.EdgeProject:
			cr.AddProjectIDs(edge.Node.Value.(*Project).ID)
		case repo.Table + cverule.EdgeRepo:
			cr.AddRepoIDs(edge.Node.Value.(*Repo).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cve_rule", edge.Name)
		}
	}
	return nil
}

func (cr *CVERuleQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case cverule.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve_rule\" field \"name\": %w", err)
			}
			cr.Where(cverule.NameEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "cve_rule", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case cve.Table + cverule.EdgeCve:
			cr.Where(cverule.HasCveWith(cve.IDEQ(edge.Node.Value.(*CVE).ID)))
		case project.Table + cverule.EdgeProject:
			cr.Where(cverule.HasProjectWith(project.IDEQ(edge.Node.Value.(*Project).ID)))
		case repo.Table + cverule.EdgeRepo:
			cr.Where(cverule.HasRepoWith(repo.IDEQ(edge.Node.Value.(*Repo).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cve_rule", edge.Name)
		}
	}
	return nil
}

func (cr *CVERuleQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case cverule.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cve_rule\" field \"id\": %w", err)
			}
			cr.Where(cverule.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case cve.Table + cverule.EdgeCve:
			cr.Where(cverule.HasCveWith(cve.IDEQ(edge.Node.Value.(*CVE).ID)))
		}
	}
	return nil
}

func (c *CWECreate) SetDataNode(node *DataNode) error {
	if err := c.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := c.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (c *CWEUpdateOne) SetDataNode(node *DataNode) error {
	if err := c.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := c.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (c *CWEMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case cwe.FieldCweID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cwe\" field \"cwe_id\": %w", err)
			}
			c.SetCweID(value)
		case cwe.FieldDescription:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cwe\" field \"description\": %w", err)
			}
			c.SetDescription(value)
		case cwe.FieldURL:
			var value float64
			if err := ctyToEntValue(field.Value, 20, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cwe\" field \"url\": %w", err)
			}
			c.SetURL(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "cwe", field.Name)
		}
	}
	return nil
}

func (c *CWEMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case codeissue.Table + cwe.EdgeIssues:
			c.AddIssueIDs(edge.Node.Value.(*CodeIssue).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cwe", edge.Name)
		}
	}
	return nil
}

func (c *CWEUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case codeissue.Table + cwe.EdgeIssues:
			c.AddIssueIDs(edge.Node.Value.(*CodeIssue).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cwe", edge.Name)
		}
	}
	return nil
}

func (c *CWEQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case cwe.FieldCweID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cwe\" field \"cwe_id\": %w", err)
			}
			c.Where(cwe.CweIDEQ(value))
		case cwe.FieldDescription:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cwe\" field \"description\": %w", err)
			}
			c.Where(cwe.DescriptionEQ(value))
		case cwe.FieldURL:
			var value float64
			if err := ctyToEntValue(field.Value, 20, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cwe\" field \"url\": %w", err)
			}
			c.Where(cwe.URLEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "cwe", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case codeissue.Table + cwe.EdgeIssues:
			c.Where(cwe.HasIssuesWith(codeissue.IDEQ(edge.Node.Value.(*CodeIssue).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "cwe", edge.Name)
		}
	}
	return nil
}

func (c *CWEQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case cwe.FieldCweID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"cwe\" field \"cwe_id\": %w", err)
			}
			c.Where(cwe.CweIDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		}
	}
	return nil
}

func (ci *CodeIssueCreate) SetDataNode(node *DataNode) error {
	if err := ci.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := ci.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (ci *CodeIssueUpdateOne) SetDataNode(node *DataNode) error {
	if err := ci.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := ci.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (ci *CodeIssueMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case codeissue.FieldRuleID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"rule_id\": %w", err)
			}
			ci.SetRuleID(value)
		case codeissue.FieldMessage:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"message\": %w", err)
			}
			ci.SetMessage(value)
		case codeissue.FieldSeverity:
			var value codeissue.Severity
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"severity\": %w", err)
			}
			ci.SetSeverity(value)
		case codeissue.FieldType:
			var value codeissue.Type
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"type\": %w", err)
			}
			ci.SetType(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "code_issue", field.Name)
		}
	}
	return nil
}

func (ci *CodeIssueMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cwe.Table + codeissue.EdgeCwe:
			ci.AddCweIDs(edge.Node.Value.(*CWE).ID)
		case codescan.Table + codeissue.EdgeScan:
			ci.SetScanID(edge.Node.Value.(*CodeScan).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "code_issue", edge.Name)
		}
	}
	return nil
}

func (ci *CodeIssueUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cwe.Table + codeissue.EdgeCwe:
			ci.AddCweIDs(edge.Node.Value.(*CWE).ID)
		case codescan.Table + codeissue.EdgeScan:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// ci.SetScanID(edge.Node.Value.(*CodeScan).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "code_issue", edge.Name)
		}
	}
	return nil
}

func (ci *CodeIssueQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case codeissue.FieldRuleID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"rule_id\": %w", err)
			}
			ci.Where(codeissue.RuleIDEQ(value))
		case codeissue.FieldMessage:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"message\": %w", err)
			}
			ci.Where(codeissue.MessageEQ(value))
		case codeissue.FieldSeverity:
			var value codeissue.Severity
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"severity\": %w", err)
			}
			ci.Where(codeissue.SeverityEQ(value))
		case codeissue.FieldType:
			var value codeissue.Type
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"type\": %w", err)
			}
			ci.Where(codeissue.TypeEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "code_issue", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case cwe.Table + codeissue.EdgeCwe:
			ci.Where(codeissue.HasCweWith(cwe.IDEQ(edge.Node.Value.(*CWE).ID)))
		case codescan.Table + codeissue.EdgeScan:
			ci.Where(codeissue.HasScanWith(codescan.IDEQ(edge.Node.Value.(*CodeScan).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "code_issue", edge.Name)
		}
	}
	return nil
}

func (ci *CodeIssueQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case codeissue.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_issue\" field \"id\": %w", err)
			}
			ci.Where(codeissue.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case codescan.Table + codeissue.EdgeScan:
			ci.Where(codeissue.HasScanWith(codescan.IDEQ(edge.Node.Value.(*CodeScan).ID)))
		}
	}
	return nil
}

func (cs *CodeScanCreate) SetDataNode(node *DataNode) error {
	if err := cs.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := cs.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (cs *CodeScanUpdateOne) SetDataNode(node *DataNode) error {
	if err := cs.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := cs.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (cs *CodeScanMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case codescan.FieldTool:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_scan\" field \"tool\": %w", err)
			}
			cs.SetTool(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "code_scan", field.Name)
		}
	}
	return nil
}

func (cs *CodeScanMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + codescan.EdgeRelease:
			cs.SetReleaseID(edge.Node.Value.(*Release).ID)
		case releaseentry.Table + codescan.EdgeEntry:
			cs.SetEntryID(edge.Node.Value.(*ReleaseEntry).ID)
		case codeissue.Table + codescan.EdgeIssues:
			cs.AddIssueIDs(edge.Node.Value.(*CodeIssue).ID)
		case componentuse.Table + codescan.EdgeComponents:
			cs.AddComponentIDs(edge.Node.Value.(*ComponentUse).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "code_scan", edge.Name)
		}
	}
	return nil
}

func (cs *CodeScanUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + codescan.EdgeRelease:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// cs.SetReleaseID(edge.Node.Value.(*Release).ID)
		case releaseentry.Table + codescan.EdgeEntry:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// cs.SetEntryID(edge.Node.Value.(*ReleaseEntry).ID)
		case codeissue.Table + codescan.EdgeIssues:
			cs.AddIssueIDs(edge.Node.Value.(*CodeIssue).ID)
		case componentuse.Table + codescan.EdgeComponents:
			cs.AddComponentIDs(edge.Node.Value.(*ComponentUse).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "code_scan", edge.Name)
		}
	}
	return nil
}

func (cs *CodeScanQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case codescan.FieldTool:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_scan\" field \"tool\": %w", err)
			}
			cs.Where(codescan.ToolEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "code_scan", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + codescan.EdgeRelease:
			cs.Where(codescan.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case releaseentry.Table + codescan.EdgeEntry:
			cs.Where(codescan.HasEntryWith(releaseentry.IDEQ(edge.Node.Value.(*ReleaseEntry).ID)))
		case codeissue.Table + codescan.EdgeIssues:
			cs.Where(codescan.HasIssuesWith(codeissue.IDEQ(edge.Node.Value.(*CodeIssue).ID)))
		case componentuse.Table + codescan.EdgeComponents:
			cs.Where(codescan.HasComponentsWith(componentuse.IDEQ(edge.Node.Value.(*ComponentUse).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "code_scan", edge.Name)
		}
	}
	return nil
}

func (cs *CodeScanQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case codescan.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"code_scan\" field \"id\": %w", err)
			}
			cs.Where(codescan.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + codescan.EdgeRelease:
			cs.Where(codescan.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case releaseentry.Table + codescan.EdgeEntry:
			cs.Where(codescan.HasEntryWith(releaseentry.IDEQ(edge.Node.Value.(*ReleaseEntry).ID)))
		}
	}
	return nil
}

func (c *ComponentCreate) SetDataNode(node *DataNode) error {
	if err := c.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := c.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (c *ComponentUpdateOne) SetDataNode(node *DataNode) error {
	if err := c.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := c.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (c *ComponentMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case component.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"name\": %w", err)
			}
			c.SetName(value)
		case component.FieldVendor:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"vendor\": %w", err)
			}
			c.SetVendor(value)
		case component.FieldVersion:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"version\": %w", err)
			}
			c.SetVersion(value)
		case component.FieldDescription:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"description\": %w", err)
			}
			c.SetDescription(value)
		case component.FieldURL:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"url\": %w", err)
			}
			c.SetURL(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "component", field.Name)
		}
	}
	return nil
}

func (c *ComponentMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cve.Table + component.EdgeCves:
			c.AddCfeIDs(edge.Node.Value.(*CVE).ID)
		case license.Table + component.EdgeLicenses:
			c.AddLicenseIDs(edge.Node.Value.(*License).ID)
		case componentuse.Table + component.EdgeUses:
			c.AddUseIDs(edge.Node.Value.(*ComponentUse).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "component", edge.Name)
		}
	}
	return nil
}

func (c *ComponentUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cve.Table + component.EdgeCves:
			c.AddCfeIDs(edge.Node.Value.(*CVE).ID)
		case license.Table + component.EdgeLicenses:
			c.AddLicenseIDs(edge.Node.Value.(*License).ID)
		case componentuse.Table + component.EdgeUses:
			c.AddUseIDs(edge.Node.Value.(*ComponentUse).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "component", edge.Name)
		}
	}
	return nil
}

func (c *ComponentQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case component.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"name\": %w", err)
			}
			c.Where(component.NameEQ(value))
		case component.FieldVendor:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"vendor\": %w", err)
			}
			c.Where(component.VendorEQ(value))
		case component.FieldVersion:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"version\": %w", err)
			}
			c.Where(component.VersionEQ(value))
		case component.FieldDescription:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"description\": %w", err)
			}
			c.Where(component.DescriptionEQ(value))
		case component.FieldURL:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"url\": %w", err)
			}
			c.Where(component.URLEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "component", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case cve.Table + component.EdgeCves:
			c.Where(component.HasCvesWith(cve.IDEQ(edge.Node.Value.(*CVE).ID)))
		case license.Table + component.EdgeLicenses:
			c.Where(component.HasLicensesWith(license.IDEQ(edge.Node.Value.(*License).ID)))
		case componentuse.Table + component.EdgeUses:
			c.Where(component.HasUsesWith(componentuse.IDEQ(edge.Node.Value.(*ComponentUse).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "component", edge.Name)
		}
	}
	return nil
}

func (c *ComponentQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case component.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"name\": %w", err)
			}
			c.Where(component.NameEQ(value))
		case component.FieldVendor:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"vendor\": %w", err)
			}
			c.Where(component.VendorEQ(value))
		case component.FieldVersion:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"component\" field \"version\": %w", err)
			}
			c.Where(component.VersionEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		}
	}
	return nil
}

func (cu *ComponentUseCreate) SetDataNode(node *DataNode) error {
	if err := cu.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := cu.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (cu *ComponentUseUpdateOne) SetDataNode(node *DataNode) error {
	if err := cu.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := cu.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (cu *ComponentUseMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "component_use", field.Name)
		}
	}
	return nil
}

func (cu *ComponentUseMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + componentuse.EdgeRelease:
			cu.SetReleaseID(edge.Node.Value.(*Release).ID)
		case codescan.Table + componentuse.EdgeScans:
			cu.AddScanIDs(edge.Node.Value.(*CodeScan).ID)
		case component.Table + componentuse.EdgeComponent:
			cu.SetComponentID(edge.Node.Value.(*Component).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "component_use", edge.Name)
		}
	}
	return nil
}

func (cu *ComponentUseUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + componentuse.EdgeRelease:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// cu.SetReleaseID(edge.Node.Value.(*Release).ID)
		case codescan.Table + componentuse.EdgeScans:
			cu.AddScanIDs(edge.Node.Value.(*CodeScan).ID)
		case component.Table + componentuse.EdgeComponent:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// cu.SetComponentID(edge.Node.Value.(*Component).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "component_use", edge.Name)
		}
	}
	return nil
}

func (cu *ComponentUseQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "component_use", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + componentuse.EdgeRelease:
			cu.Where(componentuse.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case codescan.Table + componentuse.EdgeScans:
			cu.Where(componentuse.HasScansWith(codescan.IDEQ(edge.Node.Value.(*CodeScan).ID)))
		case component.Table + componentuse.EdgeComponent:
			cu.Where(componentuse.HasComponentWith(component.IDEQ(edge.Node.Value.(*Component).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "component_use", edge.Name)
		}
	}
	return nil
}

func (cu *ComponentUseQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + componentuse.EdgeRelease:
			cu.Where(componentuse.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case component.Table + componentuse.EdgeComponent:
			cu.Where(componentuse.HasComponentWith(component.IDEQ(edge.Node.Value.(*Component).ID)))
		}
	}
	return nil
}

func (gc *GitCommitCreate) SetDataNode(node *DataNode) error {
	if err := gc.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := gc.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (gc *GitCommitUpdateOne) SetDataNode(node *DataNode) error {
	if err := gc.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := gc.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (gc *GitCommitMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case gitcommit.FieldHash:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"hash\": %w", err)
			}
			gc.SetHash(value)
		case gitcommit.FieldBranch:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"branch\": %w", err)
			}
			gc.SetBranch(value)
		case gitcommit.FieldTag:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"tag\": %w", err)
			}
			gc.SetTag(value)
		case gitcommit.FieldTime:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"time\": %w", err)
			}
			gc.SetTime(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "commit", field.Name)
		}
	}
	return nil
}

func (gc *GitCommitMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case repo.Table + gitcommit.EdgeRepo:
			gc.SetRepoID(edge.Node.Value.(*Repo).ID)
		case release.Table + gitcommit.EdgeRelease:
			gc.SetReleaseID(edge.Node.Value.(*Release).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "commit", edge.Name)
		}
	}
	return nil
}

func (gc *GitCommitUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case repo.Table + gitcommit.EdgeRepo:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// gc.SetRepoID(edge.Node.Value.(*Repo).ID)
		case release.Table + gitcommit.EdgeRelease:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// gc.SetReleaseID(edge.Node.Value.(*Release).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "commit", edge.Name)
		}
	}
	return nil
}

func (gc *GitCommitQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case gitcommit.FieldHash:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"hash\": %w", err)
			}
			gc.Where(gitcommit.HashEQ(value))
		case gitcommit.FieldBranch:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"branch\": %w", err)
			}
			gc.Where(gitcommit.BranchEQ(value))
		case gitcommit.FieldTag:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"tag\": %w", err)
			}
			gc.Where(gitcommit.TagEQ(value))
		case gitcommit.FieldTime:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"time\": %w", err)
			}
			gc.Where(gitcommit.TimeEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "commit", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case repo.Table + gitcommit.EdgeRepo:
			gc.Where(gitcommit.HasRepoWith(repo.IDEQ(edge.Node.Value.(*Repo).ID)))
		case release.Table + gitcommit.EdgeRelease:
			gc.Where(gitcommit.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "commit", edge.Name)
		}
	}
	return nil
}

func (gc *GitCommitQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case gitcommit.FieldHash:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"commit\" field \"hash\": %w", err)
			}
			gc.Where(gitcommit.HashEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case repo.Table + gitcommit.EdgeRepo:
			gc.Where(gitcommit.HasRepoWith(repo.IDEQ(edge.Node.Value.(*Repo).ID)))
		}
	}
	return nil
}

func (l *LicenseCreate) SetDataNode(node *DataNode) error {
	if err := l.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := l.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (l *LicenseUpdateOne) SetDataNode(node *DataNode) error {
	if err := l.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := l.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (l *LicenseMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case license.FieldSpdxID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"spdx_id\": %w", err)
			}
			l.SetSpdxID(value)
		case license.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"name\": %w", err)
			}
			l.SetName(value)
		case license.FieldReference:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"reference\": %w", err)
			}
			l.SetReference(value)
		case license.FieldDetailsURL:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"details_url\": %w", err)
			}
			l.SetDetailsURL(value)
		case license.FieldIsOsiApproved:
			var value bool
			if err := ctyToEntValue(field.Value, 1, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"is_osi_approved\": %w", err)
			}
			l.SetIsOsiApproved(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "license", field.Name)
		}
	}
	return nil
}

func (l *LicenseMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case component.Table + license.EdgeComponents:
			l.AddComponentIDs(edge.Node.Value.(*Component).ID)
		case licenseuse.Table + license.EdgeUses:
			l.AddUseIDs(edge.Node.Value.(*LicenseUse).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "license", edge.Name)
		}
	}
	return nil
}

func (l *LicenseUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case component.Table + license.EdgeComponents:
			l.AddComponentIDs(edge.Node.Value.(*Component).ID)
		case licenseuse.Table + license.EdgeUses:
			l.AddUseIDs(edge.Node.Value.(*LicenseUse).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "license", edge.Name)
		}
	}
	return nil
}

func (l *LicenseQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case license.FieldSpdxID:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"spdx_id\": %w", err)
			}
			l.Where(license.SpdxIDEQ(value))
		case license.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"name\": %w", err)
			}
			l.Where(license.NameEQ(value))
		case license.FieldReference:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"reference\": %w", err)
			}
			l.Where(license.ReferenceEQ(value))
		case license.FieldDetailsURL:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"details_url\": %w", err)
			}
			l.Where(license.DetailsURLEQ(value))
		case license.FieldIsOsiApproved:
			var value bool
			if err := ctyToEntValue(field.Value, 1, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"is_osi_approved\": %w", err)
			}
			l.Where(license.IsOsiApprovedEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "license", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case component.Table + license.EdgeComponents:
			l.Where(license.HasComponentsWith(component.IDEQ(edge.Node.Value.(*Component).ID)))
		case licenseuse.Table + license.EdgeUses:
			l.Where(license.HasUsesWith(licenseuse.IDEQ(edge.Node.Value.(*LicenseUse).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "license", edge.Name)
		}
	}
	return nil
}

func (l *LicenseQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case license.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license\" field \"id\": %w", err)
			}
			l.Where(license.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		}
	}
	return nil
}

func (lu *LicenseUseCreate) SetDataNode(node *DataNode) error {
	if err := lu.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := lu.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (lu *LicenseUseUpdateOne) SetDataNode(node *DataNode) error {
	if err := lu.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := lu.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (lu *LicenseUseMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "license_use", field.Name)
		}
	}
	return nil
}

func (lu *LicenseUseMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case license.Table + licenseuse.EdgeLicense:
			lu.SetLicenseID(edge.Node.Value.(*License).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "license_use", edge.Name)
		}
	}
	return nil
}

func (lu *LicenseUseUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case license.Table + licenseuse.EdgeLicense:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// lu.SetLicenseID(edge.Node.Value.(*License).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "license_use", edge.Name)
		}
	}
	return nil
}

func (lu *LicenseUseQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "license_use", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case license.Table + licenseuse.EdgeLicense:
			lu.Where(licenseuse.HasLicenseWith(license.IDEQ(edge.Node.Value.(*License).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "license_use", edge.Name)
		}
	}
	return nil
}

func (lu *LicenseUseQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case licenseuse.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"license_use\" field \"id\": %w", err)
			}
			lu.Where(licenseuse.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case license.Table + licenseuse.EdgeLicense:
			lu.Where(licenseuse.HasLicenseWith(license.IDEQ(edge.Node.Value.(*License).ID)))
		}
	}
	return nil
}

func (pr *ProjectCreate) SetDataNode(node *DataNode) error {
	if err := pr.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := pr.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (pr *ProjectUpdateOne) SetDataNode(node *DataNode) error {
	if err := pr.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := pr.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (pr *ProjectMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case project.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"project\" field \"name\": %w", err)
			}
			pr.SetName(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "project", field.Name)
		}
	}
	return nil
}

func (pr *ProjectMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case repo.Table + project.EdgeRepos:
			pr.AddRepoIDs(edge.Node.Value.(*Repo).ID)
		case release.Table + project.EdgeReleases:
			pr.AddReleaseIDs(edge.Node.Value.(*Release).ID)
		case cverule.Table + project.EdgeCveRules:
			pr.AddCveRuleIDs(edge.Node.Value.(*CVERule).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "project", edge.Name)
		}
	}
	return nil
}

func (pr *ProjectUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case repo.Table + project.EdgeRepos:
			pr.AddRepoIDs(edge.Node.Value.(*Repo).ID)
		case release.Table + project.EdgeReleases:
			pr.AddReleaseIDs(edge.Node.Value.(*Release).ID)
		case cverule.Table + project.EdgeCveRules:
			pr.AddCveRuleIDs(edge.Node.Value.(*CVERule).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "project", edge.Name)
		}
	}
	return nil
}

func (pr *ProjectQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case project.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"project\" field \"name\": %w", err)
			}
			pr.Where(project.NameEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "project", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case repo.Table + project.EdgeRepos:
			pr.Where(project.HasReposWith(repo.IDEQ(edge.Node.Value.(*Repo).ID)))
		case release.Table + project.EdgeReleases:
			pr.Where(project.HasReleasesWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case cverule.Table + project.EdgeCveRules:
			pr.Where(project.HasCveRulesWith(cverule.IDEQ(edge.Node.Value.(*CVERule).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "project", edge.Name)
		}
	}
	return nil
}

func (pr *ProjectQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case project.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"project\" field \"name\": %w", err)
			}
			pr.Where(project.NameEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		}
	}
	return nil
}

func (r *ReleaseCreate) SetDataNode(node *DataNode) error {
	if err := r.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := r.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (r *ReleaseUpdateOne) SetDataNode(node *DataNode) error {
	if err := r.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := r.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (r *ReleaseMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case release.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release\" field \"name\": %w", err)
			}
			r.SetName(value)
		case release.FieldVersion:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release\" field \"version\": %w", err)
			}
			r.SetVersion(value)
		case release.FieldStatus:
			var value release.Status
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release\" field \"status\": %w", err)
			}
			r.SetStatus(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "release", field.Name)
		}
	}
	return nil
}

func (r *ReleaseMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + release.EdgeSubreleases:
			r.AddSubreleaseIDs(edge.Node.Value.(*Release).ID)
		case release.Table + release.EdgeDependencies:
			r.AddDependencyIDs(edge.Node.Value.(*Release).ID)
		case project.Table + release.EdgeProject:
			r.SetProjectID(edge.Node.Value.(*Project).ID)
		case gitcommit.Table + release.EdgeCommit:
			r.SetCommitID(edge.Node.Value.(*GitCommit).ID)
		case releaseentry.Table + release.EdgeLog:
			r.AddLogIDs(edge.Node.Value.(*ReleaseEntry).ID)
		case artifact.Table + release.EdgeArtifacts:
			r.AddArtifactIDs(edge.Node.Value.(*Artifact).ID)
		case componentuse.Table + release.EdgeComponents:
			r.AddComponentIDs(edge.Node.Value.(*ComponentUse).ID)
		case codescan.Table + release.EdgeCodeScans:
			r.AddCodeScanIDs(edge.Node.Value.(*CodeScan).ID)
		case testrun.Table + release.EdgeTestRuns:
			r.AddTestRunIDs(edge.Node.Value.(*TestRun).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "release", edge.Name)
		}
	}
	return nil
}

func (r *ReleaseUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + release.EdgeSubreleases:
			r.AddSubreleaseIDs(edge.Node.Value.(*Release).ID)
		case release.Table + release.EdgeDependencies:
			r.AddDependencyIDs(edge.Node.Value.(*Release).ID)
		case project.Table + release.EdgeProject:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// r.SetProjectID(edge.Node.Value.(*Project).ID)
		case gitcommit.Table + release.EdgeCommit:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// r.SetCommitID(edge.Node.Value.(*GitCommit).ID)
		case releaseentry.Table + release.EdgeLog:
			r.AddLogIDs(edge.Node.Value.(*ReleaseEntry).ID)
		case artifact.Table + release.EdgeArtifacts:
			r.AddArtifactIDs(edge.Node.Value.(*Artifact).ID)
		case componentuse.Table + release.EdgeComponents:
			r.AddComponentIDs(edge.Node.Value.(*ComponentUse).ID)
		case codescan.Table + release.EdgeCodeScans:
			r.AddCodeScanIDs(edge.Node.Value.(*CodeScan).ID)
		case testrun.Table + release.EdgeTestRuns:
			r.AddTestRunIDs(edge.Node.Value.(*TestRun).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "release", edge.Name)
		}
	}
	return nil
}

func (r *ReleaseQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case release.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release\" field \"name\": %w", err)
			}
			r.Where(release.NameEQ(value))
		case release.FieldVersion:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release\" field \"version\": %w", err)
			}
			r.Where(release.VersionEQ(value))
		case release.FieldStatus:
			var value release.Status
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release\" field \"status\": %w", err)
			}
			r.Where(release.StatusEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "release", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + release.EdgeSubreleases:
			r.Where(release.HasSubreleasesWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case release.Table + release.EdgeDependencies:
			r.Where(release.HasDependenciesWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case project.Table + release.EdgeProject:
			r.Where(release.HasProjectWith(project.IDEQ(edge.Node.Value.(*Project).ID)))
		case gitcommit.Table + release.EdgeCommit:
			r.Where(release.HasCommitWith(gitcommit.IDEQ(edge.Node.Value.(*GitCommit).ID)))
		case releaseentry.Table + release.EdgeLog:
			r.Where(release.HasLogWith(releaseentry.IDEQ(edge.Node.Value.(*ReleaseEntry).ID)))
		case artifact.Table + release.EdgeArtifacts:
			r.Where(release.HasArtifactsWith(artifact.IDEQ(edge.Node.Value.(*Artifact).ID)))
		case componentuse.Table + release.EdgeComponents:
			r.Where(release.HasComponentsWith(componentuse.IDEQ(edge.Node.Value.(*ComponentUse).ID)))
		case codescan.Table + release.EdgeCodeScans:
			r.Where(release.HasCodeScansWith(codescan.IDEQ(edge.Node.Value.(*CodeScan).ID)))
		case testrun.Table + release.EdgeTestRuns:
			r.Where(release.HasTestRunsWith(testrun.IDEQ(edge.Node.Value.(*TestRun).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "release", edge.Name)
		}
	}
	return nil
}

func (r *ReleaseQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case gitcommit.Table + release.EdgeCommit:
			r.Where(release.HasCommitWith(gitcommit.IDEQ(edge.Node.Value.(*GitCommit).ID)))
		}
	}
	return nil
}

func (re *ReleaseEntryCreate) SetDataNode(node *DataNode) error {
	if err := re.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := re.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (re *ReleaseEntryUpdateOne) SetDataNode(node *DataNode) error {
	if err := re.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := re.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (re *ReleaseEntryMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case releaseentry.FieldType:
			var value releaseentry.Type
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release_entry\" field \"type\": %w", err)
			}
			re.SetType(value)
		case releaseentry.FieldTime:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release_entry\" field \"time\": %w", err)
			}
			re.SetTime(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "release_entry", field.Name)
		}
	}
	return nil
}

func (re *ReleaseEntryMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case artifact.Table + releaseentry.EdgeArtifact:
			re.SetArtifactID(edge.Node.Value.(*Artifact).ID)
		case codescan.Table + releaseentry.EdgeCodeScan:
			re.SetCodeScanID(edge.Node.Value.(*CodeScan).ID)
		case testrun.Table + releaseentry.EdgeTestRun:
			re.SetTestRunID(edge.Node.Value.(*TestRun).ID)
		case release.Table + releaseentry.EdgeRelease:
			re.SetReleaseID(edge.Node.Value.(*Release).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "release_entry", edge.Name)
		}
	}
	return nil
}

func (re *ReleaseEntryUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case artifact.Table + releaseentry.EdgeArtifact:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// re.SetArtifactID(edge.Node.Value.(*Artifact).ID)
		case codescan.Table + releaseentry.EdgeCodeScan:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// re.SetCodeScanID(edge.Node.Value.(*CodeScan).ID)
		case testrun.Table + releaseentry.EdgeTestRun:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// re.SetTestRunID(edge.Node.Value.(*TestRun).ID)
		case release.Table + releaseentry.EdgeRelease:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// re.SetReleaseID(edge.Node.Value.(*Release).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "release_entry", edge.Name)
		}
	}
	return nil
}

func (re *ReleaseEntryQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case releaseentry.FieldType:
			var value releaseentry.Type
			if err := ctyToEntValue(field.Value, 6, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release_entry\" field \"type\": %w", err)
			}
			re.Where(releaseentry.TypeEQ(value))
		case releaseentry.FieldTime:
			var value time.Time
			if err := ctyToEntValue(field.Value, 2, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release_entry\" field \"time\": %w", err)
			}
			re.Where(releaseentry.TimeEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "release_entry", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case artifact.Table + releaseentry.EdgeArtifact:
			re.Where(releaseentry.HasArtifactWith(artifact.IDEQ(edge.Node.Value.(*Artifact).ID)))
		case codescan.Table + releaseentry.EdgeCodeScan:
			re.Where(releaseentry.HasCodeScanWith(codescan.IDEQ(edge.Node.Value.(*CodeScan).ID)))
		case testrun.Table + releaseentry.EdgeTestRun:
			re.Where(releaseentry.HasTestRunWith(testrun.IDEQ(edge.Node.Value.(*TestRun).ID)))
		case release.Table + releaseentry.EdgeRelease:
			re.Where(releaseentry.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "release_entry", edge.Name)
		}
	}
	return nil
}

func (re *ReleaseEntryQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case releaseentry.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"release_entry\" field \"id\": %w", err)
			}
			re.Where(releaseentry.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case artifact.Table + releaseentry.EdgeArtifact:
			re.Where(releaseentry.HasArtifactWith(artifact.IDEQ(edge.Node.Value.(*Artifact).ID)))
		case codescan.Table + releaseentry.EdgeCodeScan:
			re.Where(releaseentry.HasCodeScanWith(codescan.IDEQ(edge.Node.Value.(*CodeScan).ID)))
		case testrun.Table + releaseentry.EdgeTestRun:
			re.Where(releaseentry.HasTestRunWith(testrun.IDEQ(edge.Node.Value.(*TestRun).ID)))
		case release.Table + releaseentry.EdgeRelease:
			re.Where(releaseentry.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		}
	}
	return nil
}

func (r *RepoCreate) SetDataNode(node *DataNode) error {
	if err := r.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := r.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (r *RepoUpdateOne) SetDataNode(node *DataNode) error {
	if err := r.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := r.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (r *RepoMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case repo.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"repo\" field \"name\": %w", err)
			}
			r.SetName(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "repo", field.Name)
		}
	}
	return nil
}

func (r *RepoMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case project.Table + repo.EdgeProject:
			r.SetProjectID(edge.Node.Value.(*Project).ID)
		case gitcommit.Table + repo.EdgeCommits:
			r.AddCommitIDs(edge.Node.Value.(*GitCommit).ID)
		case cverule.Table + repo.EdgeCveRules:
			r.AddCveRuleIDs(edge.Node.Value.(*CVERule).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "repo", edge.Name)
		}
	}
	return nil
}

func (r *RepoUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case project.Table + repo.EdgeProject:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// r.SetProjectID(edge.Node.Value.(*Project).ID)
		case gitcommit.Table + repo.EdgeCommits:
			r.AddCommitIDs(edge.Node.Value.(*GitCommit).ID)
		case cverule.Table + repo.EdgeCveRules:
			r.AddCveRuleIDs(edge.Node.Value.(*CVERule).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "repo", edge.Name)
		}
	}
	return nil
}

func (r *RepoQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case repo.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"repo\" field \"name\": %w", err)
			}
			r.Where(repo.NameEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "repo", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case project.Table + repo.EdgeProject:
			r.Where(repo.HasProjectWith(project.IDEQ(edge.Node.Value.(*Project).ID)))
		case gitcommit.Table + repo.EdgeCommits:
			r.Where(repo.HasCommitsWith(gitcommit.IDEQ(edge.Node.Value.(*GitCommit).ID)))
		case cverule.Table + repo.EdgeCveRules:
			r.Where(repo.HasCveRulesWith(cverule.IDEQ(edge.Node.Value.(*CVERule).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "repo", edge.Name)
		}
	}
	return nil
}

func (r *RepoQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case repo.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"repo\" field \"name\": %w", err)
			}
			r.Where(repo.NameEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		}
	}
	return nil
}

func (tc *TestCaseCreate) SetDataNode(node *DataNode) error {
	if err := tc.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := tc.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (tc *TestCaseUpdateOne) SetDataNode(node *DataNode) error {
	if err := tc.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := tc.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (tc *TestCaseMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case testcase.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"name\": %w", err)
			}
			tc.SetName(value)
		case testcase.FieldResult:
			var value bool
			if err := ctyToEntValue(field.Value, 1, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"result\": %w", err)
			}
			tc.SetResult(value)
		case testcase.FieldMessage:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"message\": %w", err)
			}
			tc.SetMessage(value)
		case testcase.FieldElapsed:
			var value float64
			if err := ctyToEntValue(field.Value, 20, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"elapsed\": %w", err)
			}
			tc.SetElapsed(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "test_case", field.Name)
		}
	}
	return nil
}

func (tc *TestCaseMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case testrun.Table + testcase.EdgeRun:
			tc.SetRunID(edge.Node.Value.(*TestRun).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "test_case", edge.Name)
		}
	}
	return nil
}

func (tc *TestCaseUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case testrun.Table + testcase.EdgeRun:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// tc.SetRunID(edge.Node.Value.(*TestRun).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "test_case", edge.Name)
		}
	}
	return nil
}

func (tc *TestCaseQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case testcase.FieldName:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"name\": %w", err)
			}
			tc.Where(testcase.NameEQ(value))
		case testcase.FieldResult:
			var value bool
			if err := ctyToEntValue(field.Value, 1, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"result\": %w", err)
			}
			tc.Where(testcase.ResultEQ(value))
		case testcase.FieldMessage:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"message\": %w", err)
			}
			tc.Where(testcase.MessageEQ(value))
		case testcase.FieldElapsed:
			var value float64
			if err := ctyToEntValue(field.Value, 20, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"elapsed\": %w", err)
			}
			tc.Where(testcase.ElapsedEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "test_case", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case testrun.Table + testcase.EdgeRun:
			tc.Where(testcase.HasRunWith(testrun.IDEQ(edge.Node.Value.(*TestRun).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "test_case", edge.Name)
		}
	}
	return nil
}

func (tc *TestCaseQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case testcase.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_case\" field \"id\": %w", err)
			}
			tc.Where(testcase.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case testrun.Table + testcase.EdgeRun:
			tc.Where(testcase.HasRunWith(testrun.IDEQ(edge.Node.Value.(*TestRun).ID)))
		}
	}
	return nil
}

func (tr *TestRunCreate) SetDataNode(node *DataNode) error {
	if err := tr.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := tr.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (tr *TestRunUpdateOne) SetDataNode(node *DataNode) error {
	if err := tr.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := tr.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (tr *TestRunMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		case testrun.FieldTool:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_run\" field \"tool\": %w", err)
			}
			tr.SetTool(value)
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "test_run", field.Name)
		}
	}
	return nil
}

func (tr *TestRunMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + testrun.EdgeRelease:
			tr.SetReleaseID(edge.Node.Value.(*Release).ID)
		case releaseentry.Table + testrun.EdgeEntry:
			tr.SetEntryID(edge.Node.Value.(*ReleaseEntry).ID)
		case testcase.Table + testrun.EdgeTests:
			tr.AddTestIDs(edge.Node.Value.(*TestCase).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "test_run", edge.Name)
		}
	}
	return nil
}

func (tr *TestRunUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case release.Table + testrun.EdgeRelease:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// tr.SetReleaseID(edge.Node.Value.(*Release).ID)
		case releaseentry.Table + testrun.EdgeEntry:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// tr.SetEntryID(edge.Node.Value.(*ReleaseEntry).ID)
		case testcase.Table + testrun.EdgeTests:
			tr.AddTestIDs(edge.Node.Value.(*TestCase).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "test_run", edge.Name)
		}
	}
	return nil
}

func (tr *TestRunQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case testrun.FieldTool:
			var value string
			if err := ctyToEntValue(field.Value, 7, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_run\" field \"tool\": %w", err)
			}
			tr.Where(testrun.ToolEQ(value))
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "test_run", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + testrun.EdgeRelease:
			tr.Where(testrun.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case releaseentry.Table + testrun.EdgeEntry:
			tr.Where(testrun.HasEntryWith(releaseentry.IDEQ(edge.Node.Value.(*ReleaseEntry).ID)))
		case testcase.Table + testrun.EdgeTests:
			tr.Where(testrun.HasTestsWith(testcase.IDEQ(edge.Node.Value.(*TestCase).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "test_run", edge.Name)
		}
	}
	return nil
}

func (tr *TestRunQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case testrun.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"test_run\" field \"id\": %w", err)
			}
			tr.Where(testrun.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case release.Table + testrun.EdgeRelease:
			tr.Where(testrun.HasReleaseWith(release.IDEQ(edge.Node.Value.(*Release).ID)))
		case releaseentry.Table + testrun.EdgeEntry:
			tr.Where(testrun.HasEntryWith(releaseentry.IDEQ(edge.Node.Value.(*ReleaseEntry).ID)))
		}
	}
	return nil
}

func (v *VulnerabilityCreate) SetDataNode(node *DataNode) error {
	if err := v.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := v.mutation.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (v *VulnerabilityUpdateOne) SetDataNode(node *DataNode) error {
	if err := v.mutation.SetDataFields(node.Fields); err != nil {
		return fmt.Errorf("error setting fields for node %s: %w", node.Name, err)
	}
	if err := v.SetDataEdges(node.Edges); err != nil {
		return fmt.Errorf("error setting edges for node %s: %w", node.Name, err)
	}
	return nil
}

func (v *VulnerabilityMutation) SetDataFields(fields []DataField) error {
	for _, field := range fields {
		switch field.Name {
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "vulnerability", field.Name)
		}
	}
	return nil
}

func (v *VulnerabilityMutation) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cve.Table + vulnerability.EdgeCve:
			v.SetCveID(edge.Node.Value.(*CVE).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "vulnerability", edge.Name)
		}
	}
	return nil
}

func (v *VulnerabilityUpdateOne) SetDataEdges(edges []DataEdge) error {
	for _, edge := range edges {
		if !edge.Inverse {
			continue
		}
		// Use the edge type (node name) + the edge name to avoid conflict
		// in case there are multiple edges with the same name
		switch edge.Node.Name + edge.Name {
		case cve.Table + vulnerability.EdgeCve:
			// TODO: it can get messy updating unique edges that already exist,
			// so for now just skip them
			// v.SetCveID(edge.Node.Value.(*CVE).ID)
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "vulnerability", edge.Name)
		}
	}
	return nil
}

func (v *VulnerabilityQuery) WhereNode(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		default:
			return fmt.Errorf("field does not exist for node %s: %s", "vulnerability", field.Name)
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case cve.Table + vulnerability.EdgeCve:
			v.Where(vulnerability.HasCveWith(cve.IDEQ(edge.Node.Value.(*CVE).ID)))
		default:
			return fmt.Errorf("edge does not exist for node %s: %s", "vulnerability", edge.Name)
		}
	}
	return nil
}

func (v *VulnerabilityQuery) WhereNodeUnique(node *DataNode) error {
	// Handle fields
	for _, field := range node.Fields {
		switch field.Name {
		case vulnerability.FieldID:
			var value int
			if err := ctyToEntValue(field.Value, 12, &value); err != nil {
				return fmt.Errorf("error converting cty value for type \"vulnerability\" field \"id\": %w", err)
			}
			v.Where(vulnerability.IDEQ(value))
		}
	}

	// Handle edges
	for _, edge := range node.Edges {
		// Inverse edges only because they describe the WHERE for a node
		if !edge.Inverse {
			continue
		}
		switch edge.Node.Name + edge.Name {
		case cve.Table + vulnerability.EdgeCve:
			v.Where(vulnerability.HasCveWith(cve.IDEQ(edge.Node.Value.(*CVE).ID)))
		}
	}
	return nil
}
