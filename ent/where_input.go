// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/valocode/bubbly/ent/adapter"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licenseuse"
	"github.com/valocode/bubbly/ent/organization"
	"github.com/valocode/bubbly/ent/predicate"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecomponent"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/releaselicense"
	"github.com/valocode/bubbly/ent/releasepolicy"
	"github.com/valocode/bubbly/ent/releasepolicyviolation"
	"github.com/valocode/bubbly/ent/releasevulnerability"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/valocode/bubbly/ent/vulnerabilityreview"
)

// AdapterWhereInput represents a where input for filtering Adapter queries.
type AdapterWhereInput struct {
	Not *AdapterWhereInput   `json:"not,omitempty"`
	Or  []*AdapterWhereInput `json:"or,omitempty"`
	And []*AdapterWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tag" field predicates.
	Tag             *string  `json:"tag,omitempty"`
	TagNEQ          *string  `json:"tagNEQ,omitempty"`
	TagIn           []string `json:"tagIn,omitempty"`
	TagNotIn        []string `json:"tagNotIn,omitempty"`
	TagGT           *string  `json:"tagGT,omitempty"`
	TagGTE          *string  `json:"tagGTE,omitempty"`
	TagLT           *string  `json:"tagLT,omitempty"`
	TagLTE          *string  `json:"tagLTE,omitempty"`
	TagContains     *string  `json:"tagContains,omitempty"`
	TagHasPrefix    *string  `json:"tagHasPrefix,omitempty"`
	TagHasSuffix    *string  `json:"tagHasSuffix,omitempty"`
	TagEqualFold    *string  `json:"tagEqualFold,omitempty"`
	TagContainsFold *string  `json:"tagContainsFold,omitempty"`

	// "module" field predicates.
	Module             *string  `json:"module,omitempty"`
	ModuleNEQ          *string  `json:"moduleNEQ,omitempty"`
	ModuleIn           []string `json:"moduleIn,omitempty"`
	ModuleNotIn        []string `json:"moduleNotIn,omitempty"`
	ModuleGT           *string  `json:"moduleGT,omitempty"`
	ModuleGTE          *string  `json:"moduleGTE,omitempty"`
	ModuleLT           *string  `json:"moduleLT,omitempty"`
	ModuleLTE          *string  `json:"moduleLTE,omitempty"`
	ModuleContains     *string  `json:"moduleContains,omitempty"`
	ModuleHasPrefix    *string  `json:"moduleHasPrefix,omitempty"`
	ModuleHasSuffix    *string  `json:"moduleHasSuffix,omitempty"`
	ModuleEqualFold    *string  `json:"moduleEqualFold,omitempty"`
	ModuleContainsFold *string  `json:"moduleContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`
}

// Filter applies the AdapterWhereInput filter on the AdapterQuery builder.
func (i *AdapterWhereInput) Filter(q *AdapterQuery) (*AdapterQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering adapters.
// An error is returned if the input is empty or invalid.
func (i *AdapterWhereInput) P() (predicate.Adapter, error) {
	var predicates []predicate.Adapter
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, adapter.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Adapter, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, adapter.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Adapter, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, adapter.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, adapter.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, adapter.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, adapter.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, adapter.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, adapter.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, adapter.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, adapter.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, adapter.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, adapter.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, adapter.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, adapter.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, adapter.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, adapter.NameContainsFold(*i.NameContainsFold))
	}
	if i.Tag != nil {
		predicates = append(predicates, adapter.TagEQ(*i.Tag))
	}
	if i.TagNEQ != nil {
		predicates = append(predicates, adapter.TagNEQ(*i.TagNEQ))
	}
	if len(i.TagIn) > 0 {
		predicates = append(predicates, adapter.TagIn(i.TagIn...))
	}
	if len(i.TagNotIn) > 0 {
		predicates = append(predicates, adapter.TagNotIn(i.TagNotIn...))
	}
	if i.TagGT != nil {
		predicates = append(predicates, adapter.TagGT(*i.TagGT))
	}
	if i.TagGTE != nil {
		predicates = append(predicates, adapter.TagGTE(*i.TagGTE))
	}
	if i.TagLT != nil {
		predicates = append(predicates, adapter.TagLT(*i.TagLT))
	}
	if i.TagLTE != nil {
		predicates = append(predicates, adapter.TagLTE(*i.TagLTE))
	}
	if i.TagContains != nil {
		predicates = append(predicates, adapter.TagContains(*i.TagContains))
	}
	if i.TagHasPrefix != nil {
		predicates = append(predicates, adapter.TagHasPrefix(*i.TagHasPrefix))
	}
	if i.TagHasSuffix != nil {
		predicates = append(predicates, adapter.TagHasSuffix(*i.TagHasSuffix))
	}
	if i.TagEqualFold != nil {
		predicates = append(predicates, adapter.TagEqualFold(*i.TagEqualFold))
	}
	if i.TagContainsFold != nil {
		predicates = append(predicates, adapter.TagContainsFold(*i.TagContainsFold))
	}
	if i.Module != nil {
		predicates = append(predicates, adapter.ModuleEQ(*i.Module))
	}
	if i.ModuleNEQ != nil {
		predicates = append(predicates, adapter.ModuleNEQ(*i.ModuleNEQ))
	}
	if len(i.ModuleIn) > 0 {
		predicates = append(predicates, adapter.ModuleIn(i.ModuleIn...))
	}
	if len(i.ModuleNotIn) > 0 {
		predicates = append(predicates, adapter.ModuleNotIn(i.ModuleNotIn...))
	}
	if i.ModuleGT != nil {
		predicates = append(predicates, adapter.ModuleGT(*i.ModuleGT))
	}
	if i.ModuleGTE != nil {
		predicates = append(predicates, adapter.ModuleGTE(*i.ModuleGTE))
	}
	if i.ModuleLT != nil {
		predicates = append(predicates, adapter.ModuleLT(*i.ModuleLT))
	}
	if i.ModuleLTE != nil {
		predicates = append(predicates, adapter.ModuleLTE(*i.ModuleLTE))
	}
	if i.ModuleContains != nil {
		predicates = append(predicates, adapter.ModuleContains(*i.ModuleContains))
	}
	if i.ModuleHasPrefix != nil {
		predicates = append(predicates, adapter.ModuleHasPrefix(*i.ModuleHasPrefix))
	}
	if i.ModuleHasSuffix != nil {
		predicates = append(predicates, adapter.ModuleHasSuffix(*i.ModuleHasSuffix))
	}
	if i.ModuleEqualFold != nil {
		predicates = append(predicates, adapter.ModuleEqualFold(*i.ModuleEqualFold))
	}
	if i.ModuleContainsFold != nil {
		predicates = append(predicates, adapter.ModuleContainsFold(*i.ModuleContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, adapter.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, adapter.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, adapter.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, adapter.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, adapter.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, adapter.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, adapter.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, adapter.IDLTE(*i.IDLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate AdapterWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return adapter.And(predicates...), nil
	}
}

// ArtifactWhereInput represents a where input for filtering Artifact queries.
type ArtifactWhereInput struct {
	Not *ArtifactWhereInput   `json:"not,omitempty"`
	Or  []*ArtifactWhereInput `json:"or,omitempty"`
	And []*ArtifactWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "sha256" field predicates.
	Sha256             *string  `json:"sha256,omitempty"`
	Sha256NEQ          *string  `json:"sha256NEQ,omitempty"`
	Sha256In           []string `json:"sha256In,omitempty"`
	Sha256NotIn        []string `json:"sha256NotIn,omitempty"`
	Sha256GT           *string  `json:"sha256GT,omitempty"`
	Sha256GTE          *string  `json:"sha256GTE,omitempty"`
	Sha256LT           *string  `json:"sha256LT,omitempty"`
	Sha256LTE          *string  `json:"sha256LTE,omitempty"`
	Sha256Contains     *string  `json:"sha256Contains,omitempty"`
	Sha256HasPrefix    *string  `json:"sha256HasPrefix,omitempty"`
	Sha256HasSuffix    *string  `json:"sha256HasSuffix,omitempty"`
	Sha256EqualFold    *string  `json:"sha256EqualFold,omitempty"`
	Sha256ContainsFold *string  `json:"sha256ContainsFold,omitempty"`

	// "type" field predicates.
	Type      *artifact.Type  `json:"type,omitempty"`
	TypeNEQ   *artifact.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []artifact.Type `json:"typeIn,omitempty"`
	TypeNotIn []artifact.Type `json:"typeNotIn,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "entry" edge predicates.
	HasEntry     *bool                     `json:"hasEntry,omitempty"`
	HasEntryWith []*ReleaseEntryWhereInput `json:"hasEntryWith,omitempty"`
}

// Filter applies the ArtifactWhereInput filter on the ArtifactQuery builder.
func (i *ArtifactWhereInput) Filter(q *ArtifactQuery) (*ArtifactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering artifacts.
// An error is returned if the input is empty or invalid.
func (i *ArtifactWhereInput) P() (predicate.Artifact, error) {
	var predicates []predicate.Artifact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, artifact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Artifact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, artifact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Artifact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, artifact.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, artifact.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, artifact.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, artifact.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, artifact.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, artifact.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, artifact.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, artifact.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, artifact.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, artifact.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, artifact.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, artifact.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, artifact.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, artifact.NameContainsFold(*i.NameContainsFold))
	}
	if i.Sha256 != nil {
		predicates = append(predicates, artifact.Sha256EQ(*i.Sha256))
	}
	if i.Sha256NEQ != nil {
		predicates = append(predicates, artifact.Sha256NEQ(*i.Sha256NEQ))
	}
	if len(i.Sha256In) > 0 {
		predicates = append(predicates, artifact.Sha256In(i.Sha256In...))
	}
	if len(i.Sha256NotIn) > 0 {
		predicates = append(predicates, artifact.Sha256NotIn(i.Sha256NotIn...))
	}
	if i.Sha256GT != nil {
		predicates = append(predicates, artifact.Sha256GT(*i.Sha256GT))
	}
	if i.Sha256GTE != nil {
		predicates = append(predicates, artifact.Sha256GTE(*i.Sha256GTE))
	}
	if i.Sha256LT != nil {
		predicates = append(predicates, artifact.Sha256LT(*i.Sha256LT))
	}
	if i.Sha256LTE != nil {
		predicates = append(predicates, artifact.Sha256LTE(*i.Sha256LTE))
	}
	if i.Sha256Contains != nil {
		predicates = append(predicates, artifact.Sha256Contains(*i.Sha256Contains))
	}
	if i.Sha256HasPrefix != nil {
		predicates = append(predicates, artifact.Sha256HasPrefix(*i.Sha256HasPrefix))
	}
	if i.Sha256HasSuffix != nil {
		predicates = append(predicates, artifact.Sha256HasSuffix(*i.Sha256HasSuffix))
	}
	if i.Sha256EqualFold != nil {
		predicates = append(predicates, artifact.Sha256EqualFold(*i.Sha256EqualFold))
	}
	if i.Sha256ContainsFold != nil {
		predicates = append(predicates, artifact.Sha256ContainsFold(*i.Sha256ContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, artifact.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, artifact.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, artifact.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, artifact.TypeNotIn(i.TypeNotIn...))
	}
	if i.Time != nil {
		predicates = append(predicates, artifact.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, artifact.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, artifact.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, artifact.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, artifact.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, artifact.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, artifact.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, artifact.TimeLTE(*i.TimeLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, artifact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artifact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artifact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artifact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artifact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artifact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artifact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artifact.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := artifact.HasRelease()
		if !*i.HasRelease {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasReleaseWith(with...))
	}
	if i.HasEntry != nil {
		p := artifact.HasEntry()
		if !*i.HasEntry {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntryWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasEntryWith))
		for _, w := range i.HasEntryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasEntryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ArtifactWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return artifact.And(predicates...), nil
	}
}

// CodeIssueWhereInput represents a where input for filtering CodeIssue queries.
type CodeIssueWhereInput struct {
	Not *CodeIssueWhereInput   `json:"not,omitempty"`
	Or  []*CodeIssueWhereInput `json:"or,omitempty"`
	And []*CodeIssueWhereInput `json:"and,omitempty"`

	// "rule_id" field predicates.
	RuleID             *string  `json:"ruleID,omitempty"`
	RuleIDNEQ          *string  `json:"ruleIDNEQ,omitempty"`
	RuleIDIn           []string `json:"ruleIDIn,omitempty"`
	RuleIDNotIn        []string `json:"ruleIDNotIn,omitempty"`
	RuleIDGT           *string  `json:"ruleIDGT,omitempty"`
	RuleIDGTE          *string  `json:"ruleIDGTE,omitempty"`
	RuleIDLT           *string  `json:"ruleIDLT,omitempty"`
	RuleIDLTE          *string  `json:"ruleIDLTE,omitempty"`
	RuleIDContains     *string  `json:"ruleIDContains,omitempty"`
	RuleIDHasPrefix    *string  `json:"ruleIDHasPrefix,omitempty"`
	RuleIDHasSuffix    *string  `json:"ruleIDHasSuffix,omitempty"`
	RuleIDEqualFold    *string  `json:"ruleIDEqualFold,omitempty"`
	RuleIDContainsFold *string  `json:"ruleIDContainsFold,omitempty"`

	// "message" field predicates.
	Message             *string  `json:"message,omitempty"`
	MessageNEQ          *string  `json:"messageNEQ,omitempty"`
	MessageIn           []string `json:"messageIn,omitempty"`
	MessageNotIn        []string `json:"messageNotIn,omitempty"`
	MessageGT           *string  `json:"messageGT,omitempty"`
	MessageGTE          *string  `json:"messageGTE,omitempty"`
	MessageLT           *string  `json:"messageLT,omitempty"`
	MessageLTE          *string  `json:"messageLTE,omitempty"`
	MessageContains     *string  `json:"messageContains,omitempty"`
	MessageHasPrefix    *string  `json:"messageHasPrefix,omitempty"`
	MessageHasSuffix    *string  `json:"messageHasSuffix,omitempty"`
	MessageEqualFold    *string  `json:"messageEqualFold,omitempty"`
	MessageContainsFold *string  `json:"messageContainsFold,omitempty"`

	// "severity" field predicates.
	Severity      *codeissue.Severity  `json:"severity,omitempty"`
	SeverityNEQ   *codeissue.Severity  `json:"severityNEQ,omitempty"`
	SeverityIn    []codeissue.Severity `json:"severityIn,omitempty"`
	SeverityNotIn []codeissue.Severity `json:"severityNotIn,omitempty"`

	// "type" field predicates.
	Type      *codeissue.Type  `json:"type,omitempty"`
	TypeNEQ   *codeissue.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []codeissue.Type `json:"typeIn,omitempty"`
	TypeNotIn []codeissue.Type `json:"typeNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "scan" edge predicates.
	HasScan     *bool                 `json:"hasScan,omitempty"`
	HasScanWith []*CodeScanWhereInput `json:"hasScanWith,omitempty"`
}

// Filter applies the CodeIssueWhereInput filter on the CodeIssueQuery builder.
func (i *CodeIssueWhereInput) Filter(q *CodeIssueQuery) (*CodeIssueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering codeissues.
// An error is returned if the input is empty or invalid.
func (i *CodeIssueWhereInput) P() (predicate.CodeIssue, error) {
	var predicates []predicate.CodeIssue
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, codeissue.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CodeIssue, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, codeissue.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CodeIssue, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, codeissue.And(and...))
	}
	if i.RuleID != nil {
		predicates = append(predicates, codeissue.RuleIDEQ(*i.RuleID))
	}
	if i.RuleIDNEQ != nil {
		predicates = append(predicates, codeissue.RuleIDNEQ(*i.RuleIDNEQ))
	}
	if len(i.RuleIDIn) > 0 {
		predicates = append(predicates, codeissue.RuleIDIn(i.RuleIDIn...))
	}
	if len(i.RuleIDNotIn) > 0 {
		predicates = append(predicates, codeissue.RuleIDNotIn(i.RuleIDNotIn...))
	}
	if i.RuleIDGT != nil {
		predicates = append(predicates, codeissue.RuleIDGT(*i.RuleIDGT))
	}
	if i.RuleIDGTE != nil {
		predicates = append(predicates, codeissue.RuleIDGTE(*i.RuleIDGTE))
	}
	if i.RuleIDLT != nil {
		predicates = append(predicates, codeissue.RuleIDLT(*i.RuleIDLT))
	}
	if i.RuleIDLTE != nil {
		predicates = append(predicates, codeissue.RuleIDLTE(*i.RuleIDLTE))
	}
	if i.RuleIDContains != nil {
		predicates = append(predicates, codeissue.RuleIDContains(*i.RuleIDContains))
	}
	if i.RuleIDHasPrefix != nil {
		predicates = append(predicates, codeissue.RuleIDHasPrefix(*i.RuleIDHasPrefix))
	}
	if i.RuleIDHasSuffix != nil {
		predicates = append(predicates, codeissue.RuleIDHasSuffix(*i.RuleIDHasSuffix))
	}
	if i.RuleIDEqualFold != nil {
		predicates = append(predicates, codeissue.RuleIDEqualFold(*i.RuleIDEqualFold))
	}
	if i.RuleIDContainsFold != nil {
		predicates = append(predicates, codeissue.RuleIDContainsFold(*i.RuleIDContainsFold))
	}
	if i.Message != nil {
		predicates = append(predicates, codeissue.MessageEQ(*i.Message))
	}
	if i.MessageNEQ != nil {
		predicates = append(predicates, codeissue.MessageNEQ(*i.MessageNEQ))
	}
	if len(i.MessageIn) > 0 {
		predicates = append(predicates, codeissue.MessageIn(i.MessageIn...))
	}
	if len(i.MessageNotIn) > 0 {
		predicates = append(predicates, codeissue.MessageNotIn(i.MessageNotIn...))
	}
	if i.MessageGT != nil {
		predicates = append(predicates, codeissue.MessageGT(*i.MessageGT))
	}
	if i.MessageGTE != nil {
		predicates = append(predicates, codeissue.MessageGTE(*i.MessageGTE))
	}
	if i.MessageLT != nil {
		predicates = append(predicates, codeissue.MessageLT(*i.MessageLT))
	}
	if i.MessageLTE != nil {
		predicates = append(predicates, codeissue.MessageLTE(*i.MessageLTE))
	}
	if i.MessageContains != nil {
		predicates = append(predicates, codeissue.MessageContains(*i.MessageContains))
	}
	if i.MessageHasPrefix != nil {
		predicates = append(predicates, codeissue.MessageHasPrefix(*i.MessageHasPrefix))
	}
	if i.MessageHasSuffix != nil {
		predicates = append(predicates, codeissue.MessageHasSuffix(*i.MessageHasSuffix))
	}
	if i.MessageEqualFold != nil {
		predicates = append(predicates, codeissue.MessageEqualFold(*i.MessageEqualFold))
	}
	if i.MessageContainsFold != nil {
		predicates = append(predicates, codeissue.MessageContainsFold(*i.MessageContainsFold))
	}
	if i.Severity != nil {
		predicates = append(predicates, codeissue.SeverityEQ(*i.Severity))
	}
	if i.SeverityNEQ != nil {
		predicates = append(predicates, codeissue.SeverityNEQ(*i.SeverityNEQ))
	}
	if len(i.SeverityIn) > 0 {
		predicates = append(predicates, codeissue.SeverityIn(i.SeverityIn...))
	}
	if len(i.SeverityNotIn) > 0 {
		predicates = append(predicates, codeissue.SeverityNotIn(i.SeverityNotIn...))
	}
	if i.Type != nil {
		predicates = append(predicates, codeissue.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, codeissue.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, codeissue.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, codeissue.TypeNotIn(i.TypeNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, codeissue.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, codeissue.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, codeissue.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, codeissue.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, codeissue.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, codeissue.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, codeissue.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, codeissue.IDLTE(*i.IDLTE))
	}

	if i.HasScan != nil {
		p := codeissue.HasScan()
		if !*i.HasScan {
			p = codeissue.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScanWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasScanWith))
		for _, w := range i.HasScanWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codeissue.HasScanWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate CodeIssueWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return codeissue.And(predicates...), nil
	}
}

// CodeScanWhereInput represents a where input for filtering CodeScan queries.
type CodeScanWhereInput struct {
	Not *CodeScanWhereInput   `json:"not,omitempty"`
	Or  []*CodeScanWhereInput `json:"or,omitempty"`
	And []*CodeScanWhereInput `json:"and,omitempty"`

	// "tool" field predicates.
	Tool             *string  `json:"tool,omitempty"`
	ToolNEQ          *string  `json:"toolNEQ,omitempty"`
	ToolIn           []string `json:"toolIn,omitempty"`
	ToolNotIn        []string `json:"toolNotIn,omitempty"`
	ToolGT           *string  `json:"toolGT,omitempty"`
	ToolGTE          *string  `json:"toolGTE,omitempty"`
	ToolLT           *string  `json:"toolLT,omitempty"`
	ToolLTE          *string  `json:"toolLTE,omitempty"`
	ToolContains     *string  `json:"toolContains,omitempty"`
	ToolHasPrefix    *string  `json:"toolHasPrefix,omitempty"`
	ToolHasSuffix    *string  `json:"toolHasSuffix,omitempty"`
	ToolEqualFold    *string  `json:"toolEqualFold,omitempty"`
	ToolContainsFold *string  `json:"toolContainsFold,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "entry" edge predicates.
	HasEntry     *bool                     `json:"hasEntry,omitempty"`
	HasEntryWith []*ReleaseEntryWhereInput `json:"hasEntryWith,omitempty"`

	// "issues" edge predicates.
	HasIssues     *bool                  `json:"hasIssues,omitempty"`
	HasIssuesWith []*CodeIssueWhereInput `json:"hasIssuesWith,omitempty"`

	// "vulnerabilities" edge predicates.
	HasVulnerabilities     *bool                             `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*ReleaseVulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                         `json:"hasComponents,omitempty"`
	HasComponentsWith []*ReleaseComponentWhereInput `json:"hasComponentsWith,omitempty"`
}

// Filter applies the CodeScanWhereInput filter on the CodeScanQuery builder.
func (i *CodeScanWhereInput) Filter(q *CodeScanQuery) (*CodeScanQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering codescans.
// An error is returned if the input is empty or invalid.
func (i *CodeScanWhereInput) P() (predicate.CodeScan, error) {
	var predicates []predicate.CodeScan
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, codescan.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CodeScan, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, codescan.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CodeScan, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, codescan.And(and...))
	}
	if i.Tool != nil {
		predicates = append(predicates, codescan.ToolEQ(*i.Tool))
	}
	if i.ToolNEQ != nil {
		predicates = append(predicates, codescan.ToolNEQ(*i.ToolNEQ))
	}
	if len(i.ToolIn) > 0 {
		predicates = append(predicates, codescan.ToolIn(i.ToolIn...))
	}
	if len(i.ToolNotIn) > 0 {
		predicates = append(predicates, codescan.ToolNotIn(i.ToolNotIn...))
	}
	if i.ToolGT != nil {
		predicates = append(predicates, codescan.ToolGT(*i.ToolGT))
	}
	if i.ToolGTE != nil {
		predicates = append(predicates, codescan.ToolGTE(*i.ToolGTE))
	}
	if i.ToolLT != nil {
		predicates = append(predicates, codescan.ToolLT(*i.ToolLT))
	}
	if i.ToolLTE != nil {
		predicates = append(predicates, codescan.ToolLTE(*i.ToolLTE))
	}
	if i.ToolContains != nil {
		predicates = append(predicates, codescan.ToolContains(*i.ToolContains))
	}
	if i.ToolHasPrefix != nil {
		predicates = append(predicates, codescan.ToolHasPrefix(*i.ToolHasPrefix))
	}
	if i.ToolHasSuffix != nil {
		predicates = append(predicates, codescan.ToolHasSuffix(*i.ToolHasSuffix))
	}
	if i.ToolEqualFold != nil {
		predicates = append(predicates, codescan.ToolEqualFold(*i.ToolEqualFold))
	}
	if i.ToolContainsFold != nil {
		predicates = append(predicates, codescan.ToolContainsFold(*i.ToolContainsFold))
	}
	if i.Time != nil {
		predicates = append(predicates, codescan.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, codescan.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, codescan.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, codescan.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, codescan.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, codescan.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, codescan.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, codescan.TimeLTE(*i.TimeLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, codescan.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, codescan.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, codescan.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, codescan.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, codescan.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, codescan.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, codescan.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, codescan.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := codescan.HasRelease()
		if !*i.HasRelease {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasReleaseWith(with...))
	}
	if i.HasEntry != nil {
		p := codescan.HasEntry()
		if !*i.HasEntry {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntryWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasEntryWith))
		for _, w := range i.HasEntryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasEntryWith(with...))
	}
	if i.HasIssues != nil {
		p := codescan.HasIssues()
		if !*i.HasIssues {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIssuesWith) > 0 {
		with := make([]predicate.CodeIssue, 0, len(i.HasIssuesWith))
		for _, w := range i.HasIssuesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasIssuesWith(with...))
	}
	if i.HasVulnerabilities != nil {
		p := codescan.HasVulnerabilities()
		if !*i.HasVulnerabilities {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilitiesWith) > 0 {
		with := make([]predicate.ReleaseVulnerability, 0, len(i.HasVulnerabilitiesWith))
		for _, w := range i.HasVulnerabilitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasVulnerabilitiesWith(with...))
	}
	if i.HasComponents != nil {
		p := codescan.HasComponents()
		if !*i.HasComponents {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.ReleaseComponent, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasComponentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate CodeScanWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return codescan.And(predicates...), nil
	}
}

// ComponentWhereInput represents a where input for filtering Component queries.
type ComponentWhereInput struct {
	Not *ComponentWhereInput   `json:"not,omitempty"`
	Or  []*ComponentWhereInput `json:"or,omitempty"`
	And []*ComponentWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "vulnerabilities" edge predicates.
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`

	// "licenses" edge predicates.
	HasLicenses     *bool                `json:"hasLicenses,omitempty"`
	HasLicensesWith []*LicenseWhereInput `json:"hasLicensesWith,omitempty"`

	// "uses" edge predicates.
	HasUses     *bool                         `json:"hasUses,omitempty"`
	HasUsesWith []*ReleaseComponentWhereInput `json:"hasUsesWith,omitempty"`
}

// Filter applies the ComponentWhereInput filter on the ComponentQuery builder.
func (i *ComponentWhereInput) Filter(q *ComponentQuery) (*ComponentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering components.
// An error is returned if the input is empty or invalid.
func (i *ComponentWhereInput) P() (predicate.Component, error) {
	var predicates []predicate.Component
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, component.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Component, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, component.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Component, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, component.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, component.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, component.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, component.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, component.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, component.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, component.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, component.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, component.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, component.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, component.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, component.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, component.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, component.NameContainsFold(*i.NameContainsFold))
	}
	if i.Vendor != nil {
		predicates = append(predicates, component.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, component.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, component.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, component.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, component.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, component.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, component.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, component.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, component.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, component.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, component.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, component.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, component.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, component.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, component.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, component.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, component.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, component.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, component.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, component.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, component.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, component.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, component.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, component.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, component.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, component.VersionContainsFold(*i.VersionContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, component.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, component.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, component.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, component.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, component.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, component.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, component.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, component.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, component.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, component.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, component.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, component.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, component.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, component.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, component.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, component.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, component.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, component.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, component.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, component.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, component.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, component.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, component.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, component.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, component.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, component.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, component.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, component.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, component.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, component.URLContainsFold(*i.URLContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, component.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, component.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, component.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, component.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, component.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, component.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, component.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, component.IDLTE(*i.IDLTE))
	}

	if i.HasVulnerabilities != nil {
		p := component.HasVulnerabilities()
		if !*i.HasVulnerabilities {
			p = component.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilitiesWith) > 0 {
		with := make([]predicate.Vulnerability, 0, len(i.HasVulnerabilitiesWith))
		for _, w := range i.HasVulnerabilitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, component.HasVulnerabilitiesWith(with...))
	}
	if i.HasLicenses != nil {
		p := component.HasLicenses()
		if !*i.HasLicenses {
			p = component.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicensesWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicensesWith))
		for _, w := range i.HasLicensesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, component.HasLicensesWith(with...))
	}
	if i.HasUses != nil {
		p := component.HasUses()
		if !*i.HasUses {
			p = component.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsesWith) > 0 {
		with := make([]predicate.ReleaseComponent, 0, len(i.HasUsesWith))
		for _, w := range i.HasUsesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, component.HasUsesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ComponentWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return component.And(predicates...), nil
	}
}

// GitCommitWhereInput represents a where input for filtering GitCommit queries.
type GitCommitWhereInput struct {
	Not *GitCommitWhereInput   `json:"not,omitempty"`
	Or  []*GitCommitWhereInput `json:"or,omitempty"`
	And []*GitCommitWhereInput `json:"and,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "branch" field predicates.
	Branch             *string  `json:"branch,omitempty"`
	BranchNEQ          *string  `json:"branchNEQ,omitempty"`
	BranchIn           []string `json:"branchIn,omitempty"`
	BranchNotIn        []string `json:"branchNotIn,omitempty"`
	BranchGT           *string  `json:"branchGT,omitempty"`
	BranchGTE          *string  `json:"branchGTE,omitempty"`
	BranchLT           *string  `json:"branchLT,omitempty"`
	BranchLTE          *string  `json:"branchLTE,omitempty"`
	BranchContains     *string  `json:"branchContains,omitempty"`
	BranchHasPrefix    *string  `json:"branchHasPrefix,omitempty"`
	BranchHasSuffix    *string  `json:"branchHasSuffix,omitempty"`
	BranchEqualFold    *string  `json:"branchEqualFold,omitempty"`
	BranchContainsFold *string  `json:"branchContainsFold,omitempty"`

	// "tag" field predicates.
	Tag             *string  `json:"tag,omitempty"`
	TagNEQ          *string  `json:"tagNEQ,omitempty"`
	TagIn           []string `json:"tagIn,omitempty"`
	TagNotIn        []string `json:"tagNotIn,omitempty"`
	TagGT           *string  `json:"tagGT,omitempty"`
	TagGTE          *string  `json:"tagGTE,omitempty"`
	TagLT           *string  `json:"tagLT,omitempty"`
	TagLTE          *string  `json:"tagLTE,omitempty"`
	TagContains     *string  `json:"tagContains,omitempty"`
	TagHasPrefix    *string  `json:"tagHasPrefix,omitempty"`
	TagHasSuffix    *string  `json:"tagHasSuffix,omitempty"`
	TagIsNil        bool     `json:"tagIsNil,omitempty"`
	TagNotNil       bool     `json:"tagNotNil,omitempty"`
	TagEqualFold    *string  `json:"tagEqualFold,omitempty"`
	TagContainsFold *string  `json:"tagContainsFold,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "repo" edge predicates.
	HasRepo     *bool             `json:"hasRepo,omitempty"`
	HasRepoWith []*RepoWhereInput `json:"hasRepoWith,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`
}

// Filter applies the GitCommitWhereInput filter on the GitCommitQuery builder.
func (i *GitCommitWhereInput) Filter(q *GitCommitQuery) (*GitCommitQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering gitcommits.
// An error is returned if the input is empty or invalid.
func (i *GitCommitWhereInput) P() (predicate.GitCommit, error) {
	var predicates []predicate.GitCommit
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, gitcommit.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GitCommit, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, gitcommit.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GitCommit, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, gitcommit.And(and...))
	}
	if i.Hash != nil {
		predicates = append(predicates, gitcommit.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, gitcommit.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, gitcommit.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, gitcommit.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, gitcommit.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, gitcommit.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, gitcommit.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, gitcommit.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, gitcommit.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, gitcommit.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, gitcommit.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, gitcommit.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, gitcommit.HashContainsFold(*i.HashContainsFold))
	}
	if i.Branch != nil {
		predicates = append(predicates, gitcommit.BranchEQ(*i.Branch))
	}
	if i.BranchNEQ != nil {
		predicates = append(predicates, gitcommit.BranchNEQ(*i.BranchNEQ))
	}
	if len(i.BranchIn) > 0 {
		predicates = append(predicates, gitcommit.BranchIn(i.BranchIn...))
	}
	if len(i.BranchNotIn) > 0 {
		predicates = append(predicates, gitcommit.BranchNotIn(i.BranchNotIn...))
	}
	if i.BranchGT != nil {
		predicates = append(predicates, gitcommit.BranchGT(*i.BranchGT))
	}
	if i.BranchGTE != nil {
		predicates = append(predicates, gitcommit.BranchGTE(*i.BranchGTE))
	}
	if i.BranchLT != nil {
		predicates = append(predicates, gitcommit.BranchLT(*i.BranchLT))
	}
	if i.BranchLTE != nil {
		predicates = append(predicates, gitcommit.BranchLTE(*i.BranchLTE))
	}
	if i.BranchContains != nil {
		predicates = append(predicates, gitcommit.BranchContains(*i.BranchContains))
	}
	if i.BranchHasPrefix != nil {
		predicates = append(predicates, gitcommit.BranchHasPrefix(*i.BranchHasPrefix))
	}
	if i.BranchHasSuffix != nil {
		predicates = append(predicates, gitcommit.BranchHasSuffix(*i.BranchHasSuffix))
	}
	if i.BranchEqualFold != nil {
		predicates = append(predicates, gitcommit.BranchEqualFold(*i.BranchEqualFold))
	}
	if i.BranchContainsFold != nil {
		predicates = append(predicates, gitcommit.BranchContainsFold(*i.BranchContainsFold))
	}
	if i.Tag != nil {
		predicates = append(predicates, gitcommit.TagEQ(*i.Tag))
	}
	if i.TagNEQ != nil {
		predicates = append(predicates, gitcommit.TagNEQ(*i.TagNEQ))
	}
	if len(i.TagIn) > 0 {
		predicates = append(predicates, gitcommit.TagIn(i.TagIn...))
	}
	if len(i.TagNotIn) > 0 {
		predicates = append(predicates, gitcommit.TagNotIn(i.TagNotIn...))
	}
	if i.TagGT != nil {
		predicates = append(predicates, gitcommit.TagGT(*i.TagGT))
	}
	if i.TagGTE != nil {
		predicates = append(predicates, gitcommit.TagGTE(*i.TagGTE))
	}
	if i.TagLT != nil {
		predicates = append(predicates, gitcommit.TagLT(*i.TagLT))
	}
	if i.TagLTE != nil {
		predicates = append(predicates, gitcommit.TagLTE(*i.TagLTE))
	}
	if i.TagContains != nil {
		predicates = append(predicates, gitcommit.TagContains(*i.TagContains))
	}
	if i.TagHasPrefix != nil {
		predicates = append(predicates, gitcommit.TagHasPrefix(*i.TagHasPrefix))
	}
	if i.TagHasSuffix != nil {
		predicates = append(predicates, gitcommit.TagHasSuffix(*i.TagHasSuffix))
	}
	if i.TagIsNil {
		predicates = append(predicates, gitcommit.TagIsNil())
	}
	if i.TagNotNil {
		predicates = append(predicates, gitcommit.TagNotNil())
	}
	if i.TagEqualFold != nil {
		predicates = append(predicates, gitcommit.TagEqualFold(*i.TagEqualFold))
	}
	if i.TagContainsFold != nil {
		predicates = append(predicates, gitcommit.TagContainsFold(*i.TagContainsFold))
	}
	if i.Time != nil {
		predicates = append(predicates, gitcommit.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, gitcommit.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, gitcommit.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, gitcommit.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, gitcommit.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, gitcommit.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, gitcommit.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, gitcommit.TimeLTE(*i.TimeLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, gitcommit.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gitcommit.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gitcommit.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gitcommit.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gitcommit.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gitcommit.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gitcommit.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gitcommit.IDLTE(*i.IDLTE))
	}

	if i.HasRepo != nil {
		p := gitcommit.HasRepo()
		if !*i.HasRepo {
			p = gitcommit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRepoWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasRepoWith))
		for _, w := range i.HasRepoWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, gitcommit.HasRepoWith(with...))
	}
	if i.HasRelease != nil {
		p := gitcommit.HasRelease()
		if !*i.HasRelease {
			p = gitcommit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, gitcommit.HasReleaseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate GitCommitWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return gitcommit.And(predicates...), nil
	}
}

// LicenseWhereInput represents a where input for filtering License queries.
type LicenseWhereInput struct {
	Not *LicenseWhereInput   `json:"not,omitempty"`
	Or  []*LicenseWhereInput `json:"or,omitempty"`
	And []*LicenseWhereInput `json:"and,omitempty"`

	// "spdx_id" field predicates.
	SpdxID             *string  `json:"spdxID,omitempty"`
	SpdxIDNEQ          *string  `json:"spdxIDNEQ,omitempty"`
	SpdxIDIn           []string `json:"spdxIDIn,omitempty"`
	SpdxIDNotIn        []string `json:"spdxIDNotIn,omitempty"`
	SpdxIDGT           *string  `json:"spdxIDGT,omitempty"`
	SpdxIDGTE          *string  `json:"spdxIDGTE,omitempty"`
	SpdxIDLT           *string  `json:"spdxIDLT,omitempty"`
	SpdxIDLTE          *string  `json:"spdxIDLTE,omitempty"`
	SpdxIDContains     *string  `json:"spdxIDContains,omitempty"`
	SpdxIDHasPrefix    *string  `json:"spdxIDHasPrefix,omitempty"`
	SpdxIDHasSuffix    *string  `json:"spdxIDHasSuffix,omitempty"`
	SpdxIDEqualFold    *string  `json:"spdxIDEqualFold,omitempty"`
	SpdxIDContainsFold *string  `json:"spdxIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "reference" field predicates.
	Reference             *string  `json:"reference,omitempty"`
	ReferenceNEQ          *string  `json:"referenceNEQ,omitempty"`
	ReferenceIn           []string `json:"referenceIn,omitempty"`
	ReferenceNotIn        []string `json:"referenceNotIn,omitempty"`
	ReferenceGT           *string  `json:"referenceGT,omitempty"`
	ReferenceGTE          *string  `json:"referenceGTE,omitempty"`
	ReferenceLT           *string  `json:"referenceLT,omitempty"`
	ReferenceLTE          *string  `json:"referenceLTE,omitempty"`
	ReferenceContains     *string  `json:"referenceContains,omitempty"`
	ReferenceHasPrefix    *string  `json:"referenceHasPrefix,omitempty"`
	ReferenceHasSuffix    *string  `json:"referenceHasSuffix,omitempty"`
	ReferenceIsNil        bool     `json:"referenceIsNil,omitempty"`
	ReferenceNotNil       bool     `json:"referenceNotNil,omitempty"`
	ReferenceEqualFold    *string  `json:"referenceEqualFold,omitempty"`
	ReferenceContainsFold *string  `json:"referenceContainsFold,omitempty"`

	// "details_url" field predicates.
	DetailsURL             *string  `json:"detailsURL,omitempty"`
	DetailsURLNEQ          *string  `json:"detailsURLNEQ,omitempty"`
	DetailsURLIn           []string `json:"detailsURLIn,omitempty"`
	DetailsURLNotIn        []string `json:"detailsURLNotIn,omitempty"`
	DetailsURLGT           *string  `json:"detailsURLGT,omitempty"`
	DetailsURLGTE          *string  `json:"detailsURLGTE,omitempty"`
	DetailsURLLT           *string  `json:"detailsURLLT,omitempty"`
	DetailsURLLTE          *string  `json:"detailsURLLTE,omitempty"`
	DetailsURLContains     *string  `json:"detailsURLContains,omitempty"`
	DetailsURLHasPrefix    *string  `json:"detailsURLHasPrefix,omitempty"`
	DetailsURLHasSuffix    *string  `json:"detailsURLHasSuffix,omitempty"`
	DetailsURLIsNil        bool     `json:"detailsURLIsNil,omitempty"`
	DetailsURLNotNil       bool     `json:"detailsURLNotNil,omitempty"`
	DetailsURLEqualFold    *string  `json:"detailsURLEqualFold,omitempty"`
	DetailsURLContainsFold *string  `json:"detailsURLContainsFold,omitempty"`

	// "is_osi_approved" field predicates.
	IsOsiApproved    *bool `json:"isOsiApproved,omitempty"`
	IsOsiApprovedNEQ *bool `json:"isOsiApprovedNEQ,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                  `json:"hasComponents,omitempty"`
	HasComponentsWith []*ComponentWhereInput `json:"hasComponentsWith,omitempty"`

	// "uses" edge predicates.
	HasUses     *bool                   `json:"hasUses,omitempty"`
	HasUsesWith []*LicenseUseWhereInput `json:"hasUsesWith,omitempty"`
}

// Filter applies the LicenseWhereInput filter on the LicenseQuery builder.
func (i *LicenseWhereInput) Filter(q *LicenseQuery) (*LicenseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering licenses.
// An error is returned if the input is empty or invalid.
func (i *LicenseWhereInput) P() (predicate.License, error) {
	var predicates []predicate.License
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, license.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.License, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, license.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.License, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, license.And(and...))
	}
	if i.SpdxID != nil {
		predicates = append(predicates, license.SpdxIDEQ(*i.SpdxID))
	}
	if i.SpdxIDNEQ != nil {
		predicates = append(predicates, license.SpdxIDNEQ(*i.SpdxIDNEQ))
	}
	if len(i.SpdxIDIn) > 0 {
		predicates = append(predicates, license.SpdxIDIn(i.SpdxIDIn...))
	}
	if len(i.SpdxIDNotIn) > 0 {
		predicates = append(predicates, license.SpdxIDNotIn(i.SpdxIDNotIn...))
	}
	if i.SpdxIDGT != nil {
		predicates = append(predicates, license.SpdxIDGT(*i.SpdxIDGT))
	}
	if i.SpdxIDGTE != nil {
		predicates = append(predicates, license.SpdxIDGTE(*i.SpdxIDGTE))
	}
	if i.SpdxIDLT != nil {
		predicates = append(predicates, license.SpdxIDLT(*i.SpdxIDLT))
	}
	if i.SpdxIDLTE != nil {
		predicates = append(predicates, license.SpdxIDLTE(*i.SpdxIDLTE))
	}
	if i.SpdxIDContains != nil {
		predicates = append(predicates, license.SpdxIDContains(*i.SpdxIDContains))
	}
	if i.SpdxIDHasPrefix != nil {
		predicates = append(predicates, license.SpdxIDHasPrefix(*i.SpdxIDHasPrefix))
	}
	if i.SpdxIDHasSuffix != nil {
		predicates = append(predicates, license.SpdxIDHasSuffix(*i.SpdxIDHasSuffix))
	}
	if i.SpdxIDEqualFold != nil {
		predicates = append(predicates, license.SpdxIDEqualFold(*i.SpdxIDEqualFold))
	}
	if i.SpdxIDContainsFold != nil {
		predicates = append(predicates, license.SpdxIDContainsFold(*i.SpdxIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, license.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, license.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, license.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, license.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, license.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, license.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, license.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, license.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, license.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, license.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, license.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, license.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, license.NameContainsFold(*i.NameContainsFold))
	}
	if i.Reference != nil {
		predicates = append(predicates, license.ReferenceEQ(*i.Reference))
	}
	if i.ReferenceNEQ != nil {
		predicates = append(predicates, license.ReferenceNEQ(*i.ReferenceNEQ))
	}
	if len(i.ReferenceIn) > 0 {
		predicates = append(predicates, license.ReferenceIn(i.ReferenceIn...))
	}
	if len(i.ReferenceNotIn) > 0 {
		predicates = append(predicates, license.ReferenceNotIn(i.ReferenceNotIn...))
	}
	if i.ReferenceGT != nil {
		predicates = append(predicates, license.ReferenceGT(*i.ReferenceGT))
	}
	if i.ReferenceGTE != nil {
		predicates = append(predicates, license.ReferenceGTE(*i.ReferenceGTE))
	}
	if i.ReferenceLT != nil {
		predicates = append(predicates, license.ReferenceLT(*i.ReferenceLT))
	}
	if i.ReferenceLTE != nil {
		predicates = append(predicates, license.ReferenceLTE(*i.ReferenceLTE))
	}
	if i.ReferenceContains != nil {
		predicates = append(predicates, license.ReferenceContains(*i.ReferenceContains))
	}
	if i.ReferenceHasPrefix != nil {
		predicates = append(predicates, license.ReferenceHasPrefix(*i.ReferenceHasPrefix))
	}
	if i.ReferenceHasSuffix != nil {
		predicates = append(predicates, license.ReferenceHasSuffix(*i.ReferenceHasSuffix))
	}
	if i.ReferenceIsNil {
		predicates = append(predicates, license.ReferenceIsNil())
	}
	if i.ReferenceNotNil {
		predicates = append(predicates, license.ReferenceNotNil())
	}
	if i.ReferenceEqualFold != nil {
		predicates = append(predicates, license.ReferenceEqualFold(*i.ReferenceEqualFold))
	}
	if i.ReferenceContainsFold != nil {
		predicates = append(predicates, license.ReferenceContainsFold(*i.ReferenceContainsFold))
	}
	if i.DetailsURL != nil {
		predicates = append(predicates, license.DetailsURLEQ(*i.DetailsURL))
	}
	if i.DetailsURLNEQ != nil {
		predicates = append(predicates, license.DetailsURLNEQ(*i.DetailsURLNEQ))
	}
	if len(i.DetailsURLIn) > 0 {
		predicates = append(predicates, license.DetailsURLIn(i.DetailsURLIn...))
	}
	if len(i.DetailsURLNotIn) > 0 {
		predicates = append(predicates, license.DetailsURLNotIn(i.DetailsURLNotIn...))
	}
	if i.DetailsURLGT != nil {
		predicates = append(predicates, license.DetailsURLGT(*i.DetailsURLGT))
	}
	if i.DetailsURLGTE != nil {
		predicates = append(predicates, license.DetailsURLGTE(*i.DetailsURLGTE))
	}
	if i.DetailsURLLT != nil {
		predicates = append(predicates, license.DetailsURLLT(*i.DetailsURLLT))
	}
	if i.DetailsURLLTE != nil {
		predicates = append(predicates, license.DetailsURLLTE(*i.DetailsURLLTE))
	}
	if i.DetailsURLContains != nil {
		predicates = append(predicates, license.DetailsURLContains(*i.DetailsURLContains))
	}
	if i.DetailsURLHasPrefix != nil {
		predicates = append(predicates, license.DetailsURLHasPrefix(*i.DetailsURLHasPrefix))
	}
	if i.DetailsURLHasSuffix != nil {
		predicates = append(predicates, license.DetailsURLHasSuffix(*i.DetailsURLHasSuffix))
	}
	if i.DetailsURLIsNil {
		predicates = append(predicates, license.DetailsURLIsNil())
	}
	if i.DetailsURLNotNil {
		predicates = append(predicates, license.DetailsURLNotNil())
	}
	if i.DetailsURLEqualFold != nil {
		predicates = append(predicates, license.DetailsURLEqualFold(*i.DetailsURLEqualFold))
	}
	if i.DetailsURLContainsFold != nil {
		predicates = append(predicates, license.DetailsURLContainsFold(*i.DetailsURLContainsFold))
	}
	if i.IsOsiApproved != nil {
		predicates = append(predicates, license.IsOsiApprovedEQ(*i.IsOsiApproved))
	}
	if i.IsOsiApprovedNEQ != nil {
		predicates = append(predicates, license.IsOsiApprovedNEQ(*i.IsOsiApprovedNEQ))
	}
	if i.ID != nil {
		predicates = append(predicates, license.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, license.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, license.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, license.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, license.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, license.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, license.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, license.IDLTE(*i.IDLTE))
	}

	if i.HasComponents != nil {
		p := license.HasComponents()
		if !*i.HasComponents {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.Component, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasComponentsWith(with...))
	}
	if i.HasUses != nil {
		p := license.HasUses()
		if !*i.HasUses {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsesWith) > 0 {
		with := make([]predicate.LicenseUse, 0, len(i.HasUsesWith))
		for _, w := range i.HasUsesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasUsesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate LicenseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return license.And(predicates...), nil
	}
}

// LicenseUseWhereInput represents a where input for filtering LicenseUse queries.
type LicenseUseWhereInput struct {
	Not *LicenseUseWhereInput   `json:"not,omitempty"`
	Or  []*LicenseUseWhereInput `json:"or,omitempty"`
	And []*LicenseUseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "license" edge predicates.
	HasLicense     *bool                `json:"hasLicense,omitempty"`
	HasLicenseWith []*LicenseWhereInput `json:"hasLicenseWith,omitempty"`
}

// Filter applies the LicenseUseWhereInput filter on the LicenseUseQuery builder.
func (i *LicenseUseWhereInput) Filter(q *LicenseUseQuery) (*LicenseUseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering licenseuses.
// An error is returned if the input is empty or invalid.
func (i *LicenseUseWhereInput) P() (predicate.LicenseUse, error) {
	var predicates []predicate.LicenseUse
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, licenseuse.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.LicenseUse, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, licenseuse.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.LicenseUse, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, licenseuse.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, licenseuse.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, licenseuse.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, licenseuse.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, licenseuse.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, licenseuse.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, licenseuse.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, licenseuse.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, licenseuse.IDLTE(*i.IDLTE))
	}

	if i.HasLicense != nil {
		p := licenseuse.HasLicense()
		if !*i.HasLicense {
			p = licenseuse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicenseWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicenseWith))
		for _, w := range i.HasLicenseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, licenseuse.HasLicenseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate LicenseUseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return licenseuse.And(predicates...), nil
	}
}

// OrganizationWhereInput represents a where input for filtering Organization queries.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "repos" edge predicates.
	HasRepos     *bool             `json:"hasRepos,omitempty"`
	HasReposWith []*RepoWhereInput `json:"hasReposWith,omitempty"`
}

// Filter applies the OrganizationWhereInput filter on the OrganizationQuery builder.
func (i *OrganizationWhereInput) Filter(q *OrganizationQuery) (*OrganizationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering organizations.
// An error is returned if the input is empty or invalid.
func (i *OrganizationWhereInput) P() (predicate.Organization, error) {
	var predicates []predicate.Organization
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, organization.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Organization, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, organization.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Organization, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, organization.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, organization.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, organization.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, organization.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, organization.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, organization.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, organization.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, organization.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, organization.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, organization.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, organization.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, organization.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, organization.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, organization.NameContainsFold(*i.NameContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, organization.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, organization.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, organization.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, organization.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, organization.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, organization.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, organization.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, organization.IDLTE(*i.IDLTE))
	}

	if i.HasProjects != nil {
		p := organization.HasProjects()
		if !*i.HasProjects {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasProjectsWith(with...))
	}
	if i.HasRepos != nil {
		p := organization.HasRepos()
		if !*i.HasRepos {
			p = organization.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReposWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasReposWith))
		for _, w := range i.HasReposWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, organization.HasReposWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate OrganizationWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return organization.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Not *ProjectWhereInput   `json:"not,omitempty"`
	Or  []*ProjectWhereInput `json:"or,omitempty"`
	And []*ProjectWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "repos" edge predicates.
	HasRepos     *bool             `json:"hasRepos,omitempty"`
	HasReposWith []*RepoWhereInput `json:"hasReposWith,omitempty"`

	// "vulnerability_reviews" edge predicates.
	HasVulnerabilityReviews     *bool                            `json:"hasVulnerabilityReviews,omitempty"`
	HasVulnerabilityReviewsWith []*VulnerabilityReviewWhereInput `json:"hasVulnerabilityReviewsWith,omitempty"`

	// "policies" edge predicates.
	HasPolicies     *bool                      `json:"hasPolicies,omitempty"`
	HasPoliciesWith []*ReleasePolicyWhereInput `json:"hasPoliciesWith,omitempty"`
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, project.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, project.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, project.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, project.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, project.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, project.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, project.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, project.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, project.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, project.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, project.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, project.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, project.NameContainsFold(*i.NameContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}

	if i.HasOwner != nil {
		p := project.HasOwner()
		if !*i.HasOwner {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasOwnerWith(with...))
	}
	if i.HasRepos != nil {
		p := project.HasRepos()
		if !*i.HasRepos {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReposWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasReposWith))
		for _, w := range i.HasReposWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasReposWith(with...))
	}
	if i.HasVulnerabilityReviews != nil {
		p := project.HasVulnerabilityReviews()
		if !*i.HasVulnerabilityReviews {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilityReviewsWith) > 0 {
		with := make([]predicate.VulnerabilityReview, 0, len(i.HasVulnerabilityReviewsWith))
		for _, w := range i.HasVulnerabilityReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasVulnerabilityReviewsWith(with...))
	}
	if i.HasPolicies != nil {
		p := project.HasPolicies()
		if !*i.HasPolicies {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliciesWith) > 0 {
		with := make([]predicate.ReleasePolicy, 0, len(i.HasPoliciesWith))
		for _, w := range i.HasPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasPoliciesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ProjectWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// ReleaseWhereInput represents a where input for filtering Release queries.
type ReleaseWhereInput struct {
	Not *ReleaseWhereInput   `json:"not,omitempty"`
	Or  []*ReleaseWhereInput `json:"or,omitempty"`
	And []*ReleaseWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *release.Status  `json:"status,omitempty"`
	StatusNEQ   *release.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []release.Status `json:"statusIn,omitempty"`
	StatusNotIn []release.Status `json:"statusNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "subreleases" edge predicates.
	HasSubreleases     *bool                `json:"hasSubreleases,omitempty"`
	HasSubreleasesWith []*ReleaseWhereInput `json:"hasSubreleasesWith,omitempty"`

	// "dependencies" edge predicates.
	HasDependencies     *bool                `json:"hasDependencies,omitempty"`
	HasDependenciesWith []*ReleaseWhereInput `json:"hasDependenciesWith,omitempty"`

	// "commit" edge predicates.
	HasCommit     *bool                  `json:"hasCommit,omitempty"`
	HasCommitWith []*GitCommitWhereInput `json:"hasCommitWith,omitempty"`

	// "head_of" edge predicates.
	HasHeadOf     *bool             `json:"hasHeadOf,omitempty"`
	HasHeadOfWith []*RepoWhereInput `json:"hasHeadOfWith,omitempty"`

	// "log" edge predicates.
	HasLog     *bool                     `json:"hasLog,omitempty"`
	HasLogWith []*ReleaseEntryWhereInput `json:"hasLogWith,omitempty"`

	// "violations" edge predicates.
	HasViolations     *bool                               `json:"hasViolations,omitempty"`
	HasViolationsWith []*ReleasePolicyViolationWhereInput `json:"hasViolationsWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                         `json:"hasComponents,omitempty"`
	HasComponentsWith []*ReleaseComponentWhereInput `json:"hasComponentsWith,omitempty"`

	// "vulnerabilities" edge predicates.
	HasVulnerabilities     *bool                             `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*ReleaseVulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`

	// "code_scans" edge predicates.
	HasCodeScans     *bool                 `json:"hasCodeScans,omitempty"`
	HasCodeScansWith []*CodeScanWhereInput `json:"hasCodeScansWith,omitempty"`

	// "test_runs" edge predicates.
	HasTestRuns     *bool                `json:"hasTestRuns,omitempty"`
	HasTestRunsWith []*TestRunWhereInput `json:"hasTestRunsWith,omitempty"`

	// "vulnerability_reviews" edge predicates.
	HasVulnerabilityReviews     *bool                            `json:"hasVulnerabilityReviews,omitempty"`
	HasVulnerabilityReviewsWith []*VulnerabilityReviewWhereInput `json:"hasVulnerabilityReviewsWith,omitempty"`
}

// Filter applies the ReleaseWhereInput filter on the ReleaseQuery builder.
func (i *ReleaseWhereInput) Filter(q *ReleaseQuery) (*ReleaseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releases.
// An error is returned if the input is empty or invalid.
func (i *ReleaseWhereInput) P() (predicate.Release, error) {
	var predicates []predicate.Release
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, release.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Release, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, release.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Release, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, release.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, release.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, release.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, release.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, release.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, release.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, release.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, release.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, release.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, release.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, release.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, release.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, release.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, release.NameContainsFold(*i.NameContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, release.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, release.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, release.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, release.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, release.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, release.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, release.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, release.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, release.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, release.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, release.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, release.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, release.VersionContainsFold(*i.VersionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, release.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, release.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, release.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, release.StatusNotIn(i.StatusNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, release.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, release.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, release.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, release.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, release.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, release.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, release.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, release.IDLTE(*i.IDLTE))
	}

	if i.HasSubreleases != nil {
		p := release.HasSubreleases()
		if !*i.HasSubreleases {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubreleasesWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasSubreleasesWith))
		for _, w := range i.HasSubreleasesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasSubreleasesWith(with...))
	}
	if i.HasDependencies != nil {
		p := release.HasDependencies()
		if !*i.HasDependencies {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDependenciesWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasDependenciesWith))
		for _, w := range i.HasDependenciesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasDependenciesWith(with...))
	}
	if i.HasCommit != nil {
		p := release.HasCommit()
		if !*i.HasCommit {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommitWith) > 0 {
		with := make([]predicate.GitCommit, 0, len(i.HasCommitWith))
		for _, w := range i.HasCommitWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasCommitWith(with...))
	}
	if i.HasHeadOf != nil {
		p := release.HasHeadOf()
		if !*i.HasHeadOf {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHeadOfWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasHeadOfWith))
		for _, w := range i.HasHeadOfWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasHeadOfWith(with...))
	}
	if i.HasLog != nil {
		p := release.HasLog()
		if !*i.HasLog {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasLogWith))
		for _, w := range i.HasLogWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasLogWith(with...))
	}
	if i.HasViolations != nil {
		p := release.HasViolations()
		if !*i.HasViolations {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViolationsWith) > 0 {
		with := make([]predicate.ReleasePolicyViolation, 0, len(i.HasViolationsWith))
		for _, w := range i.HasViolationsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasViolationsWith(with...))
	}
	if i.HasArtifacts != nil {
		p := release.HasArtifacts()
		if !*i.HasArtifacts {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasArtifactsWith(with...))
	}
	if i.HasComponents != nil {
		p := release.HasComponents()
		if !*i.HasComponents {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.ReleaseComponent, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasComponentsWith(with...))
	}
	if i.HasVulnerabilities != nil {
		p := release.HasVulnerabilities()
		if !*i.HasVulnerabilities {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilitiesWith) > 0 {
		with := make([]predicate.ReleaseVulnerability, 0, len(i.HasVulnerabilitiesWith))
		for _, w := range i.HasVulnerabilitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasVulnerabilitiesWith(with...))
	}
	if i.HasCodeScans != nil {
		p := release.HasCodeScans()
		if !*i.HasCodeScans {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCodeScansWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasCodeScansWith))
		for _, w := range i.HasCodeScansWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasCodeScansWith(with...))
	}
	if i.HasTestRuns != nil {
		p := release.HasTestRuns()
		if !*i.HasTestRuns {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestRunsWith) > 0 {
		with := make([]predicate.TestRun, 0, len(i.HasTestRunsWith))
		for _, w := range i.HasTestRunsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasTestRunsWith(with...))
	}
	if i.HasVulnerabilityReviews != nil {
		p := release.HasVulnerabilityReviews()
		if !*i.HasVulnerabilityReviews {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilityReviewsWith) > 0 {
		with := make([]predicate.VulnerabilityReview, 0, len(i.HasVulnerabilityReviewsWith))
		for _, w := range i.HasVulnerabilityReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasVulnerabilityReviewsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleaseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return release.And(predicates...), nil
	}
}

// ReleaseComponentWhereInput represents a where input for filtering ReleaseComponent queries.
type ReleaseComponentWhereInput struct {
	Not *ReleaseComponentWhereInput   `json:"not,omitempty"`
	Or  []*ReleaseComponentWhereInput `json:"or,omitempty"`
	And []*ReleaseComponentWhereInput `json:"and,omitempty"`

	// "type" field predicates.
	Type      *releasecomponent.Type  `json:"type,omitempty"`
	TypeNEQ   *releasecomponent.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []releasecomponent.Type `json:"typeIn,omitempty"`
	TypeNotIn []releasecomponent.Type `json:"typeNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "scans" edge predicates.
	HasScans     *bool                 `json:"hasScans,omitempty"`
	HasScansWith []*CodeScanWhereInput `json:"hasScansWith,omitempty"`

	// "component" edge predicates.
	HasComponent     *bool                  `json:"hasComponent,omitempty"`
	HasComponentWith []*ComponentWhereInput `json:"hasComponentWith,omitempty"`

	// "vulnerabilities" edge predicates.
	HasVulnerabilities     *bool                             `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*ReleaseVulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`
}

// Filter applies the ReleaseComponentWhereInput filter on the ReleaseComponentQuery builder.
func (i *ReleaseComponentWhereInput) Filter(q *ReleaseComponentQuery) (*ReleaseComponentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releasecomponents.
// An error is returned if the input is empty or invalid.
func (i *ReleaseComponentWhereInput) P() (predicate.ReleaseComponent, error) {
	var predicates []predicate.ReleaseComponent
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, releasecomponent.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleaseComponent, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, releasecomponent.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleaseComponent, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, releasecomponent.And(and...))
	}
	if i.Type != nil {
		predicates = append(predicates, releasecomponent.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, releasecomponent.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, releasecomponent.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, releasecomponent.TypeNotIn(i.TypeNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, releasecomponent.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releasecomponent.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releasecomponent.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releasecomponent.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releasecomponent.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releasecomponent.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releasecomponent.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releasecomponent.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := releasecomponent.HasRelease()
		if !*i.HasRelease {
			p = releasecomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasecomponent.HasReleaseWith(with...))
	}
	if i.HasScans != nil {
		p := releasecomponent.HasScans()
		if !*i.HasScans {
			p = releasecomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScansWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasScansWith))
		for _, w := range i.HasScansWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasecomponent.HasScansWith(with...))
	}
	if i.HasComponent != nil {
		p := releasecomponent.HasComponent()
		if !*i.HasComponent {
			p = releasecomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentWith) > 0 {
		with := make([]predicate.Component, 0, len(i.HasComponentWith))
		for _, w := range i.HasComponentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasecomponent.HasComponentWith(with...))
	}
	if i.HasVulnerabilities != nil {
		p := releasecomponent.HasVulnerabilities()
		if !*i.HasVulnerabilities {
			p = releasecomponent.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilitiesWith) > 0 {
		with := make([]predicate.ReleaseVulnerability, 0, len(i.HasVulnerabilitiesWith))
		for _, w := range i.HasVulnerabilitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasecomponent.HasVulnerabilitiesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleaseComponentWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return releasecomponent.And(predicates...), nil
	}
}

// ReleaseEntryWhereInput represents a where input for filtering ReleaseEntry queries.
type ReleaseEntryWhereInput struct {
	Not *ReleaseEntryWhereInput   `json:"not,omitempty"`
	Or  []*ReleaseEntryWhereInput `json:"or,omitempty"`
	And []*ReleaseEntryWhereInput `json:"and,omitempty"`

	// "type" field predicates.
	Type      *releaseentry.Type  `json:"type,omitempty"`
	TypeNEQ   *releaseentry.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []releaseentry.Type `json:"typeIn,omitempty"`
	TypeNotIn []releaseentry.Type `json:"typeNotIn,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "artifact" edge predicates.
	HasArtifact     *bool                 `json:"hasArtifact,omitempty"`
	HasArtifactWith []*ArtifactWhereInput `json:"hasArtifactWith,omitempty"`

	// "code_scan" edge predicates.
	HasCodeScan     *bool                 `json:"hasCodeScan,omitempty"`
	HasCodeScanWith []*CodeScanWhereInput `json:"hasCodeScanWith,omitempty"`

	// "test_run" edge predicates.
	HasTestRun     *bool                `json:"hasTestRun,omitempty"`
	HasTestRunWith []*TestRunWhereInput `json:"hasTestRunWith,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`
}

// Filter applies the ReleaseEntryWhereInput filter on the ReleaseEntryQuery builder.
func (i *ReleaseEntryWhereInput) Filter(q *ReleaseEntryQuery) (*ReleaseEntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releaseentries.
// An error is returned if the input is empty or invalid.
func (i *ReleaseEntryWhereInput) P() (predicate.ReleaseEntry, error) {
	var predicates []predicate.ReleaseEntry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, releaseentry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleaseEntry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, releaseentry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleaseEntry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, releaseentry.And(and...))
	}
	if i.Type != nil {
		predicates = append(predicates, releaseentry.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, releaseentry.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, releaseentry.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, releaseentry.TypeNotIn(i.TypeNotIn...))
	}
	if i.Time != nil {
		predicates = append(predicates, releaseentry.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, releaseentry.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, releaseentry.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, releaseentry.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, releaseentry.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, releaseentry.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, releaseentry.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, releaseentry.TimeLTE(*i.TimeLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, releaseentry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releaseentry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releaseentry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releaseentry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releaseentry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releaseentry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releaseentry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releaseentry.IDLTE(*i.IDLTE))
	}

	if i.HasArtifact != nil {
		p := releaseentry.HasArtifact()
		if !*i.HasArtifact {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactWith))
		for _, w := range i.HasArtifactWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasArtifactWith(with...))
	}
	if i.HasCodeScan != nil {
		p := releaseentry.HasCodeScan()
		if !*i.HasCodeScan {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCodeScanWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasCodeScanWith))
		for _, w := range i.HasCodeScanWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasCodeScanWith(with...))
	}
	if i.HasTestRun != nil {
		p := releaseentry.HasTestRun()
		if !*i.HasTestRun {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestRunWith) > 0 {
		with := make([]predicate.TestRun, 0, len(i.HasTestRunWith))
		for _, w := range i.HasTestRunWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasTestRunWith(with...))
	}
	if i.HasRelease != nil {
		p := releaseentry.HasRelease()
		if !*i.HasRelease {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasReleaseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleaseEntryWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return releaseentry.And(predicates...), nil
	}
}

// ReleaseLicenseWhereInput represents a where input for filtering ReleaseLicense queries.
type ReleaseLicenseWhereInput struct {
	Not *ReleaseLicenseWhereInput   `json:"not,omitempty"`
	Or  []*ReleaseLicenseWhereInput `json:"or,omitempty"`
	And []*ReleaseLicenseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "license" edge predicates.
	HasLicense     *bool                `json:"hasLicense,omitempty"`
	HasLicenseWith []*LicenseWhereInput `json:"hasLicenseWith,omitempty"`

	// "component" edge predicates.
	HasComponent     *bool                         `json:"hasComponent,omitempty"`
	HasComponentWith []*ReleaseComponentWhereInput `json:"hasComponentWith,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "scans" edge predicates.
	HasScans     *bool                 `json:"hasScans,omitempty"`
	HasScansWith []*CodeScanWhereInput `json:"hasScansWith,omitempty"`
}

// Filter applies the ReleaseLicenseWhereInput filter on the ReleaseLicenseQuery builder.
func (i *ReleaseLicenseWhereInput) Filter(q *ReleaseLicenseQuery) (*ReleaseLicenseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releaselicenses.
// An error is returned if the input is empty or invalid.
func (i *ReleaseLicenseWhereInput) P() (predicate.ReleaseLicense, error) {
	var predicates []predicate.ReleaseLicense
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, releaselicense.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleaseLicense, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, releaselicense.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleaseLicense, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, releaselicense.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, releaselicense.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releaselicense.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releaselicense.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releaselicense.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releaselicense.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releaselicense.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releaselicense.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releaselicense.IDLTE(*i.IDLTE))
	}

	if i.HasLicense != nil {
		p := releaselicense.HasLicense()
		if !*i.HasLicense {
			p = releaselicense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicenseWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicenseWith))
		for _, w := range i.HasLicenseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaselicense.HasLicenseWith(with...))
	}
	if i.HasComponent != nil {
		p := releaselicense.HasComponent()
		if !*i.HasComponent {
			p = releaselicense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentWith) > 0 {
		with := make([]predicate.ReleaseComponent, 0, len(i.HasComponentWith))
		for _, w := range i.HasComponentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaselicense.HasComponentWith(with...))
	}
	if i.HasRelease != nil {
		p := releaselicense.HasRelease()
		if !*i.HasRelease {
			p = releaselicense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaselicense.HasReleaseWith(with...))
	}
	if i.HasScans != nil {
		p := releaselicense.HasScans()
		if !*i.HasScans {
			p = releaselicense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScansWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasScansWith))
		for _, w := range i.HasScansWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaselicense.HasScansWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleaseLicenseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return releaselicense.And(predicates...), nil
	}
}

// ReleasePolicyWhereInput represents a where input for filtering ReleasePolicy queries.
type ReleasePolicyWhereInput struct {
	Not *ReleasePolicyWhereInput   `json:"not,omitempty"`
	Or  []*ReleasePolicyWhereInput `json:"or,omitempty"`
	And []*ReleasePolicyWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "module" field predicates.
	Module             *string  `json:"module,omitempty"`
	ModuleNEQ          *string  `json:"moduleNEQ,omitempty"`
	ModuleIn           []string `json:"moduleIn,omitempty"`
	ModuleNotIn        []string `json:"moduleNotIn,omitempty"`
	ModuleGT           *string  `json:"moduleGT,omitempty"`
	ModuleGTE          *string  `json:"moduleGTE,omitempty"`
	ModuleLT           *string  `json:"moduleLT,omitempty"`
	ModuleLTE          *string  `json:"moduleLTE,omitempty"`
	ModuleContains     *string  `json:"moduleContains,omitempty"`
	ModuleHasPrefix    *string  `json:"moduleHasPrefix,omitempty"`
	ModuleHasSuffix    *string  `json:"moduleHasSuffix,omitempty"`
	ModuleEqualFold    *string  `json:"moduleEqualFold,omitempty"`
	ModuleContainsFold *string  `json:"moduleContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "repos" edge predicates.
	HasRepos     *bool             `json:"hasRepos,omitempty"`
	HasReposWith []*RepoWhereInput `json:"hasReposWith,omitempty"`

	// "violations" edge predicates.
	HasViolations     *bool                               `json:"hasViolations,omitempty"`
	HasViolationsWith []*ReleasePolicyViolationWhereInput `json:"hasViolationsWith,omitempty"`
}

// Filter applies the ReleasePolicyWhereInput filter on the ReleasePolicyQuery builder.
func (i *ReleasePolicyWhereInput) Filter(q *ReleasePolicyQuery) (*ReleasePolicyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releasepolicies.
// An error is returned if the input is empty or invalid.
func (i *ReleasePolicyWhereInput) P() (predicate.ReleasePolicy, error) {
	var predicates []predicate.ReleasePolicy
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, releasepolicy.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleasePolicy, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, releasepolicy.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleasePolicy, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, releasepolicy.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, releasepolicy.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, releasepolicy.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, releasepolicy.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, releasepolicy.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, releasepolicy.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, releasepolicy.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, releasepolicy.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, releasepolicy.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, releasepolicy.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, releasepolicy.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, releasepolicy.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, releasepolicy.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, releasepolicy.NameContainsFold(*i.NameContainsFold))
	}
	if i.Module != nil {
		predicates = append(predicates, releasepolicy.ModuleEQ(*i.Module))
	}
	if i.ModuleNEQ != nil {
		predicates = append(predicates, releasepolicy.ModuleNEQ(*i.ModuleNEQ))
	}
	if len(i.ModuleIn) > 0 {
		predicates = append(predicates, releasepolicy.ModuleIn(i.ModuleIn...))
	}
	if len(i.ModuleNotIn) > 0 {
		predicates = append(predicates, releasepolicy.ModuleNotIn(i.ModuleNotIn...))
	}
	if i.ModuleGT != nil {
		predicates = append(predicates, releasepolicy.ModuleGT(*i.ModuleGT))
	}
	if i.ModuleGTE != nil {
		predicates = append(predicates, releasepolicy.ModuleGTE(*i.ModuleGTE))
	}
	if i.ModuleLT != nil {
		predicates = append(predicates, releasepolicy.ModuleLT(*i.ModuleLT))
	}
	if i.ModuleLTE != nil {
		predicates = append(predicates, releasepolicy.ModuleLTE(*i.ModuleLTE))
	}
	if i.ModuleContains != nil {
		predicates = append(predicates, releasepolicy.ModuleContains(*i.ModuleContains))
	}
	if i.ModuleHasPrefix != nil {
		predicates = append(predicates, releasepolicy.ModuleHasPrefix(*i.ModuleHasPrefix))
	}
	if i.ModuleHasSuffix != nil {
		predicates = append(predicates, releasepolicy.ModuleHasSuffix(*i.ModuleHasSuffix))
	}
	if i.ModuleEqualFold != nil {
		predicates = append(predicates, releasepolicy.ModuleEqualFold(*i.ModuleEqualFold))
	}
	if i.ModuleContainsFold != nil {
		predicates = append(predicates, releasepolicy.ModuleContainsFold(*i.ModuleContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, releasepolicy.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releasepolicy.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releasepolicy.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releasepolicy.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releasepolicy.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releasepolicy.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releasepolicy.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releasepolicy.IDLTE(*i.IDLTE))
	}

	if i.HasProjects != nil {
		p := releasepolicy.HasProjects()
		if !*i.HasProjects {
			p = releasepolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasepolicy.HasProjectsWith(with...))
	}
	if i.HasRepos != nil {
		p := releasepolicy.HasRepos()
		if !*i.HasRepos {
			p = releasepolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReposWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasReposWith))
		for _, w := range i.HasReposWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasepolicy.HasReposWith(with...))
	}
	if i.HasViolations != nil {
		p := releasepolicy.HasViolations()
		if !*i.HasViolations {
			p = releasepolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasViolationsWith) > 0 {
		with := make([]predicate.ReleasePolicyViolation, 0, len(i.HasViolationsWith))
		for _, w := range i.HasViolationsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasepolicy.HasViolationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleasePolicyWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return releasepolicy.And(predicates...), nil
	}
}

// ReleasePolicyViolationWhereInput represents a where input for filtering ReleasePolicyViolation queries.
type ReleasePolicyViolationWhereInput struct {
	Not *ReleasePolicyViolationWhereInput   `json:"not,omitempty"`
	Or  []*ReleasePolicyViolationWhereInput `json:"or,omitempty"`
	And []*ReleasePolicyViolationWhereInput `json:"and,omitempty"`

	// "message" field predicates.
	Message             *string  `json:"message,omitempty"`
	MessageNEQ          *string  `json:"messageNEQ,omitempty"`
	MessageIn           []string `json:"messageIn,omitempty"`
	MessageNotIn        []string `json:"messageNotIn,omitempty"`
	MessageGT           *string  `json:"messageGT,omitempty"`
	MessageGTE          *string  `json:"messageGTE,omitempty"`
	MessageLT           *string  `json:"messageLT,omitempty"`
	MessageLTE          *string  `json:"messageLTE,omitempty"`
	MessageContains     *string  `json:"messageContains,omitempty"`
	MessageHasPrefix    *string  `json:"messageHasPrefix,omitempty"`
	MessageHasSuffix    *string  `json:"messageHasSuffix,omitempty"`
	MessageEqualFold    *string  `json:"messageEqualFold,omitempty"`
	MessageContainsFold *string  `json:"messageContainsFold,omitempty"`

	// "type" field predicates.
	Type      *releasepolicyviolation.Type  `json:"type,omitempty"`
	TypeNEQ   *releasepolicyviolation.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []releasepolicyviolation.Type `json:"typeIn,omitempty"`
	TypeNotIn []releasepolicyviolation.Type `json:"typeNotIn,omitempty"`

	// "severity" field predicates.
	Severity      *releasepolicyviolation.Severity  `json:"severity,omitempty"`
	SeverityNEQ   *releasepolicyviolation.Severity  `json:"severityNEQ,omitempty"`
	SeverityIn    []releasepolicyviolation.Severity `json:"severityIn,omitempty"`
	SeverityNotIn []releasepolicyviolation.Severity `json:"severityNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "policy" edge predicates.
	HasPolicy     *bool                      `json:"hasPolicy,omitempty"`
	HasPolicyWith []*ReleasePolicyWhereInput `json:"hasPolicyWith,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`
}

// Filter applies the ReleasePolicyViolationWhereInput filter on the ReleasePolicyViolationQuery builder.
func (i *ReleasePolicyViolationWhereInput) Filter(q *ReleasePolicyViolationQuery) (*ReleasePolicyViolationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releasepolicyviolations.
// An error is returned if the input is empty or invalid.
func (i *ReleasePolicyViolationWhereInput) P() (predicate.ReleasePolicyViolation, error) {
	var predicates []predicate.ReleasePolicyViolation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, releasepolicyviolation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleasePolicyViolation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, releasepolicyviolation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleasePolicyViolation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, releasepolicyviolation.And(and...))
	}
	if i.Message != nil {
		predicates = append(predicates, releasepolicyviolation.MessageEQ(*i.Message))
	}
	if i.MessageNEQ != nil {
		predicates = append(predicates, releasepolicyviolation.MessageNEQ(*i.MessageNEQ))
	}
	if len(i.MessageIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.MessageIn(i.MessageIn...))
	}
	if len(i.MessageNotIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.MessageNotIn(i.MessageNotIn...))
	}
	if i.MessageGT != nil {
		predicates = append(predicates, releasepolicyviolation.MessageGT(*i.MessageGT))
	}
	if i.MessageGTE != nil {
		predicates = append(predicates, releasepolicyviolation.MessageGTE(*i.MessageGTE))
	}
	if i.MessageLT != nil {
		predicates = append(predicates, releasepolicyviolation.MessageLT(*i.MessageLT))
	}
	if i.MessageLTE != nil {
		predicates = append(predicates, releasepolicyviolation.MessageLTE(*i.MessageLTE))
	}
	if i.MessageContains != nil {
		predicates = append(predicates, releasepolicyviolation.MessageContains(*i.MessageContains))
	}
	if i.MessageHasPrefix != nil {
		predicates = append(predicates, releasepolicyviolation.MessageHasPrefix(*i.MessageHasPrefix))
	}
	if i.MessageHasSuffix != nil {
		predicates = append(predicates, releasepolicyviolation.MessageHasSuffix(*i.MessageHasSuffix))
	}
	if i.MessageEqualFold != nil {
		predicates = append(predicates, releasepolicyviolation.MessageEqualFold(*i.MessageEqualFold))
	}
	if i.MessageContainsFold != nil {
		predicates = append(predicates, releasepolicyviolation.MessageContainsFold(*i.MessageContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, releasepolicyviolation.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, releasepolicyviolation.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.TypeNotIn(i.TypeNotIn...))
	}
	if i.Severity != nil {
		predicates = append(predicates, releasepolicyviolation.SeverityEQ(*i.Severity))
	}
	if i.SeverityNEQ != nil {
		predicates = append(predicates, releasepolicyviolation.SeverityNEQ(*i.SeverityNEQ))
	}
	if len(i.SeverityIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.SeverityIn(i.SeverityIn...))
	}
	if len(i.SeverityNotIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.SeverityNotIn(i.SeverityNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, releasepolicyviolation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releasepolicyviolation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releasepolicyviolation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releasepolicyviolation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releasepolicyviolation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releasepolicyviolation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releasepolicyviolation.IDLTE(*i.IDLTE))
	}

	if i.HasPolicy != nil {
		p := releasepolicyviolation.HasPolicy()
		if !*i.HasPolicy {
			p = releasepolicyviolation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPolicyWith) > 0 {
		with := make([]predicate.ReleasePolicy, 0, len(i.HasPolicyWith))
		for _, w := range i.HasPolicyWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasepolicyviolation.HasPolicyWith(with...))
	}
	if i.HasRelease != nil {
		p := releasepolicyviolation.HasRelease()
		if !*i.HasRelease {
			p = releasepolicyviolation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasepolicyviolation.HasReleaseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleasePolicyViolationWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return releasepolicyviolation.And(predicates...), nil
	}
}

// ReleaseVulnerabilityWhereInput represents a where input for filtering ReleaseVulnerability queries.
type ReleaseVulnerabilityWhereInput struct {
	Not *ReleaseVulnerabilityWhereInput   `json:"not,omitempty"`
	Or  []*ReleaseVulnerabilityWhereInput `json:"or,omitempty"`
	And []*ReleaseVulnerabilityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "vulnerability" edge predicates.
	HasVulnerability     *bool                      `json:"hasVulnerability,omitempty"`
	HasVulnerabilityWith []*VulnerabilityWhereInput `json:"hasVulnerabilityWith,omitempty"`

	// "component" edge predicates.
	HasComponent     *bool                         `json:"hasComponent,omitempty"`
	HasComponentWith []*ReleaseComponentWhereInput `json:"hasComponentWith,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "reviews" edge predicates.
	HasReviews     *bool                            `json:"hasReviews,omitempty"`
	HasReviewsWith []*VulnerabilityReviewWhereInput `json:"hasReviewsWith,omitempty"`

	// "scan" edge predicates.
	HasScan     *bool                 `json:"hasScan,omitempty"`
	HasScanWith []*CodeScanWhereInput `json:"hasScanWith,omitempty"`
}

// Filter applies the ReleaseVulnerabilityWhereInput filter on the ReleaseVulnerabilityQuery builder.
func (i *ReleaseVulnerabilityWhereInput) Filter(q *ReleaseVulnerabilityQuery) (*ReleaseVulnerabilityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releasevulnerabilities.
// An error is returned if the input is empty or invalid.
func (i *ReleaseVulnerabilityWhereInput) P() (predicate.ReleaseVulnerability, error) {
	var predicates []predicate.ReleaseVulnerability
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, releasevulnerability.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleaseVulnerability, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, releasevulnerability.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleaseVulnerability, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, releasevulnerability.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, releasevulnerability.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releasevulnerability.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releasevulnerability.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releasevulnerability.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releasevulnerability.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releasevulnerability.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releasevulnerability.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releasevulnerability.IDLTE(*i.IDLTE))
	}

	if i.HasVulnerability != nil {
		p := releasevulnerability.HasVulnerability()
		if !*i.HasVulnerability {
			p = releasevulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilityWith) > 0 {
		with := make([]predicate.Vulnerability, 0, len(i.HasVulnerabilityWith))
		for _, w := range i.HasVulnerabilityWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasevulnerability.HasVulnerabilityWith(with...))
	}
	if i.HasComponent != nil {
		p := releasevulnerability.HasComponent()
		if !*i.HasComponent {
			p = releasevulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentWith) > 0 {
		with := make([]predicate.ReleaseComponent, 0, len(i.HasComponentWith))
		for _, w := range i.HasComponentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasevulnerability.HasComponentWith(with...))
	}
	if i.HasRelease != nil {
		p := releasevulnerability.HasRelease()
		if !*i.HasRelease {
			p = releasevulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasevulnerability.HasReleaseWith(with...))
	}
	if i.HasReviews != nil {
		p := releasevulnerability.HasReviews()
		if !*i.HasReviews {
			p = releasevulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReviewsWith) > 0 {
		with := make([]predicate.VulnerabilityReview, 0, len(i.HasReviewsWith))
		for _, w := range i.HasReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasevulnerability.HasReviewsWith(with...))
	}
	if i.HasScan != nil {
		p := releasevulnerability.HasScan()
		if !*i.HasScan {
			p = releasevulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScanWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasScanWith))
		for _, w := range i.HasScanWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releasevulnerability.HasScanWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleaseVulnerabilityWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return releasevulnerability.And(predicates...), nil
	}
}

// RepoWhereInput represents a where input for filtering Repo queries.
type RepoWhereInput struct {
	Not *RepoWhereInput   `json:"not,omitempty"`
	Or  []*RepoWhereInput `json:"or,omitempty"`
	And []*RepoWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "default_branch" field predicates.
	DefaultBranch             *string  `json:"defaultBranch,omitempty"`
	DefaultBranchNEQ          *string  `json:"defaultBranchNEQ,omitempty"`
	DefaultBranchIn           []string `json:"defaultBranchIn,omitempty"`
	DefaultBranchNotIn        []string `json:"defaultBranchNotIn,omitempty"`
	DefaultBranchGT           *string  `json:"defaultBranchGT,omitempty"`
	DefaultBranchGTE          *string  `json:"defaultBranchGTE,omitempty"`
	DefaultBranchLT           *string  `json:"defaultBranchLT,omitempty"`
	DefaultBranchLTE          *string  `json:"defaultBranchLTE,omitempty"`
	DefaultBranchContains     *string  `json:"defaultBranchContains,omitempty"`
	DefaultBranchHasPrefix    *string  `json:"defaultBranchHasPrefix,omitempty"`
	DefaultBranchHasSuffix    *string  `json:"defaultBranchHasSuffix,omitempty"`
	DefaultBranchEqualFold    *string  `json:"defaultBranchEqualFold,omitempty"`
	DefaultBranchContainsFold *string  `json:"defaultBranchContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "head" edge predicates.
	HasHead     *bool                `json:"hasHead,omitempty"`
	HasHeadWith []*ReleaseWhereInput `json:"hasHeadWith,omitempty"`

	// "commits" edge predicates.
	HasCommits     *bool                  `json:"hasCommits,omitempty"`
	HasCommitsWith []*GitCommitWhereInput `json:"hasCommitsWith,omitempty"`

	// "vulnerability_reviews" edge predicates.
	HasVulnerabilityReviews     *bool                            `json:"hasVulnerabilityReviews,omitempty"`
	HasVulnerabilityReviewsWith []*VulnerabilityReviewWhereInput `json:"hasVulnerabilityReviewsWith,omitempty"`

	// "policies" edge predicates.
	HasPolicies     *bool                      `json:"hasPolicies,omitempty"`
	HasPoliciesWith []*ReleasePolicyWhereInput `json:"hasPoliciesWith,omitempty"`
}

// Filter applies the RepoWhereInput filter on the RepoQuery builder.
func (i *RepoWhereInput) Filter(q *RepoQuery) (*RepoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering repos.
// An error is returned if the input is empty or invalid.
func (i *RepoWhereInput) P() (predicate.Repo, error) {
	var predicates []predicate.Repo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, repo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Repo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, repo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Repo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, repo.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, repo.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, repo.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, repo.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, repo.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, repo.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, repo.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, repo.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, repo.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, repo.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, repo.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, repo.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, repo.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, repo.NameContainsFold(*i.NameContainsFold))
	}
	if i.DefaultBranch != nil {
		predicates = append(predicates, repo.DefaultBranchEQ(*i.DefaultBranch))
	}
	if i.DefaultBranchNEQ != nil {
		predicates = append(predicates, repo.DefaultBranchNEQ(*i.DefaultBranchNEQ))
	}
	if len(i.DefaultBranchIn) > 0 {
		predicates = append(predicates, repo.DefaultBranchIn(i.DefaultBranchIn...))
	}
	if len(i.DefaultBranchNotIn) > 0 {
		predicates = append(predicates, repo.DefaultBranchNotIn(i.DefaultBranchNotIn...))
	}
	if i.DefaultBranchGT != nil {
		predicates = append(predicates, repo.DefaultBranchGT(*i.DefaultBranchGT))
	}
	if i.DefaultBranchGTE != nil {
		predicates = append(predicates, repo.DefaultBranchGTE(*i.DefaultBranchGTE))
	}
	if i.DefaultBranchLT != nil {
		predicates = append(predicates, repo.DefaultBranchLT(*i.DefaultBranchLT))
	}
	if i.DefaultBranchLTE != nil {
		predicates = append(predicates, repo.DefaultBranchLTE(*i.DefaultBranchLTE))
	}
	if i.DefaultBranchContains != nil {
		predicates = append(predicates, repo.DefaultBranchContains(*i.DefaultBranchContains))
	}
	if i.DefaultBranchHasPrefix != nil {
		predicates = append(predicates, repo.DefaultBranchHasPrefix(*i.DefaultBranchHasPrefix))
	}
	if i.DefaultBranchHasSuffix != nil {
		predicates = append(predicates, repo.DefaultBranchHasSuffix(*i.DefaultBranchHasSuffix))
	}
	if i.DefaultBranchEqualFold != nil {
		predicates = append(predicates, repo.DefaultBranchEqualFold(*i.DefaultBranchEqualFold))
	}
	if i.DefaultBranchContainsFold != nil {
		predicates = append(predicates, repo.DefaultBranchContainsFold(*i.DefaultBranchContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, repo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, repo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, repo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, repo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, repo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, repo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, repo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, repo.IDLTE(*i.IDLTE))
	}

	if i.HasOwner != nil {
		p := repo.HasOwner()
		if !*i.HasOwner {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.Organization, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasOwnerWith(with...))
	}
	if i.HasProject != nil {
		p := repo.HasProject()
		if !*i.HasProject {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasProjectWith(with...))
	}
	if i.HasHead != nil {
		p := repo.HasHead()
		if !*i.HasHead {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHeadWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasHeadWith))
		for _, w := range i.HasHeadWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasHeadWith(with...))
	}
	if i.HasCommits != nil {
		p := repo.HasCommits()
		if !*i.HasCommits {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommitsWith) > 0 {
		with := make([]predicate.GitCommit, 0, len(i.HasCommitsWith))
		for _, w := range i.HasCommitsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasCommitsWith(with...))
	}
	if i.HasVulnerabilityReviews != nil {
		p := repo.HasVulnerabilityReviews()
		if !*i.HasVulnerabilityReviews {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilityReviewsWith) > 0 {
		with := make([]predicate.VulnerabilityReview, 0, len(i.HasVulnerabilityReviewsWith))
		for _, w := range i.HasVulnerabilityReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasVulnerabilityReviewsWith(with...))
	}
	if i.HasPolicies != nil {
		p := repo.HasPolicies()
		if !*i.HasPolicies {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliciesWith) > 0 {
		with := make([]predicate.ReleasePolicy, 0, len(i.HasPoliciesWith))
		for _, w := range i.HasPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasPoliciesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate RepoWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return repo.And(predicates...), nil
	}
}

// TestCaseWhereInput represents a where input for filtering TestCase queries.
type TestCaseWhereInput struct {
	Not *TestCaseWhereInput   `json:"not,omitempty"`
	Or  []*TestCaseWhereInput `json:"or,omitempty"`
	And []*TestCaseWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "result" field predicates.
	Result    *bool `json:"result,omitempty"`
	ResultNEQ *bool `json:"resultNEQ,omitempty"`

	// "message" field predicates.
	Message             *string  `json:"message,omitempty"`
	MessageNEQ          *string  `json:"messageNEQ,omitempty"`
	MessageIn           []string `json:"messageIn,omitempty"`
	MessageNotIn        []string `json:"messageNotIn,omitempty"`
	MessageGT           *string  `json:"messageGT,omitempty"`
	MessageGTE          *string  `json:"messageGTE,omitempty"`
	MessageLT           *string  `json:"messageLT,omitempty"`
	MessageLTE          *string  `json:"messageLTE,omitempty"`
	MessageContains     *string  `json:"messageContains,omitempty"`
	MessageHasPrefix    *string  `json:"messageHasPrefix,omitempty"`
	MessageHasSuffix    *string  `json:"messageHasSuffix,omitempty"`
	MessageEqualFold    *string  `json:"messageEqualFold,omitempty"`
	MessageContainsFold *string  `json:"messageContainsFold,omitempty"`

	// "elapsed" field predicates.
	Elapsed      *float64  `json:"elapsed,omitempty"`
	ElapsedNEQ   *float64  `json:"elapsedNEQ,omitempty"`
	ElapsedIn    []float64 `json:"elapsedIn,omitempty"`
	ElapsedNotIn []float64 `json:"elapsedNotIn,omitempty"`
	ElapsedGT    *float64  `json:"elapsedGT,omitempty"`
	ElapsedGTE   *float64  `json:"elapsedGTE,omitempty"`
	ElapsedLT    *float64  `json:"elapsedLT,omitempty"`
	ElapsedLTE   *float64  `json:"elapsedLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "run" edge predicates.
	HasRun     *bool                `json:"hasRun,omitempty"`
	HasRunWith []*TestRunWhereInput `json:"hasRunWith,omitempty"`
}

// Filter applies the TestCaseWhereInput filter on the TestCaseQuery builder.
func (i *TestCaseWhereInput) Filter(q *TestCaseQuery) (*TestCaseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering testcases.
// An error is returned if the input is empty or invalid.
func (i *TestCaseWhereInput) P() (predicate.TestCase, error) {
	var predicates []predicate.TestCase
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, testcase.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TestCase, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, testcase.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TestCase, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, testcase.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, testcase.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, testcase.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, testcase.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, testcase.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, testcase.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, testcase.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, testcase.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, testcase.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, testcase.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, testcase.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, testcase.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, testcase.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, testcase.NameContainsFold(*i.NameContainsFold))
	}
	if i.Result != nil {
		predicates = append(predicates, testcase.ResultEQ(*i.Result))
	}
	if i.ResultNEQ != nil {
		predicates = append(predicates, testcase.ResultNEQ(*i.ResultNEQ))
	}
	if i.Message != nil {
		predicates = append(predicates, testcase.MessageEQ(*i.Message))
	}
	if i.MessageNEQ != nil {
		predicates = append(predicates, testcase.MessageNEQ(*i.MessageNEQ))
	}
	if len(i.MessageIn) > 0 {
		predicates = append(predicates, testcase.MessageIn(i.MessageIn...))
	}
	if len(i.MessageNotIn) > 0 {
		predicates = append(predicates, testcase.MessageNotIn(i.MessageNotIn...))
	}
	if i.MessageGT != nil {
		predicates = append(predicates, testcase.MessageGT(*i.MessageGT))
	}
	if i.MessageGTE != nil {
		predicates = append(predicates, testcase.MessageGTE(*i.MessageGTE))
	}
	if i.MessageLT != nil {
		predicates = append(predicates, testcase.MessageLT(*i.MessageLT))
	}
	if i.MessageLTE != nil {
		predicates = append(predicates, testcase.MessageLTE(*i.MessageLTE))
	}
	if i.MessageContains != nil {
		predicates = append(predicates, testcase.MessageContains(*i.MessageContains))
	}
	if i.MessageHasPrefix != nil {
		predicates = append(predicates, testcase.MessageHasPrefix(*i.MessageHasPrefix))
	}
	if i.MessageHasSuffix != nil {
		predicates = append(predicates, testcase.MessageHasSuffix(*i.MessageHasSuffix))
	}
	if i.MessageEqualFold != nil {
		predicates = append(predicates, testcase.MessageEqualFold(*i.MessageEqualFold))
	}
	if i.MessageContainsFold != nil {
		predicates = append(predicates, testcase.MessageContainsFold(*i.MessageContainsFold))
	}
	if i.Elapsed != nil {
		predicates = append(predicates, testcase.ElapsedEQ(*i.Elapsed))
	}
	if i.ElapsedNEQ != nil {
		predicates = append(predicates, testcase.ElapsedNEQ(*i.ElapsedNEQ))
	}
	if len(i.ElapsedIn) > 0 {
		predicates = append(predicates, testcase.ElapsedIn(i.ElapsedIn...))
	}
	if len(i.ElapsedNotIn) > 0 {
		predicates = append(predicates, testcase.ElapsedNotIn(i.ElapsedNotIn...))
	}
	if i.ElapsedGT != nil {
		predicates = append(predicates, testcase.ElapsedGT(*i.ElapsedGT))
	}
	if i.ElapsedGTE != nil {
		predicates = append(predicates, testcase.ElapsedGTE(*i.ElapsedGTE))
	}
	if i.ElapsedLT != nil {
		predicates = append(predicates, testcase.ElapsedLT(*i.ElapsedLT))
	}
	if i.ElapsedLTE != nil {
		predicates = append(predicates, testcase.ElapsedLTE(*i.ElapsedLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, testcase.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, testcase.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, testcase.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, testcase.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, testcase.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, testcase.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, testcase.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, testcase.IDLTE(*i.IDLTE))
	}

	if i.HasRun != nil {
		p := testcase.HasRun()
		if !*i.HasRun {
			p = testcase.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRunWith) > 0 {
		with := make([]predicate.TestRun, 0, len(i.HasRunWith))
		for _, w := range i.HasRunWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testcase.HasRunWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate TestCaseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return testcase.And(predicates...), nil
	}
}

// TestRunWhereInput represents a where input for filtering TestRun queries.
type TestRunWhereInput struct {
	Not *TestRunWhereInput   `json:"not,omitempty"`
	Or  []*TestRunWhereInput `json:"or,omitempty"`
	And []*TestRunWhereInput `json:"and,omitempty"`

	// "tool" field predicates.
	Tool             *string  `json:"tool,omitempty"`
	ToolNEQ          *string  `json:"toolNEQ,omitempty"`
	ToolIn           []string `json:"toolIn,omitempty"`
	ToolNotIn        []string `json:"toolNotIn,omitempty"`
	ToolGT           *string  `json:"toolGT,omitempty"`
	ToolGTE          *string  `json:"toolGTE,omitempty"`
	ToolLT           *string  `json:"toolLT,omitempty"`
	ToolLTE          *string  `json:"toolLTE,omitempty"`
	ToolContains     *string  `json:"toolContains,omitempty"`
	ToolHasPrefix    *string  `json:"toolHasPrefix,omitempty"`
	ToolHasSuffix    *string  `json:"toolHasSuffix,omitempty"`
	ToolEqualFold    *string  `json:"toolEqualFold,omitempty"`
	ToolContainsFold *string  `json:"toolContainsFold,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "entry" edge predicates.
	HasEntry     *bool                     `json:"hasEntry,omitempty"`
	HasEntryWith []*ReleaseEntryWhereInput `json:"hasEntryWith,omitempty"`

	// "tests" edge predicates.
	HasTests     *bool                 `json:"hasTests,omitempty"`
	HasTestsWith []*TestCaseWhereInput `json:"hasTestsWith,omitempty"`
}

// Filter applies the TestRunWhereInput filter on the TestRunQuery builder.
func (i *TestRunWhereInput) Filter(q *TestRunQuery) (*TestRunQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering testruns.
// An error is returned if the input is empty or invalid.
func (i *TestRunWhereInput) P() (predicate.TestRun, error) {
	var predicates []predicate.TestRun
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, testrun.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TestRun, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, testrun.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TestRun, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, testrun.And(and...))
	}
	if i.Tool != nil {
		predicates = append(predicates, testrun.ToolEQ(*i.Tool))
	}
	if i.ToolNEQ != nil {
		predicates = append(predicates, testrun.ToolNEQ(*i.ToolNEQ))
	}
	if len(i.ToolIn) > 0 {
		predicates = append(predicates, testrun.ToolIn(i.ToolIn...))
	}
	if len(i.ToolNotIn) > 0 {
		predicates = append(predicates, testrun.ToolNotIn(i.ToolNotIn...))
	}
	if i.ToolGT != nil {
		predicates = append(predicates, testrun.ToolGT(*i.ToolGT))
	}
	if i.ToolGTE != nil {
		predicates = append(predicates, testrun.ToolGTE(*i.ToolGTE))
	}
	if i.ToolLT != nil {
		predicates = append(predicates, testrun.ToolLT(*i.ToolLT))
	}
	if i.ToolLTE != nil {
		predicates = append(predicates, testrun.ToolLTE(*i.ToolLTE))
	}
	if i.ToolContains != nil {
		predicates = append(predicates, testrun.ToolContains(*i.ToolContains))
	}
	if i.ToolHasPrefix != nil {
		predicates = append(predicates, testrun.ToolHasPrefix(*i.ToolHasPrefix))
	}
	if i.ToolHasSuffix != nil {
		predicates = append(predicates, testrun.ToolHasSuffix(*i.ToolHasSuffix))
	}
	if i.ToolEqualFold != nil {
		predicates = append(predicates, testrun.ToolEqualFold(*i.ToolEqualFold))
	}
	if i.ToolContainsFold != nil {
		predicates = append(predicates, testrun.ToolContainsFold(*i.ToolContainsFold))
	}
	if i.Time != nil {
		predicates = append(predicates, testrun.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, testrun.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, testrun.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, testrun.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, testrun.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, testrun.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, testrun.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, testrun.TimeLTE(*i.TimeLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, testrun.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, testrun.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, testrun.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, testrun.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, testrun.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, testrun.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, testrun.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, testrun.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := testrun.HasRelease()
		if !*i.HasRelease {
			p = testrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testrun.HasReleaseWith(with...))
	}
	if i.HasEntry != nil {
		p := testrun.HasEntry()
		if !*i.HasEntry {
			p = testrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntryWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasEntryWith))
		for _, w := range i.HasEntryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testrun.HasEntryWith(with...))
	}
	if i.HasTests != nil {
		p := testrun.HasTests()
		if !*i.HasTests {
			p = testrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestsWith) > 0 {
		with := make([]predicate.TestCase, 0, len(i.HasTestsWith))
		for _, w := range i.HasTestsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testrun.HasTestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate TestRunWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return testrun.And(predicates...), nil
	}
}

// VulnerabilityWhereInput represents a where input for filtering Vulnerability queries.
type VulnerabilityWhereInput struct {
	Not *VulnerabilityWhereInput   `json:"not,omitempty"`
	Or  []*VulnerabilityWhereInput `json:"or,omitempty"`
	And []*VulnerabilityWhereInput `json:"and,omitempty"`

	// "vid" field predicates.
	Vid             *string  `json:"vid,omitempty"`
	VidNEQ          *string  `json:"vidNEQ,omitempty"`
	VidIn           []string `json:"vidIn,omitempty"`
	VidNotIn        []string `json:"vidNotIn,omitempty"`
	VidGT           *string  `json:"vidGT,omitempty"`
	VidGTE          *string  `json:"vidGTE,omitempty"`
	VidLT           *string  `json:"vidLT,omitempty"`
	VidLTE          *string  `json:"vidLTE,omitempty"`
	VidContains     *string  `json:"vidContains,omitempty"`
	VidHasPrefix    *string  `json:"vidHasPrefix,omitempty"`
	VidHasSuffix    *string  `json:"vidHasSuffix,omitempty"`
	VidEqualFold    *string  `json:"vidEqualFold,omitempty"`
	VidContainsFold *string  `json:"vidContainsFold,omitempty"`

	// "summary" field predicates.
	Summary             *string  `json:"summary,omitempty"`
	SummaryNEQ          *string  `json:"summaryNEQ,omitempty"`
	SummaryIn           []string `json:"summaryIn,omitempty"`
	SummaryNotIn        []string `json:"summaryNotIn,omitempty"`
	SummaryGT           *string  `json:"summaryGT,omitempty"`
	SummaryGTE          *string  `json:"summaryGTE,omitempty"`
	SummaryLT           *string  `json:"summaryLT,omitempty"`
	SummaryLTE          *string  `json:"summaryLTE,omitempty"`
	SummaryContains     *string  `json:"summaryContains,omitempty"`
	SummaryHasPrefix    *string  `json:"summaryHasPrefix,omitempty"`
	SummaryHasSuffix    *string  `json:"summaryHasSuffix,omitempty"`
	SummaryIsNil        bool     `json:"summaryIsNil,omitempty"`
	SummaryNotNil       bool     `json:"summaryNotNil,omitempty"`
	SummaryEqualFold    *string  `json:"summaryEqualFold,omitempty"`
	SummaryContainsFold *string  `json:"summaryContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "severity_score" field predicates.
	SeverityScore      *float64  `json:"severityScore,omitempty"`
	SeverityScoreNEQ   *float64  `json:"severityScoreNEQ,omitempty"`
	SeverityScoreIn    []float64 `json:"severityScoreIn,omitempty"`
	SeverityScoreNotIn []float64 `json:"severityScoreNotIn,omitempty"`
	SeverityScoreGT    *float64  `json:"severityScoreGT,omitempty"`
	SeverityScoreGTE   *float64  `json:"severityScoreGTE,omitempty"`
	SeverityScoreLT    *float64  `json:"severityScoreLT,omitempty"`
	SeverityScoreLTE   *float64  `json:"severityScoreLTE,omitempty"`

	// "severity" field predicates.
	Severity      *vulnerability.Severity  `json:"severity,omitempty"`
	SeverityNEQ   *vulnerability.Severity  `json:"severityNEQ,omitempty"`
	SeverityIn    []vulnerability.Severity `json:"severityIn,omitempty"`
	SeverityNotIn []vulnerability.Severity `json:"severityNotIn,omitempty"`

	// "published" field predicates.
	Published       *time.Time  `json:"published,omitempty"`
	PublishedNEQ    *time.Time  `json:"publishedNEQ,omitempty"`
	PublishedIn     []time.Time `json:"publishedIn,omitempty"`
	PublishedNotIn  []time.Time `json:"publishedNotIn,omitempty"`
	PublishedGT     *time.Time  `json:"publishedGT,omitempty"`
	PublishedGTE    *time.Time  `json:"publishedGTE,omitempty"`
	PublishedLT     *time.Time  `json:"publishedLT,omitempty"`
	PublishedLTE    *time.Time  `json:"publishedLTE,omitempty"`
	PublishedIsNil  bool        `json:"publishedIsNil,omitempty"`
	PublishedNotNil bool        `json:"publishedNotNil,omitempty"`

	// "modified" field predicates.
	Modified       *time.Time  `json:"modified,omitempty"`
	ModifiedNEQ    *time.Time  `json:"modifiedNEQ,omitempty"`
	ModifiedIn     []time.Time `json:"modifiedIn,omitempty"`
	ModifiedNotIn  []time.Time `json:"modifiedNotIn,omitempty"`
	ModifiedGT     *time.Time  `json:"modifiedGT,omitempty"`
	ModifiedGTE    *time.Time  `json:"modifiedGTE,omitempty"`
	ModifiedLT     *time.Time  `json:"modifiedLT,omitempty"`
	ModifiedLTE    *time.Time  `json:"modifiedLTE,omitempty"`
	ModifiedIsNil  bool        `json:"modifiedIsNil,omitempty"`
	ModifiedNotNil bool        `json:"modifiedNotNil,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                  `json:"hasComponents,omitempty"`
	HasComponentsWith []*ComponentWhereInput `json:"hasComponentsWith,omitempty"`

	// "reviews" edge predicates.
	HasReviews     *bool                            `json:"hasReviews,omitempty"`
	HasReviewsWith []*VulnerabilityReviewWhereInput `json:"hasReviewsWith,omitempty"`

	// "instances" edge predicates.
	HasInstances     *bool                             `json:"hasInstances,omitempty"`
	HasInstancesWith []*ReleaseVulnerabilityWhereInput `json:"hasInstancesWith,omitempty"`
}

// Filter applies the VulnerabilityWhereInput filter on the VulnerabilityQuery builder.
func (i *VulnerabilityWhereInput) Filter(q *VulnerabilityQuery) (*VulnerabilityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vulnerabilities.
// An error is returned if the input is empty or invalid.
func (i *VulnerabilityWhereInput) P() (predicate.Vulnerability, error) {
	var predicates []predicate.Vulnerability
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vulnerability.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Vulnerability, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vulnerability.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Vulnerability, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vulnerability.And(and...))
	}
	if i.Vid != nil {
		predicates = append(predicates, vulnerability.VidEQ(*i.Vid))
	}
	if i.VidNEQ != nil {
		predicates = append(predicates, vulnerability.VidNEQ(*i.VidNEQ))
	}
	if len(i.VidIn) > 0 {
		predicates = append(predicates, vulnerability.VidIn(i.VidIn...))
	}
	if len(i.VidNotIn) > 0 {
		predicates = append(predicates, vulnerability.VidNotIn(i.VidNotIn...))
	}
	if i.VidGT != nil {
		predicates = append(predicates, vulnerability.VidGT(*i.VidGT))
	}
	if i.VidGTE != nil {
		predicates = append(predicates, vulnerability.VidGTE(*i.VidGTE))
	}
	if i.VidLT != nil {
		predicates = append(predicates, vulnerability.VidLT(*i.VidLT))
	}
	if i.VidLTE != nil {
		predicates = append(predicates, vulnerability.VidLTE(*i.VidLTE))
	}
	if i.VidContains != nil {
		predicates = append(predicates, vulnerability.VidContains(*i.VidContains))
	}
	if i.VidHasPrefix != nil {
		predicates = append(predicates, vulnerability.VidHasPrefix(*i.VidHasPrefix))
	}
	if i.VidHasSuffix != nil {
		predicates = append(predicates, vulnerability.VidHasSuffix(*i.VidHasSuffix))
	}
	if i.VidEqualFold != nil {
		predicates = append(predicates, vulnerability.VidEqualFold(*i.VidEqualFold))
	}
	if i.VidContainsFold != nil {
		predicates = append(predicates, vulnerability.VidContainsFold(*i.VidContainsFold))
	}
	if i.Summary != nil {
		predicates = append(predicates, vulnerability.SummaryEQ(*i.Summary))
	}
	if i.SummaryNEQ != nil {
		predicates = append(predicates, vulnerability.SummaryNEQ(*i.SummaryNEQ))
	}
	if len(i.SummaryIn) > 0 {
		predicates = append(predicates, vulnerability.SummaryIn(i.SummaryIn...))
	}
	if len(i.SummaryNotIn) > 0 {
		predicates = append(predicates, vulnerability.SummaryNotIn(i.SummaryNotIn...))
	}
	if i.SummaryGT != nil {
		predicates = append(predicates, vulnerability.SummaryGT(*i.SummaryGT))
	}
	if i.SummaryGTE != nil {
		predicates = append(predicates, vulnerability.SummaryGTE(*i.SummaryGTE))
	}
	if i.SummaryLT != nil {
		predicates = append(predicates, vulnerability.SummaryLT(*i.SummaryLT))
	}
	if i.SummaryLTE != nil {
		predicates = append(predicates, vulnerability.SummaryLTE(*i.SummaryLTE))
	}
	if i.SummaryContains != nil {
		predicates = append(predicates, vulnerability.SummaryContains(*i.SummaryContains))
	}
	if i.SummaryHasPrefix != nil {
		predicates = append(predicates, vulnerability.SummaryHasPrefix(*i.SummaryHasPrefix))
	}
	if i.SummaryHasSuffix != nil {
		predicates = append(predicates, vulnerability.SummaryHasSuffix(*i.SummaryHasSuffix))
	}
	if i.SummaryIsNil {
		predicates = append(predicates, vulnerability.SummaryIsNil())
	}
	if i.SummaryNotNil {
		predicates = append(predicates, vulnerability.SummaryNotNil())
	}
	if i.SummaryEqualFold != nil {
		predicates = append(predicates, vulnerability.SummaryEqualFold(*i.SummaryEqualFold))
	}
	if i.SummaryContainsFold != nil {
		predicates = append(predicates, vulnerability.SummaryContainsFold(*i.SummaryContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, vulnerability.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, vulnerability.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, vulnerability.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, vulnerability.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, vulnerability.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, vulnerability.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, vulnerability.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, vulnerability.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, vulnerability.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, vulnerability.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, vulnerability.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, vulnerability.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, vulnerability.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, vulnerability.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, vulnerability.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.SeverityScore != nil {
		predicates = append(predicates, vulnerability.SeverityScoreEQ(*i.SeverityScore))
	}
	if i.SeverityScoreNEQ != nil {
		predicates = append(predicates, vulnerability.SeverityScoreNEQ(*i.SeverityScoreNEQ))
	}
	if len(i.SeverityScoreIn) > 0 {
		predicates = append(predicates, vulnerability.SeverityScoreIn(i.SeverityScoreIn...))
	}
	if len(i.SeverityScoreNotIn) > 0 {
		predicates = append(predicates, vulnerability.SeverityScoreNotIn(i.SeverityScoreNotIn...))
	}
	if i.SeverityScoreGT != nil {
		predicates = append(predicates, vulnerability.SeverityScoreGT(*i.SeverityScoreGT))
	}
	if i.SeverityScoreGTE != nil {
		predicates = append(predicates, vulnerability.SeverityScoreGTE(*i.SeverityScoreGTE))
	}
	if i.SeverityScoreLT != nil {
		predicates = append(predicates, vulnerability.SeverityScoreLT(*i.SeverityScoreLT))
	}
	if i.SeverityScoreLTE != nil {
		predicates = append(predicates, vulnerability.SeverityScoreLTE(*i.SeverityScoreLTE))
	}
	if i.Severity != nil {
		predicates = append(predicates, vulnerability.SeverityEQ(*i.Severity))
	}
	if i.SeverityNEQ != nil {
		predicates = append(predicates, vulnerability.SeverityNEQ(*i.SeverityNEQ))
	}
	if len(i.SeverityIn) > 0 {
		predicates = append(predicates, vulnerability.SeverityIn(i.SeverityIn...))
	}
	if len(i.SeverityNotIn) > 0 {
		predicates = append(predicates, vulnerability.SeverityNotIn(i.SeverityNotIn...))
	}
	if i.Published != nil {
		predicates = append(predicates, vulnerability.PublishedEQ(*i.Published))
	}
	if i.PublishedNEQ != nil {
		predicates = append(predicates, vulnerability.PublishedNEQ(*i.PublishedNEQ))
	}
	if len(i.PublishedIn) > 0 {
		predicates = append(predicates, vulnerability.PublishedIn(i.PublishedIn...))
	}
	if len(i.PublishedNotIn) > 0 {
		predicates = append(predicates, vulnerability.PublishedNotIn(i.PublishedNotIn...))
	}
	if i.PublishedGT != nil {
		predicates = append(predicates, vulnerability.PublishedGT(*i.PublishedGT))
	}
	if i.PublishedGTE != nil {
		predicates = append(predicates, vulnerability.PublishedGTE(*i.PublishedGTE))
	}
	if i.PublishedLT != nil {
		predicates = append(predicates, vulnerability.PublishedLT(*i.PublishedLT))
	}
	if i.PublishedLTE != nil {
		predicates = append(predicates, vulnerability.PublishedLTE(*i.PublishedLTE))
	}
	if i.PublishedIsNil {
		predicates = append(predicates, vulnerability.PublishedIsNil())
	}
	if i.PublishedNotNil {
		predicates = append(predicates, vulnerability.PublishedNotNil())
	}
	if i.Modified != nil {
		predicates = append(predicates, vulnerability.ModifiedEQ(*i.Modified))
	}
	if i.ModifiedNEQ != nil {
		predicates = append(predicates, vulnerability.ModifiedNEQ(*i.ModifiedNEQ))
	}
	if len(i.ModifiedIn) > 0 {
		predicates = append(predicates, vulnerability.ModifiedIn(i.ModifiedIn...))
	}
	if len(i.ModifiedNotIn) > 0 {
		predicates = append(predicates, vulnerability.ModifiedNotIn(i.ModifiedNotIn...))
	}
	if i.ModifiedGT != nil {
		predicates = append(predicates, vulnerability.ModifiedGT(*i.ModifiedGT))
	}
	if i.ModifiedGTE != nil {
		predicates = append(predicates, vulnerability.ModifiedGTE(*i.ModifiedGTE))
	}
	if i.ModifiedLT != nil {
		predicates = append(predicates, vulnerability.ModifiedLT(*i.ModifiedLT))
	}
	if i.ModifiedLTE != nil {
		predicates = append(predicates, vulnerability.ModifiedLTE(*i.ModifiedLTE))
	}
	if i.ModifiedIsNil {
		predicates = append(predicates, vulnerability.ModifiedIsNil())
	}
	if i.ModifiedNotNil {
		predicates = append(predicates, vulnerability.ModifiedNotNil())
	}
	if i.ID != nil {
		predicates = append(predicates, vulnerability.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vulnerability.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vulnerability.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vulnerability.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vulnerability.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vulnerability.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vulnerability.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vulnerability.IDLTE(*i.IDLTE))
	}

	if i.HasComponents != nil {
		p := vulnerability.HasComponents()
		if !*i.HasComponents {
			p = vulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.Component, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerability.HasComponentsWith(with...))
	}
	if i.HasReviews != nil {
		p := vulnerability.HasReviews()
		if !*i.HasReviews {
			p = vulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReviewsWith) > 0 {
		with := make([]predicate.VulnerabilityReview, 0, len(i.HasReviewsWith))
		for _, w := range i.HasReviewsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerability.HasReviewsWith(with...))
	}
	if i.HasInstances != nil {
		p := vulnerability.HasInstances()
		if !*i.HasInstances {
			p = vulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstancesWith) > 0 {
		with := make([]predicate.ReleaseVulnerability, 0, len(i.HasInstancesWith))
		for _, w := range i.HasInstancesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerability.HasInstancesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate VulnerabilityWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vulnerability.And(predicates...), nil
	}
}

// VulnerabilityReviewWhereInput represents a where input for filtering VulnerabilityReview queries.
type VulnerabilityReviewWhereInput struct {
	Not *VulnerabilityReviewWhereInput   `json:"not,omitempty"`
	Or  []*VulnerabilityReviewWhereInput `json:"or,omitempty"`
	And []*VulnerabilityReviewWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "decision" field predicates.
	Decision      *vulnerabilityreview.Decision  `json:"decision,omitempty"`
	DecisionNEQ   *vulnerabilityreview.Decision  `json:"decisionNEQ,omitempty"`
	DecisionIn    []vulnerabilityreview.Decision `json:"decisionIn,omitempty"`
	DecisionNotIn []vulnerabilityreview.Decision `json:"decisionNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "vulnerability" edge predicates.
	HasVulnerability     *bool                      `json:"hasVulnerability,omitempty"`
	HasVulnerabilityWith []*VulnerabilityWhereInput `json:"hasVulnerabilityWith,omitempty"`

	// "projects" edge predicates.
	HasProjects     *bool                `json:"hasProjects,omitempty"`
	HasProjectsWith []*ProjectWhereInput `json:"hasProjectsWith,omitempty"`

	// "repos" edge predicates.
	HasRepos     *bool             `json:"hasRepos,omitempty"`
	HasReposWith []*RepoWhereInput `json:"hasReposWith,omitempty"`

	// "releases" edge predicates.
	HasReleases     *bool                `json:"hasReleases,omitempty"`
	HasReleasesWith []*ReleaseWhereInput `json:"hasReleasesWith,omitempty"`

	// "instances" edge predicates.
	HasInstances     *bool                             `json:"hasInstances,omitempty"`
	HasInstancesWith []*ReleaseVulnerabilityWhereInput `json:"hasInstancesWith,omitempty"`
}

// Filter applies the VulnerabilityReviewWhereInput filter on the VulnerabilityReviewQuery builder.
func (i *VulnerabilityReviewWhereInput) Filter(q *VulnerabilityReviewQuery) (*VulnerabilityReviewQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vulnerabilityreviews.
// An error is returned if the input is empty or invalid.
func (i *VulnerabilityReviewWhereInput) P() (predicate.VulnerabilityReview, error) {
	var predicates []predicate.VulnerabilityReview
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vulnerabilityreview.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VulnerabilityReview, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vulnerabilityreview.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VulnerabilityReview, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vulnerabilityreview.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, vulnerabilityreview.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, vulnerabilityreview.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, vulnerabilityreview.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, vulnerabilityreview.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, vulnerabilityreview.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, vulnerabilityreview.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, vulnerabilityreview.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, vulnerabilityreview.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, vulnerabilityreview.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, vulnerabilityreview.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, vulnerabilityreview.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, vulnerabilityreview.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, vulnerabilityreview.NameContainsFold(*i.NameContainsFold))
	}
	if i.Decision != nil {
		predicates = append(predicates, vulnerabilityreview.DecisionEQ(*i.Decision))
	}
	if i.DecisionNEQ != nil {
		predicates = append(predicates, vulnerabilityreview.DecisionNEQ(*i.DecisionNEQ))
	}
	if len(i.DecisionIn) > 0 {
		predicates = append(predicates, vulnerabilityreview.DecisionIn(i.DecisionIn...))
	}
	if len(i.DecisionNotIn) > 0 {
		predicates = append(predicates, vulnerabilityreview.DecisionNotIn(i.DecisionNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, vulnerabilityreview.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vulnerabilityreview.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vulnerabilityreview.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vulnerabilityreview.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vulnerabilityreview.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vulnerabilityreview.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vulnerabilityreview.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vulnerabilityreview.IDLTE(*i.IDLTE))
	}

	if i.HasVulnerability != nil {
		p := vulnerabilityreview.HasVulnerability()
		if !*i.HasVulnerability {
			p = vulnerabilityreview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilityWith) > 0 {
		with := make([]predicate.Vulnerability, 0, len(i.HasVulnerabilityWith))
		for _, w := range i.HasVulnerabilityWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerabilityreview.HasVulnerabilityWith(with...))
	}
	if i.HasProjects != nil {
		p := vulnerabilityreview.HasProjects()
		if !*i.HasProjects {
			p = vulnerabilityreview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectsWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectsWith))
		for _, w := range i.HasProjectsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerabilityreview.HasProjectsWith(with...))
	}
	if i.HasRepos != nil {
		p := vulnerabilityreview.HasRepos()
		if !*i.HasRepos {
			p = vulnerabilityreview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReposWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasReposWith))
		for _, w := range i.HasReposWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerabilityreview.HasReposWith(with...))
	}
	if i.HasReleases != nil {
		p := vulnerabilityreview.HasReleases()
		if !*i.HasReleases {
			p = vulnerabilityreview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleasesWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleasesWith))
		for _, w := range i.HasReleasesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerabilityreview.HasReleasesWith(with...))
	}
	if i.HasInstances != nil {
		p := vulnerabilityreview.HasInstances()
		if !*i.HasInstances {
			p = vulnerabilityreview.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstancesWith) > 0 {
		with := make([]predicate.ReleaseVulnerability, 0, len(i.HasInstancesWith))
		for _, w := range i.HasInstancesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerabilityreview.HasInstancesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate VulnerabilityReviewWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vulnerabilityreview.And(predicates...), nil
	}
}
