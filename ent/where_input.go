// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/componentuse"
	"github.com/valocode/bubbly/ent/cve"
	"github.com/valocode/bubbly/ent/cverule"
	"github.com/valocode/bubbly/ent/cwe"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licenseuse"
	"github.com/valocode/bubbly/ent/predicate"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
)

// ArtifactWhereInput represents a where input for filtering Artifact queries.
type ArtifactWhereInput struct {
	Not *ArtifactWhereInput   `json:"not,omitempty"`
	Or  []*ArtifactWhereInput `json:"or,omitempty"`
	And []*ArtifactWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "sha256" field predicates.
	Sha256             *string  `json:"sha256,omitempty"`
	Sha256NEQ          *string  `json:"sha256NEQ,omitempty"`
	Sha256In           []string `json:"sha256In,omitempty"`
	Sha256NotIn        []string `json:"sha256NotIn,omitempty"`
	Sha256GT           *string  `json:"sha256GT,omitempty"`
	Sha256GTE          *string  `json:"sha256GTE,omitempty"`
	Sha256LT           *string  `json:"sha256LT,omitempty"`
	Sha256LTE          *string  `json:"sha256LTE,omitempty"`
	Sha256Contains     *string  `json:"sha256Contains,omitempty"`
	Sha256HasPrefix    *string  `json:"sha256HasPrefix,omitempty"`
	Sha256HasSuffix    *string  `json:"sha256HasSuffix,omitempty"`
	Sha256EqualFold    *string  `json:"sha256EqualFold,omitempty"`
	Sha256ContainsFold *string  `json:"sha256ContainsFold,omitempty"`

	// "type" field predicates.
	Type      *artifact.Type  `json:"type,omitempty"`
	TypeNEQ   *artifact.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []artifact.Type `json:"typeIn,omitempty"`
	TypeNotIn []artifact.Type `json:"typeNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "entry" edge predicates.
	HasEntry     *bool                     `json:"hasEntry,omitempty"`
	HasEntryWith []*ReleaseEntryWhereInput `json:"hasEntryWith,omitempty"`
}

// Filter applies the ArtifactWhereInput filter on the ArtifactQuery builder.
func (i *ArtifactWhereInput) Filter(q *ArtifactQuery) (*ArtifactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering artifacts.
// An error is returned if the input is empty or invalid.
func (i *ArtifactWhereInput) P() (predicate.Artifact, error) {
	var predicates []predicate.Artifact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, artifact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Artifact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, artifact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Artifact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, artifact.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, artifact.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, artifact.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, artifact.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, artifact.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, artifact.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, artifact.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, artifact.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, artifact.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, artifact.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, artifact.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, artifact.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, artifact.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, artifact.NameContainsFold(*i.NameContainsFold))
	}
	if i.Sha256 != nil {
		predicates = append(predicates, artifact.Sha256EQ(*i.Sha256))
	}
	if i.Sha256NEQ != nil {
		predicates = append(predicates, artifact.Sha256NEQ(*i.Sha256NEQ))
	}
	if len(i.Sha256In) > 0 {
		predicates = append(predicates, artifact.Sha256In(i.Sha256In...))
	}
	if len(i.Sha256NotIn) > 0 {
		predicates = append(predicates, artifact.Sha256NotIn(i.Sha256NotIn...))
	}
	if i.Sha256GT != nil {
		predicates = append(predicates, artifact.Sha256GT(*i.Sha256GT))
	}
	if i.Sha256GTE != nil {
		predicates = append(predicates, artifact.Sha256GTE(*i.Sha256GTE))
	}
	if i.Sha256LT != nil {
		predicates = append(predicates, artifact.Sha256LT(*i.Sha256LT))
	}
	if i.Sha256LTE != nil {
		predicates = append(predicates, artifact.Sha256LTE(*i.Sha256LTE))
	}
	if i.Sha256Contains != nil {
		predicates = append(predicates, artifact.Sha256Contains(*i.Sha256Contains))
	}
	if i.Sha256HasPrefix != nil {
		predicates = append(predicates, artifact.Sha256HasPrefix(*i.Sha256HasPrefix))
	}
	if i.Sha256HasSuffix != nil {
		predicates = append(predicates, artifact.Sha256HasSuffix(*i.Sha256HasSuffix))
	}
	if i.Sha256EqualFold != nil {
		predicates = append(predicates, artifact.Sha256EqualFold(*i.Sha256EqualFold))
	}
	if i.Sha256ContainsFold != nil {
		predicates = append(predicates, artifact.Sha256ContainsFold(*i.Sha256ContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, artifact.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, artifact.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, artifact.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, artifact.TypeNotIn(i.TypeNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, artifact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, artifact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, artifact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, artifact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, artifact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, artifact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, artifact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, artifact.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := artifact.HasRelease()
		if !*i.HasRelease {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasReleaseWith(with...))
	}
	if i.HasEntry != nil {
		p := artifact.HasEntry()
		if !*i.HasEntry {
			p = artifact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntryWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasEntryWith))
		for _, w := range i.HasEntryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, artifact.HasEntryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ArtifactWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return artifact.And(predicates...), nil
	}
}

// CVEWhereInput represents a where input for filtering CVE queries.
type CVEWhereInput struct {
	Not *CVEWhereInput   `json:"not,omitempty"`
	Or  []*CVEWhereInput `json:"or,omitempty"`
	And []*CVEWhereInput `json:"and,omitempty"`

	// "cve_id" field predicates.
	CveID             *string  `json:"cveID,omitempty"`
	CveIDNEQ          *string  `json:"cveIDNEQ,omitempty"`
	CveIDIn           []string `json:"cveIDIn,omitempty"`
	CveIDNotIn        []string `json:"cveIDNotIn,omitempty"`
	CveIDGT           *string  `json:"cveIDGT,omitempty"`
	CveIDGTE          *string  `json:"cveIDGTE,omitempty"`
	CveIDLT           *string  `json:"cveIDLT,omitempty"`
	CveIDLTE          *string  `json:"cveIDLTE,omitempty"`
	CveIDContains     *string  `json:"cveIDContains,omitempty"`
	CveIDHasPrefix    *string  `json:"cveIDHasPrefix,omitempty"`
	CveIDHasSuffix    *string  `json:"cveIDHasSuffix,omitempty"`
	CveIDEqualFold    *string  `json:"cveIDEqualFold,omitempty"`
	CveIDContainsFold *string  `json:"cveIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "severity_score" field predicates.
	SeverityScore      *float64  `json:"severityScore,omitempty"`
	SeverityScoreNEQ   *float64  `json:"severityScoreNEQ,omitempty"`
	SeverityScoreIn    []float64 `json:"severityScoreIn,omitempty"`
	SeverityScoreNotIn []float64 `json:"severityScoreNotIn,omitempty"`
	SeverityScoreGT    *float64  `json:"severityScoreGT,omitempty"`
	SeverityScoreGTE   *float64  `json:"severityScoreGTE,omitempty"`
	SeverityScoreLT    *float64  `json:"severityScoreLT,omitempty"`
	SeverityScoreLTE   *float64  `json:"severityScoreLTE,omitempty"`

	// "severity" field predicates.
	Severity      *cve.Severity  `json:"severity,omitempty"`
	SeverityNEQ   *cve.Severity  `json:"severityNEQ,omitempty"`
	SeverityIn    []cve.Severity `json:"severityIn,omitempty"`
	SeverityNotIn []cve.Severity `json:"severityNotIn,omitempty"`

	// "published_data" field predicates.
	PublishedData       *time.Time  `json:"publishedData,omitempty"`
	PublishedDataNEQ    *time.Time  `json:"publishedDataNEQ,omitempty"`
	PublishedDataIn     []time.Time `json:"publishedDataIn,omitempty"`
	PublishedDataNotIn  []time.Time `json:"publishedDataNotIn,omitempty"`
	PublishedDataGT     *time.Time  `json:"publishedDataGT,omitempty"`
	PublishedDataGTE    *time.Time  `json:"publishedDataGTE,omitempty"`
	PublishedDataLT     *time.Time  `json:"publishedDataLT,omitempty"`
	PublishedDataLTE    *time.Time  `json:"publishedDataLTE,omitempty"`
	PublishedDataIsNil  bool        `json:"publishedDataIsNil,omitempty"`
	PublishedDataNotNil bool        `json:"publishedDataNotNil,omitempty"`

	// "modified_data" field predicates.
	ModifiedData       *time.Time  `json:"modifiedData,omitempty"`
	ModifiedDataNEQ    *time.Time  `json:"modifiedDataNEQ,omitempty"`
	ModifiedDataIn     []time.Time `json:"modifiedDataIn,omitempty"`
	ModifiedDataNotIn  []time.Time `json:"modifiedDataNotIn,omitempty"`
	ModifiedDataGT     *time.Time  `json:"modifiedDataGT,omitempty"`
	ModifiedDataGTE    *time.Time  `json:"modifiedDataGTE,omitempty"`
	ModifiedDataLT     *time.Time  `json:"modifiedDataLT,omitempty"`
	ModifiedDataLTE    *time.Time  `json:"modifiedDataLTE,omitempty"`
	ModifiedDataIsNil  bool        `json:"modifiedDataIsNil,omitempty"`
	ModifiedDataNotNil bool        `json:"modifiedDataNotNil,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                  `json:"hasComponents,omitempty"`
	HasComponentsWith []*ComponentWhereInput `json:"hasComponentsWith,omitempty"`

	// "vulnerabilities" edge predicates.
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`

	// "rules" edge predicates.
	HasRules     *bool                `json:"hasRules,omitempty"`
	HasRulesWith []*CVERuleWhereInput `json:"hasRulesWith,omitempty"`
}

// Filter applies the CVEWhereInput filter on the CVEQuery builder.
func (i *CVEWhereInput) Filter(q *CVEQuery) (*CVEQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering cves.
// An error is returned if the input is empty or invalid.
func (i *CVEWhereInput) P() (predicate.CVE, error) {
	var predicates []predicate.CVE
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, cve.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CVE, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, cve.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CVE, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, cve.And(and...))
	}
	if i.CveID != nil {
		predicates = append(predicates, cve.CveIDEQ(*i.CveID))
	}
	if i.CveIDNEQ != nil {
		predicates = append(predicates, cve.CveIDNEQ(*i.CveIDNEQ))
	}
	if len(i.CveIDIn) > 0 {
		predicates = append(predicates, cve.CveIDIn(i.CveIDIn...))
	}
	if len(i.CveIDNotIn) > 0 {
		predicates = append(predicates, cve.CveIDNotIn(i.CveIDNotIn...))
	}
	if i.CveIDGT != nil {
		predicates = append(predicates, cve.CveIDGT(*i.CveIDGT))
	}
	if i.CveIDGTE != nil {
		predicates = append(predicates, cve.CveIDGTE(*i.CveIDGTE))
	}
	if i.CveIDLT != nil {
		predicates = append(predicates, cve.CveIDLT(*i.CveIDLT))
	}
	if i.CveIDLTE != nil {
		predicates = append(predicates, cve.CveIDLTE(*i.CveIDLTE))
	}
	if i.CveIDContains != nil {
		predicates = append(predicates, cve.CveIDContains(*i.CveIDContains))
	}
	if i.CveIDHasPrefix != nil {
		predicates = append(predicates, cve.CveIDHasPrefix(*i.CveIDHasPrefix))
	}
	if i.CveIDHasSuffix != nil {
		predicates = append(predicates, cve.CveIDHasSuffix(*i.CveIDHasSuffix))
	}
	if i.CveIDEqualFold != nil {
		predicates = append(predicates, cve.CveIDEqualFold(*i.CveIDEqualFold))
	}
	if i.CveIDContainsFold != nil {
		predicates = append(predicates, cve.CveIDContainsFold(*i.CveIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, cve.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, cve.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, cve.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, cve.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, cve.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, cve.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, cve.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, cve.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, cve.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, cve.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, cve.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, cve.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, cve.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, cve.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, cve.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.SeverityScore != nil {
		predicates = append(predicates, cve.SeverityScoreEQ(*i.SeverityScore))
	}
	if i.SeverityScoreNEQ != nil {
		predicates = append(predicates, cve.SeverityScoreNEQ(*i.SeverityScoreNEQ))
	}
	if len(i.SeverityScoreIn) > 0 {
		predicates = append(predicates, cve.SeverityScoreIn(i.SeverityScoreIn...))
	}
	if len(i.SeverityScoreNotIn) > 0 {
		predicates = append(predicates, cve.SeverityScoreNotIn(i.SeverityScoreNotIn...))
	}
	if i.SeverityScoreGT != nil {
		predicates = append(predicates, cve.SeverityScoreGT(*i.SeverityScoreGT))
	}
	if i.SeverityScoreGTE != nil {
		predicates = append(predicates, cve.SeverityScoreGTE(*i.SeverityScoreGTE))
	}
	if i.SeverityScoreLT != nil {
		predicates = append(predicates, cve.SeverityScoreLT(*i.SeverityScoreLT))
	}
	if i.SeverityScoreLTE != nil {
		predicates = append(predicates, cve.SeverityScoreLTE(*i.SeverityScoreLTE))
	}
	if i.Severity != nil {
		predicates = append(predicates, cve.SeverityEQ(*i.Severity))
	}
	if i.SeverityNEQ != nil {
		predicates = append(predicates, cve.SeverityNEQ(*i.SeverityNEQ))
	}
	if len(i.SeverityIn) > 0 {
		predicates = append(predicates, cve.SeverityIn(i.SeverityIn...))
	}
	if len(i.SeverityNotIn) > 0 {
		predicates = append(predicates, cve.SeverityNotIn(i.SeverityNotIn...))
	}
	if i.PublishedData != nil {
		predicates = append(predicates, cve.PublishedDataEQ(*i.PublishedData))
	}
	if i.PublishedDataNEQ != nil {
		predicates = append(predicates, cve.PublishedDataNEQ(*i.PublishedDataNEQ))
	}
	if len(i.PublishedDataIn) > 0 {
		predicates = append(predicates, cve.PublishedDataIn(i.PublishedDataIn...))
	}
	if len(i.PublishedDataNotIn) > 0 {
		predicates = append(predicates, cve.PublishedDataNotIn(i.PublishedDataNotIn...))
	}
	if i.PublishedDataGT != nil {
		predicates = append(predicates, cve.PublishedDataGT(*i.PublishedDataGT))
	}
	if i.PublishedDataGTE != nil {
		predicates = append(predicates, cve.PublishedDataGTE(*i.PublishedDataGTE))
	}
	if i.PublishedDataLT != nil {
		predicates = append(predicates, cve.PublishedDataLT(*i.PublishedDataLT))
	}
	if i.PublishedDataLTE != nil {
		predicates = append(predicates, cve.PublishedDataLTE(*i.PublishedDataLTE))
	}
	if i.PublishedDataIsNil {
		predicates = append(predicates, cve.PublishedDataIsNil())
	}
	if i.PublishedDataNotNil {
		predicates = append(predicates, cve.PublishedDataNotNil())
	}
	if i.ModifiedData != nil {
		predicates = append(predicates, cve.ModifiedDataEQ(*i.ModifiedData))
	}
	if i.ModifiedDataNEQ != nil {
		predicates = append(predicates, cve.ModifiedDataNEQ(*i.ModifiedDataNEQ))
	}
	if len(i.ModifiedDataIn) > 0 {
		predicates = append(predicates, cve.ModifiedDataIn(i.ModifiedDataIn...))
	}
	if len(i.ModifiedDataNotIn) > 0 {
		predicates = append(predicates, cve.ModifiedDataNotIn(i.ModifiedDataNotIn...))
	}
	if i.ModifiedDataGT != nil {
		predicates = append(predicates, cve.ModifiedDataGT(*i.ModifiedDataGT))
	}
	if i.ModifiedDataGTE != nil {
		predicates = append(predicates, cve.ModifiedDataGTE(*i.ModifiedDataGTE))
	}
	if i.ModifiedDataLT != nil {
		predicates = append(predicates, cve.ModifiedDataLT(*i.ModifiedDataLT))
	}
	if i.ModifiedDataLTE != nil {
		predicates = append(predicates, cve.ModifiedDataLTE(*i.ModifiedDataLTE))
	}
	if i.ModifiedDataIsNil {
		predicates = append(predicates, cve.ModifiedDataIsNil())
	}
	if i.ModifiedDataNotNil {
		predicates = append(predicates, cve.ModifiedDataNotNil())
	}
	if i.ID != nil {
		predicates = append(predicates, cve.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cve.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cve.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cve.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cve.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cve.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cve.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cve.IDLTE(*i.IDLTE))
	}

	if i.HasComponents != nil {
		p := cve.HasComponents()
		if !*i.HasComponents {
			p = cve.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.Component, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, cve.HasComponentsWith(with...))
	}
	if i.HasVulnerabilities != nil {
		p := cve.HasVulnerabilities()
		if !*i.HasVulnerabilities {
			p = cve.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVulnerabilitiesWith) > 0 {
		with := make([]predicate.Vulnerability, 0, len(i.HasVulnerabilitiesWith))
		for _, w := range i.HasVulnerabilitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, cve.HasVulnerabilitiesWith(with...))
	}
	if i.HasRules != nil {
		p := cve.HasRules()
		if !*i.HasRules {
			p = cve.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRulesWith) > 0 {
		with := make([]predicate.CVERule, 0, len(i.HasRulesWith))
		for _, w := range i.HasRulesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, cve.HasRulesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate CVEWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return cve.And(predicates...), nil
	}
}

// CVERuleWhereInput represents a where input for filtering CVERule queries.
type CVERuleWhereInput struct {
	Not *CVERuleWhereInput   `json:"not,omitempty"`
	Or  []*CVERuleWhereInput `json:"or,omitempty"`
	And []*CVERuleWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "cve" edge predicates.
	HasCve     *bool            `json:"hasCve,omitempty"`
	HasCveWith []*CVEWhereInput `json:"hasCveWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "repo" edge predicates.
	HasRepo     *bool             `json:"hasRepo,omitempty"`
	HasRepoWith []*RepoWhereInput `json:"hasRepoWith,omitempty"`
}

// Filter applies the CVERuleWhereInput filter on the CVERuleQuery builder.
func (i *CVERuleWhereInput) Filter(q *CVERuleQuery) (*CVERuleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering cverules.
// An error is returned if the input is empty or invalid.
func (i *CVERuleWhereInput) P() (predicate.CVERule, error) {
	var predicates []predicate.CVERule
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, cverule.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CVERule, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, cverule.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CVERule, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, cverule.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, cverule.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, cverule.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, cverule.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, cverule.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, cverule.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, cverule.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, cverule.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, cverule.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, cverule.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, cverule.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, cverule.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, cverule.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, cverule.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, cverule.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, cverule.NameContainsFold(*i.NameContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, cverule.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cverule.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cverule.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cverule.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cverule.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cverule.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cverule.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cverule.IDLTE(*i.IDLTE))
	}

	if i.HasCve != nil {
		p := cverule.HasCve()
		if !*i.HasCve {
			p = cverule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCveWith) > 0 {
		with := make([]predicate.CVE, 0, len(i.HasCveWith))
		for _, w := range i.HasCveWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, cverule.HasCveWith(with...))
	}
	if i.HasProject != nil {
		p := cverule.HasProject()
		if !*i.HasProject {
			p = cverule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, cverule.HasProjectWith(with...))
	}
	if i.HasRepo != nil {
		p := cverule.HasRepo()
		if !*i.HasRepo {
			p = cverule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRepoWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasRepoWith))
		for _, w := range i.HasRepoWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, cverule.HasRepoWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate CVERuleWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return cverule.And(predicates...), nil
	}
}

// CWEWhereInput represents a where input for filtering CWE queries.
type CWEWhereInput struct {
	Not *CWEWhereInput   `json:"not,omitempty"`
	Or  []*CWEWhereInput `json:"or,omitempty"`
	And []*CWEWhereInput `json:"and,omitempty"`

	// "cwe_id" field predicates.
	CweID             *string  `json:"cweID,omitempty"`
	CweIDNEQ          *string  `json:"cweIDNEQ,omitempty"`
	CweIDIn           []string `json:"cweIDIn,omitempty"`
	CweIDNotIn        []string `json:"cweIDNotIn,omitempty"`
	CweIDGT           *string  `json:"cweIDGT,omitempty"`
	CweIDGTE          *string  `json:"cweIDGTE,omitempty"`
	CweIDLT           *string  `json:"cweIDLT,omitempty"`
	CweIDLTE          *string  `json:"cweIDLTE,omitempty"`
	CweIDContains     *string  `json:"cweIDContains,omitempty"`
	CweIDHasPrefix    *string  `json:"cweIDHasPrefix,omitempty"`
	CweIDHasSuffix    *string  `json:"cweIDHasSuffix,omitempty"`
	CweIDEqualFold    *string  `json:"cweIDEqualFold,omitempty"`
	CweIDContainsFold *string  `json:"cweIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "url" field predicates.
	URL       *float64  `json:"url,omitempty"`
	URLNEQ    *float64  `json:"urlNEQ,omitempty"`
	URLIn     []float64 `json:"urlIn,omitempty"`
	URLNotIn  []float64 `json:"urlNotIn,omitempty"`
	URLGT     *float64  `json:"urlGT,omitempty"`
	URLGTE    *float64  `json:"urlGTE,omitempty"`
	URLLT     *float64  `json:"urlLT,omitempty"`
	URLLTE    *float64  `json:"urlLTE,omitempty"`
	URLIsNil  bool      `json:"urlIsNil,omitempty"`
	URLNotNil bool      `json:"urlNotNil,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "issues" edge predicates.
	HasIssues     *bool                  `json:"hasIssues,omitempty"`
	HasIssuesWith []*CodeIssueWhereInput `json:"hasIssuesWith,omitempty"`
}

// Filter applies the CWEWhereInput filter on the CWEQuery builder.
func (i *CWEWhereInput) Filter(q *CWEQuery) (*CWEQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering cwes.
// An error is returned if the input is empty or invalid.
func (i *CWEWhereInput) P() (predicate.CWE, error) {
	var predicates []predicate.CWE
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, cwe.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CWE, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, cwe.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CWE, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, cwe.And(and...))
	}
	if i.CweID != nil {
		predicates = append(predicates, cwe.CweIDEQ(*i.CweID))
	}
	if i.CweIDNEQ != nil {
		predicates = append(predicates, cwe.CweIDNEQ(*i.CweIDNEQ))
	}
	if len(i.CweIDIn) > 0 {
		predicates = append(predicates, cwe.CweIDIn(i.CweIDIn...))
	}
	if len(i.CweIDNotIn) > 0 {
		predicates = append(predicates, cwe.CweIDNotIn(i.CweIDNotIn...))
	}
	if i.CweIDGT != nil {
		predicates = append(predicates, cwe.CweIDGT(*i.CweIDGT))
	}
	if i.CweIDGTE != nil {
		predicates = append(predicates, cwe.CweIDGTE(*i.CweIDGTE))
	}
	if i.CweIDLT != nil {
		predicates = append(predicates, cwe.CweIDLT(*i.CweIDLT))
	}
	if i.CweIDLTE != nil {
		predicates = append(predicates, cwe.CweIDLTE(*i.CweIDLTE))
	}
	if i.CweIDContains != nil {
		predicates = append(predicates, cwe.CweIDContains(*i.CweIDContains))
	}
	if i.CweIDHasPrefix != nil {
		predicates = append(predicates, cwe.CweIDHasPrefix(*i.CweIDHasPrefix))
	}
	if i.CweIDHasSuffix != nil {
		predicates = append(predicates, cwe.CweIDHasSuffix(*i.CweIDHasSuffix))
	}
	if i.CweIDEqualFold != nil {
		predicates = append(predicates, cwe.CweIDEqualFold(*i.CweIDEqualFold))
	}
	if i.CweIDContainsFold != nil {
		predicates = append(predicates, cwe.CweIDContainsFold(*i.CweIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, cwe.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, cwe.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, cwe.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, cwe.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, cwe.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, cwe.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, cwe.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, cwe.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, cwe.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, cwe.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, cwe.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, cwe.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, cwe.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, cwe.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, cwe.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, cwe.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, cwe.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, cwe.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, cwe.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, cwe.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, cwe.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, cwe.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, cwe.URLLTE(*i.URLLTE))
	}
	if i.URLIsNil {
		predicates = append(predicates, cwe.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, cwe.URLNotNil())
	}
	if i.ID != nil {
		predicates = append(predicates, cwe.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cwe.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cwe.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cwe.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cwe.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cwe.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cwe.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cwe.IDLTE(*i.IDLTE))
	}

	if i.HasIssues != nil {
		p := cwe.HasIssues()
		if !*i.HasIssues {
			p = cwe.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIssuesWith) > 0 {
		with := make([]predicate.CodeIssue, 0, len(i.HasIssuesWith))
		for _, w := range i.HasIssuesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, cwe.HasIssuesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate CWEWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return cwe.And(predicates...), nil
	}
}

// CodeIssueWhereInput represents a where input for filtering CodeIssue queries.
type CodeIssueWhereInput struct {
	Not *CodeIssueWhereInput   `json:"not,omitempty"`
	Or  []*CodeIssueWhereInput `json:"or,omitempty"`
	And []*CodeIssueWhereInput `json:"and,omitempty"`

	// "rule_id" field predicates.
	RuleID             *string  `json:"ruleID,omitempty"`
	RuleIDNEQ          *string  `json:"ruleIDNEQ,omitempty"`
	RuleIDIn           []string `json:"ruleIDIn,omitempty"`
	RuleIDNotIn        []string `json:"ruleIDNotIn,omitempty"`
	RuleIDGT           *string  `json:"ruleIDGT,omitempty"`
	RuleIDGTE          *string  `json:"ruleIDGTE,omitempty"`
	RuleIDLT           *string  `json:"ruleIDLT,omitempty"`
	RuleIDLTE          *string  `json:"ruleIDLTE,omitempty"`
	RuleIDContains     *string  `json:"ruleIDContains,omitempty"`
	RuleIDHasPrefix    *string  `json:"ruleIDHasPrefix,omitempty"`
	RuleIDHasSuffix    *string  `json:"ruleIDHasSuffix,omitempty"`
	RuleIDEqualFold    *string  `json:"ruleIDEqualFold,omitempty"`
	RuleIDContainsFold *string  `json:"ruleIDContainsFold,omitempty"`

	// "message" field predicates.
	Message             *string  `json:"message,omitempty"`
	MessageNEQ          *string  `json:"messageNEQ,omitempty"`
	MessageIn           []string `json:"messageIn,omitempty"`
	MessageNotIn        []string `json:"messageNotIn,omitempty"`
	MessageGT           *string  `json:"messageGT,omitempty"`
	MessageGTE          *string  `json:"messageGTE,omitempty"`
	MessageLT           *string  `json:"messageLT,omitempty"`
	MessageLTE          *string  `json:"messageLTE,omitempty"`
	MessageContains     *string  `json:"messageContains,omitempty"`
	MessageHasPrefix    *string  `json:"messageHasPrefix,omitempty"`
	MessageHasSuffix    *string  `json:"messageHasSuffix,omitempty"`
	MessageEqualFold    *string  `json:"messageEqualFold,omitempty"`
	MessageContainsFold *string  `json:"messageContainsFold,omitempty"`

	// "severity" field predicates.
	Severity      *codeissue.Severity  `json:"severity,omitempty"`
	SeverityNEQ   *codeissue.Severity  `json:"severityNEQ,omitempty"`
	SeverityIn    []codeissue.Severity `json:"severityIn,omitempty"`
	SeverityNotIn []codeissue.Severity `json:"severityNotIn,omitempty"`

	// "type" field predicates.
	Type      *codeissue.Type  `json:"type,omitempty"`
	TypeNEQ   *codeissue.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []codeissue.Type `json:"typeIn,omitempty"`
	TypeNotIn []codeissue.Type `json:"typeNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "cwe" edge predicates.
	HasCwe     *bool            `json:"hasCwe,omitempty"`
	HasCweWith []*CWEWhereInput `json:"hasCweWith,omitempty"`

	// "scan" edge predicates.
	HasScan     *bool                 `json:"hasScan,omitempty"`
	HasScanWith []*CodeScanWhereInput `json:"hasScanWith,omitempty"`
}

// Filter applies the CodeIssueWhereInput filter on the CodeIssueQuery builder.
func (i *CodeIssueWhereInput) Filter(q *CodeIssueQuery) (*CodeIssueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering codeissues.
// An error is returned if the input is empty or invalid.
func (i *CodeIssueWhereInput) P() (predicate.CodeIssue, error) {
	var predicates []predicate.CodeIssue
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, codeissue.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CodeIssue, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, codeissue.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CodeIssue, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, codeissue.And(and...))
	}
	if i.RuleID != nil {
		predicates = append(predicates, codeissue.RuleIDEQ(*i.RuleID))
	}
	if i.RuleIDNEQ != nil {
		predicates = append(predicates, codeissue.RuleIDNEQ(*i.RuleIDNEQ))
	}
	if len(i.RuleIDIn) > 0 {
		predicates = append(predicates, codeissue.RuleIDIn(i.RuleIDIn...))
	}
	if len(i.RuleIDNotIn) > 0 {
		predicates = append(predicates, codeissue.RuleIDNotIn(i.RuleIDNotIn...))
	}
	if i.RuleIDGT != nil {
		predicates = append(predicates, codeissue.RuleIDGT(*i.RuleIDGT))
	}
	if i.RuleIDGTE != nil {
		predicates = append(predicates, codeissue.RuleIDGTE(*i.RuleIDGTE))
	}
	if i.RuleIDLT != nil {
		predicates = append(predicates, codeissue.RuleIDLT(*i.RuleIDLT))
	}
	if i.RuleIDLTE != nil {
		predicates = append(predicates, codeissue.RuleIDLTE(*i.RuleIDLTE))
	}
	if i.RuleIDContains != nil {
		predicates = append(predicates, codeissue.RuleIDContains(*i.RuleIDContains))
	}
	if i.RuleIDHasPrefix != nil {
		predicates = append(predicates, codeissue.RuleIDHasPrefix(*i.RuleIDHasPrefix))
	}
	if i.RuleIDHasSuffix != nil {
		predicates = append(predicates, codeissue.RuleIDHasSuffix(*i.RuleIDHasSuffix))
	}
	if i.RuleIDEqualFold != nil {
		predicates = append(predicates, codeissue.RuleIDEqualFold(*i.RuleIDEqualFold))
	}
	if i.RuleIDContainsFold != nil {
		predicates = append(predicates, codeissue.RuleIDContainsFold(*i.RuleIDContainsFold))
	}
	if i.Message != nil {
		predicates = append(predicates, codeissue.MessageEQ(*i.Message))
	}
	if i.MessageNEQ != nil {
		predicates = append(predicates, codeissue.MessageNEQ(*i.MessageNEQ))
	}
	if len(i.MessageIn) > 0 {
		predicates = append(predicates, codeissue.MessageIn(i.MessageIn...))
	}
	if len(i.MessageNotIn) > 0 {
		predicates = append(predicates, codeissue.MessageNotIn(i.MessageNotIn...))
	}
	if i.MessageGT != nil {
		predicates = append(predicates, codeissue.MessageGT(*i.MessageGT))
	}
	if i.MessageGTE != nil {
		predicates = append(predicates, codeissue.MessageGTE(*i.MessageGTE))
	}
	if i.MessageLT != nil {
		predicates = append(predicates, codeissue.MessageLT(*i.MessageLT))
	}
	if i.MessageLTE != nil {
		predicates = append(predicates, codeissue.MessageLTE(*i.MessageLTE))
	}
	if i.MessageContains != nil {
		predicates = append(predicates, codeissue.MessageContains(*i.MessageContains))
	}
	if i.MessageHasPrefix != nil {
		predicates = append(predicates, codeissue.MessageHasPrefix(*i.MessageHasPrefix))
	}
	if i.MessageHasSuffix != nil {
		predicates = append(predicates, codeissue.MessageHasSuffix(*i.MessageHasSuffix))
	}
	if i.MessageEqualFold != nil {
		predicates = append(predicates, codeissue.MessageEqualFold(*i.MessageEqualFold))
	}
	if i.MessageContainsFold != nil {
		predicates = append(predicates, codeissue.MessageContainsFold(*i.MessageContainsFold))
	}
	if i.Severity != nil {
		predicates = append(predicates, codeissue.SeverityEQ(*i.Severity))
	}
	if i.SeverityNEQ != nil {
		predicates = append(predicates, codeissue.SeverityNEQ(*i.SeverityNEQ))
	}
	if len(i.SeverityIn) > 0 {
		predicates = append(predicates, codeissue.SeverityIn(i.SeverityIn...))
	}
	if len(i.SeverityNotIn) > 0 {
		predicates = append(predicates, codeissue.SeverityNotIn(i.SeverityNotIn...))
	}
	if i.Type != nil {
		predicates = append(predicates, codeissue.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, codeissue.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, codeissue.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, codeissue.TypeNotIn(i.TypeNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, codeissue.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, codeissue.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, codeissue.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, codeissue.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, codeissue.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, codeissue.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, codeissue.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, codeissue.IDLTE(*i.IDLTE))
	}

	if i.HasCwe != nil {
		p := codeissue.HasCwe()
		if !*i.HasCwe {
			p = codeissue.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCweWith) > 0 {
		with := make([]predicate.CWE, 0, len(i.HasCweWith))
		for _, w := range i.HasCweWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codeissue.HasCweWith(with...))
	}
	if i.HasScan != nil {
		p := codeissue.HasScan()
		if !*i.HasScan {
			p = codeissue.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScanWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasScanWith))
		for _, w := range i.HasScanWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codeissue.HasScanWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate CodeIssueWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return codeissue.And(predicates...), nil
	}
}

// CodeScanWhereInput represents a where input for filtering CodeScan queries.
type CodeScanWhereInput struct {
	Not *CodeScanWhereInput   `json:"not,omitempty"`
	Or  []*CodeScanWhereInput `json:"or,omitempty"`
	And []*CodeScanWhereInput `json:"and,omitempty"`

	// "tool" field predicates.
	Tool             *string  `json:"tool,omitempty"`
	ToolNEQ          *string  `json:"toolNEQ,omitempty"`
	ToolIn           []string `json:"toolIn,omitempty"`
	ToolNotIn        []string `json:"toolNotIn,omitempty"`
	ToolGT           *string  `json:"toolGT,omitempty"`
	ToolGTE          *string  `json:"toolGTE,omitempty"`
	ToolLT           *string  `json:"toolLT,omitempty"`
	ToolLTE          *string  `json:"toolLTE,omitempty"`
	ToolContains     *string  `json:"toolContains,omitempty"`
	ToolHasPrefix    *string  `json:"toolHasPrefix,omitempty"`
	ToolHasSuffix    *string  `json:"toolHasSuffix,omitempty"`
	ToolEqualFold    *string  `json:"toolEqualFold,omitempty"`
	ToolContainsFold *string  `json:"toolContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "entry" edge predicates.
	HasEntry     *bool                     `json:"hasEntry,omitempty"`
	HasEntryWith []*ReleaseEntryWhereInput `json:"hasEntryWith,omitempty"`

	// "issues" edge predicates.
	HasIssues     *bool                  `json:"hasIssues,omitempty"`
	HasIssuesWith []*CodeIssueWhereInput `json:"hasIssuesWith,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                     `json:"hasComponents,omitempty"`
	HasComponentsWith []*ComponentUseWhereInput `json:"hasComponentsWith,omitempty"`
}

// Filter applies the CodeScanWhereInput filter on the CodeScanQuery builder.
func (i *CodeScanWhereInput) Filter(q *CodeScanQuery) (*CodeScanQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering codescans.
// An error is returned if the input is empty or invalid.
func (i *CodeScanWhereInput) P() (predicate.CodeScan, error) {
	var predicates []predicate.CodeScan
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, codescan.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CodeScan, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, codescan.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CodeScan, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, codescan.And(and...))
	}
	if i.Tool != nil {
		predicates = append(predicates, codescan.ToolEQ(*i.Tool))
	}
	if i.ToolNEQ != nil {
		predicates = append(predicates, codescan.ToolNEQ(*i.ToolNEQ))
	}
	if len(i.ToolIn) > 0 {
		predicates = append(predicates, codescan.ToolIn(i.ToolIn...))
	}
	if len(i.ToolNotIn) > 0 {
		predicates = append(predicates, codescan.ToolNotIn(i.ToolNotIn...))
	}
	if i.ToolGT != nil {
		predicates = append(predicates, codescan.ToolGT(*i.ToolGT))
	}
	if i.ToolGTE != nil {
		predicates = append(predicates, codescan.ToolGTE(*i.ToolGTE))
	}
	if i.ToolLT != nil {
		predicates = append(predicates, codescan.ToolLT(*i.ToolLT))
	}
	if i.ToolLTE != nil {
		predicates = append(predicates, codescan.ToolLTE(*i.ToolLTE))
	}
	if i.ToolContains != nil {
		predicates = append(predicates, codescan.ToolContains(*i.ToolContains))
	}
	if i.ToolHasPrefix != nil {
		predicates = append(predicates, codescan.ToolHasPrefix(*i.ToolHasPrefix))
	}
	if i.ToolHasSuffix != nil {
		predicates = append(predicates, codescan.ToolHasSuffix(*i.ToolHasSuffix))
	}
	if i.ToolEqualFold != nil {
		predicates = append(predicates, codescan.ToolEqualFold(*i.ToolEqualFold))
	}
	if i.ToolContainsFold != nil {
		predicates = append(predicates, codescan.ToolContainsFold(*i.ToolContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, codescan.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, codescan.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, codescan.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, codescan.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, codescan.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, codescan.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, codescan.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, codescan.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := codescan.HasRelease()
		if !*i.HasRelease {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasReleaseWith(with...))
	}
	if i.HasEntry != nil {
		p := codescan.HasEntry()
		if !*i.HasEntry {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntryWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasEntryWith))
		for _, w := range i.HasEntryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasEntryWith(with...))
	}
	if i.HasIssues != nil {
		p := codescan.HasIssues()
		if !*i.HasIssues {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIssuesWith) > 0 {
		with := make([]predicate.CodeIssue, 0, len(i.HasIssuesWith))
		for _, w := range i.HasIssuesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasIssuesWith(with...))
	}
	if i.HasComponents != nil {
		p := codescan.HasComponents()
		if !*i.HasComponents {
			p = codescan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.ComponentUse, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, codescan.HasComponentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate CodeScanWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return codescan.And(predicates...), nil
	}
}

// ComponentWhereInput represents a where input for filtering Component queries.
type ComponentWhereInput struct {
	Not *ComponentWhereInput   `json:"not,omitempty"`
	Or  []*ComponentWhereInput `json:"or,omitempty"`
	And []*ComponentWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "cves" edge predicates.
	HasCves     *bool            `json:"hasCves,omitempty"`
	HasCvesWith []*CVEWhereInput `json:"hasCvesWith,omitempty"`

	// "licenses" edge predicates.
	HasLicenses     *bool                `json:"hasLicenses,omitempty"`
	HasLicensesWith []*LicenseWhereInput `json:"hasLicensesWith,omitempty"`

	// "uses" edge predicates.
	HasUses     *bool                     `json:"hasUses,omitempty"`
	HasUsesWith []*ComponentUseWhereInput `json:"hasUsesWith,omitempty"`
}

// Filter applies the ComponentWhereInput filter on the ComponentQuery builder.
func (i *ComponentWhereInput) Filter(q *ComponentQuery) (*ComponentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering components.
// An error is returned if the input is empty or invalid.
func (i *ComponentWhereInput) P() (predicate.Component, error) {
	var predicates []predicate.Component
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, component.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Component, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, component.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Component, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, component.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, component.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, component.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, component.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, component.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, component.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, component.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, component.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, component.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, component.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, component.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, component.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, component.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, component.NameContainsFold(*i.NameContainsFold))
	}
	if i.Vendor != nil {
		predicates = append(predicates, component.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, component.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, component.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, component.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, component.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, component.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, component.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, component.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, component.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, component.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, component.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, component.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, component.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, component.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, component.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, component.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, component.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, component.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, component.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, component.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, component.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, component.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, component.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, component.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, component.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, component.VersionContainsFold(*i.VersionContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, component.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, component.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, component.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, component.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, component.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, component.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, component.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, component.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, component.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, component.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, component.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, component.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, component.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, component.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, component.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, component.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, component.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, component.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, component.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, component.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, component.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, component.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, component.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, component.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, component.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, component.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, component.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, component.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, component.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, component.URLContainsFold(*i.URLContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, component.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, component.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, component.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, component.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, component.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, component.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, component.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, component.IDLTE(*i.IDLTE))
	}

	if i.HasCves != nil {
		p := component.HasCves()
		if !*i.HasCves {
			p = component.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCvesWith) > 0 {
		with := make([]predicate.CVE, 0, len(i.HasCvesWith))
		for _, w := range i.HasCvesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, component.HasCvesWith(with...))
	}
	if i.HasLicenses != nil {
		p := component.HasLicenses()
		if !*i.HasLicenses {
			p = component.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicensesWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicensesWith))
		for _, w := range i.HasLicensesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, component.HasLicensesWith(with...))
	}
	if i.HasUses != nil {
		p := component.HasUses()
		if !*i.HasUses {
			p = component.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsesWith) > 0 {
		with := make([]predicate.ComponentUse, 0, len(i.HasUsesWith))
		for _, w := range i.HasUsesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, component.HasUsesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ComponentWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return component.And(predicates...), nil
	}
}

// ComponentUseWhereInput represents a where input for filtering ComponentUse queries.
type ComponentUseWhereInput struct {
	Not *ComponentUseWhereInput   `json:"not,omitempty"`
	Or  []*ComponentUseWhereInput `json:"or,omitempty"`
	And []*ComponentUseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "scans" edge predicates.
	HasScans     *bool                 `json:"hasScans,omitempty"`
	HasScansWith []*CodeScanWhereInput `json:"hasScansWith,omitempty"`

	// "component" edge predicates.
	HasComponent     *bool                  `json:"hasComponent,omitempty"`
	HasComponentWith []*ComponentWhereInput `json:"hasComponentWith,omitempty"`
}

// Filter applies the ComponentUseWhereInput filter on the ComponentUseQuery builder.
func (i *ComponentUseWhereInput) Filter(q *ComponentUseQuery) (*ComponentUseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering componentuses.
// An error is returned if the input is empty or invalid.
func (i *ComponentUseWhereInput) P() (predicate.ComponentUse, error) {
	var predicates []predicate.ComponentUse
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, componentuse.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ComponentUse, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, componentuse.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ComponentUse, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, componentuse.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, componentuse.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, componentuse.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, componentuse.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, componentuse.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, componentuse.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, componentuse.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, componentuse.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, componentuse.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := componentuse.HasRelease()
		if !*i.HasRelease {
			p = componentuse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, componentuse.HasReleaseWith(with...))
	}
	if i.HasScans != nil {
		p := componentuse.HasScans()
		if !*i.HasScans {
			p = componentuse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScansWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasScansWith))
		for _, w := range i.HasScansWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, componentuse.HasScansWith(with...))
	}
	if i.HasComponent != nil {
		p := componentuse.HasComponent()
		if !*i.HasComponent {
			p = componentuse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentWith) > 0 {
		with := make([]predicate.Component, 0, len(i.HasComponentWith))
		for _, w := range i.HasComponentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, componentuse.HasComponentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ComponentUseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return componentuse.And(predicates...), nil
	}
}

// GitCommitWhereInput represents a where input for filtering GitCommit queries.
type GitCommitWhereInput struct {
	Not *GitCommitWhereInput   `json:"not,omitempty"`
	Or  []*GitCommitWhereInput `json:"or,omitempty"`
	And []*GitCommitWhereInput `json:"and,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "branch" field predicates.
	Branch             *string  `json:"branch,omitempty"`
	BranchNEQ          *string  `json:"branchNEQ,omitempty"`
	BranchIn           []string `json:"branchIn,omitempty"`
	BranchNotIn        []string `json:"branchNotIn,omitempty"`
	BranchGT           *string  `json:"branchGT,omitempty"`
	BranchGTE          *string  `json:"branchGTE,omitempty"`
	BranchLT           *string  `json:"branchLT,omitempty"`
	BranchLTE          *string  `json:"branchLTE,omitempty"`
	BranchContains     *string  `json:"branchContains,omitempty"`
	BranchHasPrefix    *string  `json:"branchHasPrefix,omitempty"`
	BranchHasSuffix    *string  `json:"branchHasSuffix,omitempty"`
	BranchEqualFold    *string  `json:"branchEqualFold,omitempty"`
	BranchContainsFold *string  `json:"branchContainsFold,omitempty"`

	// "tag" field predicates.
	Tag             *string  `json:"tag,omitempty"`
	TagNEQ          *string  `json:"tagNEQ,omitempty"`
	TagIn           []string `json:"tagIn,omitempty"`
	TagNotIn        []string `json:"tagNotIn,omitempty"`
	TagGT           *string  `json:"tagGT,omitempty"`
	TagGTE          *string  `json:"tagGTE,omitempty"`
	TagLT           *string  `json:"tagLT,omitempty"`
	TagLTE          *string  `json:"tagLTE,omitempty"`
	TagContains     *string  `json:"tagContains,omitempty"`
	TagHasPrefix    *string  `json:"tagHasPrefix,omitempty"`
	TagHasSuffix    *string  `json:"tagHasSuffix,omitempty"`
	TagIsNil        bool     `json:"tagIsNil,omitempty"`
	TagNotNil       bool     `json:"tagNotNil,omitempty"`
	TagEqualFold    *string  `json:"tagEqualFold,omitempty"`
	TagContainsFold *string  `json:"tagContainsFold,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "repo" edge predicates.
	HasRepo     *bool             `json:"hasRepo,omitempty"`
	HasRepoWith []*RepoWhereInput `json:"hasRepoWith,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`
}

// Filter applies the GitCommitWhereInput filter on the GitCommitQuery builder.
func (i *GitCommitWhereInput) Filter(q *GitCommitQuery) (*GitCommitQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering gitcommits.
// An error is returned if the input is empty or invalid.
func (i *GitCommitWhereInput) P() (predicate.GitCommit, error) {
	var predicates []predicate.GitCommit
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, gitcommit.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GitCommit, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, gitcommit.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GitCommit, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, gitcommit.And(and...))
	}
	if i.Hash != nil {
		predicates = append(predicates, gitcommit.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, gitcommit.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, gitcommit.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, gitcommit.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, gitcommit.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, gitcommit.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, gitcommit.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, gitcommit.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, gitcommit.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, gitcommit.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, gitcommit.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, gitcommit.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, gitcommit.HashContainsFold(*i.HashContainsFold))
	}
	if i.Branch != nil {
		predicates = append(predicates, gitcommit.BranchEQ(*i.Branch))
	}
	if i.BranchNEQ != nil {
		predicates = append(predicates, gitcommit.BranchNEQ(*i.BranchNEQ))
	}
	if len(i.BranchIn) > 0 {
		predicates = append(predicates, gitcommit.BranchIn(i.BranchIn...))
	}
	if len(i.BranchNotIn) > 0 {
		predicates = append(predicates, gitcommit.BranchNotIn(i.BranchNotIn...))
	}
	if i.BranchGT != nil {
		predicates = append(predicates, gitcommit.BranchGT(*i.BranchGT))
	}
	if i.BranchGTE != nil {
		predicates = append(predicates, gitcommit.BranchGTE(*i.BranchGTE))
	}
	if i.BranchLT != nil {
		predicates = append(predicates, gitcommit.BranchLT(*i.BranchLT))
	}
	if i.BranchLTE != nil {
		predicates = append(predicates, gitcommit.BranchLTE(*i.BranchLTE))
	}
	if i.BranchContains != nil {
		predicates = append(predicates, gitcommit.BranchContains(*i.BranchContains))
	}
	if i.BranchHasPrefix != nil {
		predicates = append(predicates, gitcommit.BranchHasPrefix(*i.BranchHasPrefix))
	}
	if i.BranchHasSuffix != nil {
		predicates = append(predicates, gitcommit.BranchHasSuffix(*i.BranchHasSuffix))
	}
	if i.BranchEqualFold != nil {
		predicates = append(predicates, gitcommit.BranchEqualFold(*i.BranchEqualFold))
	}
	if i.BranchContainsFold != nil {
		predicates = append(predicates, gitcommit.BranchContainsFold(*i.BranchContainsFold))
	}
	if i.Tag != nil {
		predicates = append(predicates, gitcommit.TagEQ(*i.Tag))
	}
	if i.TagNEQ != nil {
		predicates = append(predicates, gitcommit.TagNEQ(*i.TagNEQ))
	}
	if len(i.TagIn) > 0 {
		predicates = append(predicates, gitcommit.TagIn(i.TagIn...))
	}
	if len(i.TagNotIn) > 0 {
		predicates = append(predicates, gitcommit.TagNotIn(i.TagNotIn...))
	}
	if i.TagGT != nil {
		predicates = append(predicates, gitcommit.TagGT(*i.TagGT))
	}
	if i.TagGTE != nil {
		predicates = append(predicates, gitcommit.TagGTE(*i.TagGTE))
	}
	if i.TagLT != nil {
		predicates = append(predicates, gitcommit.TagLT(*i.TagLT))
	}
	if i.TagLTE != nil {
		predicates = append(predicates, gitcommit.TagLTE(*i.TagLTE))
	}
	if i.TagContains != nil {
		predicates = append(predicates, gitcommit.TagContains(*i.TagContains))
	}
	if i.TagHasPrefix != nil {
		predicates = append(predicates, gitcommit.TagHasPrefix(*i.TagHasPrefix))
	}
	if i.TagHasSuffix != nil {
		predicates = append(predicates, gitcommit.TagHasSuffix(*i.TagHasSuffix))
	}
	if i.TagIsNil {
		predicates = append(predicates, gitcommit.TagIsNil())
	}
	if i.TagNotNil {
		predicates = append(predicates, gitcommit.TagNotNil())
	}
	if i.TagEqualFold != nil {
		predicates = append(predicates, gitcommit.TagEqualFold(*i.TagEqualFold))
	}
	if i.TagContainsFold != nil {
		predicates = append(predicates, gitcommit.TagContainsFold(*i.TagContainsFold))
	}
	if i.Time != nil {
		predicates = append(predicates, gitcommit.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, gitcommit.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, gitcommit.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, gitcommit.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, gitcommit.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, gitcommit.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, gitcommit.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, gitcommit.TimeLTE(*i.TimeLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, gitcommit.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gitcommit.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gitcommit.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gitcommit.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gitcommit.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gitcommit.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gitcommit.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gitcommit.IDLTE(*i.IDLTE))
	}

	if i.HasRepo != nil {
		p := gitcommit.HasRepo()
		if !*i.HasRepo {
			p = gitcommit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRepoWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasRepoWith))
		for _, w := range i.HasRepoWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, gitcommit.HasRepoWith(with...))
	}
	if i.HasRelease != nil {
		p := gitcommit.HasRelease()
		if !*i.HasRelease {
			p = gitcommit.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, gitcommit.HasReleaseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate GitCommitWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return gitcommit.And(predicates...), nil
	}
}

// LicenseWhereInput represents a where input for filtering License queries.
type LicenseWhereInput struct {
	Not *LicenseWhereInput   `json:"not,omitempty"`
	Or  []*LicenseWhereInput `json:"or,omitempty"`
	And []*LicenseWhereInput `json:"and,omitempty"`

	// "spdx_id" field predicates.
	SpdxID             *string  `json:"spdxID,omitempty"`
	SpdxIDNEQ          *string  `json:"spdxIDNEQ,omitempty"`
	SpdxIDIn           []string `json:"spdxIDIn,omitempty"`
	SpdxIDNotIn        []string `json:"spdxIDNotIn,omitempty"`
	SpdxIDGT           *string  `json:"spdxIDGT,omitempty"`
	SpdxIDGTE          *string  `json:"spdxIDGTE,omitempty"`
	SpdxIDLT           *string  `json:"spdxIDLT,omitempty"`
	SpdxIDLTE          *string  `json:"spdxIDLTE,omitempty"`
	SpdxIDContains     *string  `json:"spdxIDContains,omitempty"`
	SpdxIDHasPrefix    *string  `json:"spdxIDHasPrefix,omitempty"`
	SpdxIDHasSuffix    *string  `json:"spdxIDHasSuffix,omitempty"`
	SpdxIDEqualFold    *string  `json:"spdxIDEqualFold,omitempty"`
	SpdxIDContainsFold *string  `json:"spdxIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "reference" field predicates.
	Reference             *string  `json:"reference,omitempty"`
	ReferenceNEQ          *string  `json:"referenceNEQ,omitempty"`
	ReferenceIn           []string `json:"referenceIn,omitempty"`
	ReferenceNotIn        []string `json:"referenceNotIn,omitempty"`
	ReferenceGT           *string  `json:"referenceGT,omitempty"`
	ReferenceGTE          *string  `json:"referenceGTE,omitempty"`
	ReferenceLT           *string  `json:"referenceLT,omitempty"`
	ReferenceLTE          *string  `json:"referenceLTE,omitempty"`
	ReferenceContains     *string  `json:"referenceContains,omitempty"`
	ReferenceHasPrefix    *string  `json:"referenceHasPrefix,omitempty"`
	ReferenceHasSuffix    *string  `json:"referenceHasSuffix,omitempty"`
	ReferenceIsNil        bool     `json:"referenceIsNil,omitempty"`
	ReferenceNotNil       bool     `json:"referenceNotNil,omitempty"`
	ReferenceEqualFold    *string  `json:"referenceEqualFold,omitempty"`
	ReferenceContainsFold *string  `json:"referenceContainsFold,omitempty"`

	// "details_url" field predicates.
	DetailsURL             *string  `json:"detailsURL,omitempty"`
	DetailsURLNEQ          *string  `json:"detailsURLNEQ,omitempty"`
	DetailsURLIn           []string `json:"detailsURLIn,omitempty"`
	DetailsURLNotIn        []string `json:"detailsURLNotIn,omitempty"`
	DetailsURLGT           *string  `json:"detailsURLGT,omitempty"`
	DetailsURLGTE          *string  `json:"detailsURLGTE,omitempty"`
	DetailsURLLT           *string  `json:"detailsURLLT,omitempty"`
	DetailsURLLTE          *string  `json:"detailsURLLTE,omitempty"`
	DetailsURLContains     *string  `json:"detailsURLContains,omitempty"`
	DetailsURLHasPrefix    *string  `json:"detailsURLHasPrefix,omitempty"`
	DetailsURLHasSuffix    *string  `json:"detailsURLHasSuffix,omitempty"`
	DetailsURLIsNil        bool     `json:"detailsURLIsNil,omitempty"`
	DetailsURLNotNil       bool     `json:"detailsURLNotNil,omitempty"`
	DetailsURLEqualFold    *string  `json:"detailsURLEqualFold,omitempty"`
	DetailsURLContainsFold *string  `json:"detailsURLContainsFold,omitempty"`

	// "is_osi_approved" field predicates.
	IsOsiApproved    *bool `json:"isOsiApproved,omitempty"`
	IsOsiApprovedNEQ *bool `json:"isOsiApprovedNEQ,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                  `json:"hasComponents,omitempty"`
	HasComponentsWith []*ComponentWhereInput `json:"hasComponentsWith,omitempty"`

	// "uses" edge predicates.
	HasUses     *bool                   `json:"hasUses,omitempty"`
	HasUsesWith []*LicenseUseWhereInput `json:"hasUsesWith,omitempty"`
}

// Filter applies the LicenseWhereInput filter on the LicenseQuery builder.
func (i *LicenseWhereInput) Filter(q *LicenseQuery) (*LicenseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering licenses.
// An error is returned if the input is empty or invalid.
func (i *LicenseWhereInput) P() (predicate.License, error) {
	var predicates []predicate.License
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, license.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.License, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, license.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.License, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, license.And(and...))
	}
	if i.SpdxID != nil {
		predicates = append(predicates, license.SpdxIDEQ(*i.SpdxID))
	}
	if i.SpdxIDNEQ != nil {
		predicates = append(predicates, license.SpdxIDNEQ(*i.SpdxIDNEQ))
	}
	if len(i.SpdxIDIn) > 0 {
		predicates = append(predicates, license.SpdxIDIn(i.SpdxIDIn...))
	}
	if len(i.SpdxIDNotIn) > 0 {
		predicates = append(predicates, license.SpdxIDNotIn(i.SpdxIDNotIn...))
	}
	if i.SpdxIDGT != nil {
		predicates = append(predicates, license.SpdxIDGT(*i.SpdxIDGT))
	}
	if i.SpdxIDGTE != nil {
		predicates = append(predicates, license.SpdxIDGTE(*i.SpdxIDGTE))
	}
	if i.SpdxIDLT != nil {
		predicates = append(predicates, license.SpdxIDLT(*i.SpdxIDLT))
	}
	if i.SpdxIDLTE != nil {
		predicates = append(predicates, license.SpdxIDLTE(*i.SpdxIDLTE))
	}
	if i.SpdxIDContains != nil {
		predicates = append(predicates, license.SpdxIDContains(*i.SpdxIDContains))
	}
	if i.SpdxIDHasPrefix != nil {
		predicates = append(predicates, license.SpdxIDHasPrefix(*i.SpdxIDHasPrefix))
	}
	if i.SpdxIDHasSuffix != nil {
		predicates = append(predicates, license.SpdxIDHasSuffix(*i.SpdxIDHasSuffix))
	}
	if i.SpdxIDEqualFold != nil {
		predicates = append(predicates, license.SpdxIDEqualFold(*i.SpdxIDEqualFold))
	}
	if i.SpdxIDContainsFold != nil {
		predicates = append(predicates, license.SpdxIDContainsFold(*i.SpdxIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, license.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, license.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, license.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, license.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, license.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, license.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, license.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, license.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, license.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, license.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, license.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, license.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, license.NameContainsFold(*i.NameContainsFold))
	}
	if i.Reference != nil {
		predicates = append(predicates, license.ReferenceEQ(*i.Reference))
	}
	if i.ReferenceNEQ != nil {
		predicates = append(predicates, license.ReferenceNEQ(*i.ReferenceNEQ))
	}
	if len(i.ReferenceIn) > 0 {
		predicates = append(predicates, license.ReferenceIn(i.ReferenceIn...))
	}
	if len(i.ReferenceNotIn) > 0 {
		predicates = append(predicates, license.ReferenceNotIn(i.ReferenceNotIn...))
	}
	if i.ReferenceGT != nil {
		predicates = append(predicates, license.ReferenceGT(*i.ReferenceGT))
	}
	if i.ReferenceGTE != nil {
		predicates = append(predicates, license.ReferenceGTE(*i.ReferenceGTE))
	}
	if i.ReferenceLT != nil {
		predicates = append(predicates, license.ReferenceLT(*i.ReferenceLT))
	}
	if i.ReferenceLTE != nil {
		predicates = append(predicates, license.ReferenceLTE(*i.ReferenceLTE))
	}
	if i.ReferenceContains != nil {
		predicates = append(predicates, license.ReferenceContains(*i.ReferenceContains))
	}
	if i.ReferenceHasPrefix != nil {
		predicates = append(predicates, license.ReferenceHasPrefix(*i.ReferenceHasPrefix))
	}
	if i.ReferenceHasSuffix != nil {
		predicates = append(predicates, license.ReferenceHasSuffix(*i.ReferenceHasSuffix))
	}
	if i.ReferenceIsNil {
		predicates = append(predicates, license.ReferenceIsNil())
	}
	if i.ReferenceNotNil {
		predicates = append(predicates, license.ReferenceNotNil())
	}
	if i.ReferenceEqualFold != nil {
		predicates = append(predicates, license.ReferenceEqualFold(*i.ReferenceEqualFold))
	}
	if i.ReferenceContainsFold != nil {
		predicates = append(predicates, license.ReferenceContainsFold(*i.ReferenceContainsFold))
	}
	if i.DetailsURL != nil {
		predicates = append(predicates, license.DetailsURLEQ(*i.DetailsURL))
	}
	if i.DetailsURLNEQ != nil {
		predicates = append(predicates, license.DetailsURLNEQ(*i.DetailsURLNEQ))
	}
	if len(i.DetailsURLIn) > 0 {
		predicates = append(predicates, license.DetailsURLIn(i.DetailsURLIn...))
	}
	if len(i.DetailsURLNotIn) > 0 {
		predicates = append(predicates, license.DetailsURLNotIn(i.DetailsURLNotIn...))
	}
	if i.DetailsURLGT != nil {
		predicates = append(predicates, license.DetailsURLGT(*i.DetailsURLGT))
	}
	if i.DetailsURLGTE != nil {
		predicates = append(predicates, license.DetailsURLGTE(*i.DetailsURLGTE))
	}
	if i.DetailsURLLT != nil {
		predicates = append(predicates, license.DetailsURLLT(*i.DetailsURLLT))
	}
	if i.DetailsURLLTE != nil {
		predicates = append(predicates, license.DetailsURLLTE(*i.DetailsURLLTE))
	}
	if i.DetailsURLContains != nil {
		predicates = append(predicates, license.DetailsURLContains(*i.DetailsURLContains))
	}
	if i.DetailsURLHasPrefix != nil {
		predicates = append(predicates, license.DetailsURLHasPrefix(*i.DetailsURLHasPrefix))
	}
	if i.DetailsURLHasSuffix != nil {
		predicates = append(predicates, license.DetailsURLHasSuffix(*i.DetailsURLHasSuffix))
	}
	if i.DetailsURLIsNil {
		predicates = append(predicates, license.DetailsURLIsNil())
	}
	if i.DetailsURLNotNil {
		predicates = append(predicates, license.DetailsURLNotNil())
	}
	if i.DetailsURLEqualFold != nil {
		predicates = append(predicates, license.DetailsURLEqualFold(*i.DetailsURLEqualFold))
	}
	if i.DetailsURLContainsFold != nil {
		predicates = append(predicates, license.DetailsURLContainsFold(*i.DetailsURLContainsFold))
	}
	if i.IsOsiApproved != nil {
		predicates = append(predicates, license.IsOsiApprovedEQ(*i.IsOsiApproved))
	}
	if i.IsOsiApprovedNEQ != nil {
		predicates = append(predicates, license.IsOsiApprovedNEQ(*i.IsOsiApprovedNEQ))
	}
	if i.ID != nil {
		predicates = append(predicates, license.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, license.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, license.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, license.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, license.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, license.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, license.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, license.IDLTE(*i.IDLTE))
	}

	if i.HasComponents != nil {
		p := license.HasComponents()
		if !*i.HasComponents {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.Component, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasComponentsWith(with...))
	}
	if i.HasUses != nil {
		p := license.HasUses()
		if !*i.HasUses {
			p = license.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsesWith) > 0 {
		with := make([]predicate.LicenseUse, 0, len(i.HasUsesWith))
		for _, w := range i.HasUsesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, license.HasUsesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate LicenseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return license.And(predicates...), nil
	}
}

// LicenseUseWhereInput represents a where input for filtering LicenseUse queries.
type LicenseUseWhereInput struct {
	Not *LicenseUseWhereInput   `json:"not,omitempty"`
	Or  []*LicenseUseWhereInput `json:"or,omitempty"`
	And []*LicenseUseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "license" edge predicates.
	HasLicense     *bool                `json:"hasLicense,omitempty"`
	HasLicenseWith []*LicenseWhereInput `json:"hasLicenseWith,omitempty"`
}

// Filter applies the LicenseUseWhereInput filter on the LicenseUseQuery builder.
func (i *LicenseUseWhereInput) Filter(q *LicenseUseQuery) (*LicenseUseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering licenseuses.
// An error is returned if the input is empty or invalid.
func (i *LicenseUseWhereInput) P() (predicate.LicenseUse, error) {
	var predicates []predicate.LicenseUse
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, licenseuse.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.LicenseUse, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, licenseuse.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.LicenseUse, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, licenseuse.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, licenseuse.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, licenseuse.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, licenseuse.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, licenseuse.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, licenseuse.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, licenseuse.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, licenseuse.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, licenseuse.IDLTE(*i.IDLTE))
	}

	if i.HasLicense != nil {
		p := licenseuse.HasLicense()
		if !*i.HasLicense {
			p = licenseuse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLicenseWith) > 0 {
		with := make([]predicate.License, 0, len(i.HasLicenseWith))
		for _, w := range i.HasLicenseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, licenseuse.HasLicenseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate LicenseUseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return licenseuse.And(predicates...), nil
	}
}

// ProjectWhereInput represents a where input for filtering Project queries.
type ProjectWhereInput struct {
	Not *ProjectWhereInput   `json:"not,omitempty"`
	Or  []*ProjectWhereInput `json:"or,omitempty"`
	And []*ProjectWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "repos" edge predicates.
	HasRepos     *bool             `json:"hasRepos,omitempty"`
	HasReposWith []*RepoWhereInput `json:"hasReposWith,omitempty"`

	// "releases" edge predicates.
	HasReleases     *bool                `json:"hasReleases,omitempty"`
	HasReleasesWith []*ReleaseWhereInput `json:"hasReleasesWith,omitempty"`

	// "cve_rules" edge predicates.
	HasCveRules     *bool                `json:"hasCveRules,omitempty"`
	HasCveRulesWith []*CVERuleWhereInput `json:"hasCveRulesWith,omitempty"`
}

// Filter applies the ProjectWhereInput filter on the ProjectQuery builder.
func (i *ProjectWhereInput) Filter(q *ProjectQuery) (*ProjectQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering projects.
// An error is returned if the input is empty or invalid.
func (i *ProjectWhereInput) P() (predicate.Project, error) {
	var predicates []predicate.Project
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, project.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Project, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, project.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Project, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, project.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, project.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, project.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, project.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, project.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, project.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, project.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, project.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, project.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, project.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, project.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, project.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, project.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, project.NameContainsFold(*i.NameContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, project.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, project.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, project.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, project.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, project.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, project.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, project.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, project.IDLTE(*i.IDLTE))
	}

	if i.HasRepos != nil {
		p := project.HasRepos()
		if !*i.HasRepos {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReposWith) > 0 {
		with := make([]predicate.Repo, 0, len(i.HasReposWith))
		for _, w := range i.HasReposWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasReposWith(with...))
	}
	if i.HasReleases != nil {
		p := project.HasReleases()
		if !*i.HasReleases {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleasesWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleasesWith))
		for _, w := range i.HasReleasesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasReleasesWith(with...))
	}
	if i.HasCveRules != nil {
		p := project.HasCveRules()
		if !*i.HasCveRules {
			p = project.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCveRulesWith) > 0 {
		with := make([]predicate.CVERule, 0, len(i.HasCveRulesWith))
		for _, w := range i.HasCveRulesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, project.HasCveRulesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ProjectWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return project.And(predicates...), nil
	}
}

// ReleaseWhereInput represents a where input for filtering Release queries.
type ReleaseWhereInput struct {
	Not *ReleaseWhereInput   `json:"not,omitempty"`
	Or  []*ReleaseWhereInput `json:"or,omitempty"`
	And []*ReleaseWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *release.Status  `json:"status,omitempty"`
	StatusNEQ   *release.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []release.Status `json:"statusIn,omitempty"`
	StatusNotIn []release.Status `json:"statusNotIn,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "subreleases" edge predicates.
	HasSubreleases     *bool                `json:"hasSubreleases,omitempty"`
	HasSubreleasesWith []*ReleaseWhereInput `json:"hasSubreleasesWith,omitempty"`

	// "dependencies" edge predicates.
	HasDependencies     *bool                `json:"hasDependencies,omitempty"`
	HasDependenciesWith []*ReleaseWhereInput `json:"hasDependenciesWith,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "commit" edge predicates.
	HasCommit     *bool                  `json:"hasCommit,omitempty"`
	HasCommitWith []*GitCommitWhereInput `json:"hasCommitWith,omitempty"`

	// "log" edge predicates.
	HasLog     *bool                     `json:"hasLog,omitempty"`
	HasLogWith []*ReleaseEntryWhereInput `json:"hasLogWith,omitempty"`

	// "artifacts" edge predicates.
	HasArtifacts     *bool                 `json:"hasArtifacts,omitempty"`
	HasArtifactsWith []*ArtifactWhereInput `json:"hasArtifactsWith,omitempty"`

	// "components" edge predicates.
	HasComponents     *bool                     `json:"hasComponents,omitempty"`
	HasComponentsWith []*ComponentUseWhereInput `json:"hasComponentsWith,omitempty"`

	// "code_scans" edge predicates.
	HasCodeScans     *bool                 `json:"hasCodeScans,omitempty"`
	HasCodeScansWith []*CodeScanWhereInput `json:"hasCodeScansWith,omitempty"`

	// "test_runs" edge predicates.
	HasTestRuns     *bool                `json:"hasTestRuns,omitempty"`
	HasTestRunsWith []*TestRunWhereInput `json:"hasTestRunsWith,omitempty"`
}

// Filter applies the ReleaseWhereInput filter on the ReleaseQuery builder.
func (i *ReleaseWhereInput) Filter(q *ReleaseQuery) (*ReleaseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releases.
// An error is returned if the input is empty or invalid.
func (i *ReleaseWhereInput) P() (predicate.Release, error) {
	var predicates []predicate.Release
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, release.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Release, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, release.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Release, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, release.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, release.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, release.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, release.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, release.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, release.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, release.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, release.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, release.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, release.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, release.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, release.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, release.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, release.NameContainsFold(*i.NameContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, release.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, release.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, release.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, release.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, release.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, release.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, release.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, release.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, release.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, release.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, release.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, release.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, release.VersionContainsFold(*i.VersionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, release.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, release.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, release.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, release.StatusNotIn(i.StatusNotIn...))
	}
	if i.ID != nil {
		predicates = append(predicates, release.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, release.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, release.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, release.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, release.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, release.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, release.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, release.IDLTE(*i.IDLTE))
	}

	if i.HasSubreleases != nil {
		p := release.HasSubreleases()
		if !*i.HasSubreleases {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubreleasesWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasSubreleasesWith))
		for _, w := range i.HasSubreleasesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasSubreleasesWith(with...))
	}
	if i.HasDependencies != nil {
		p := release.HasDependencies()
		if !*i.HasDependencies {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDependenciesWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasDependenciesWith))
		for _, w := range i.HasDependenciesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasDependenciesWith(with...))
	}
	if i.HasProject != nil {
		p := release.HasProject()
		if !*i.HasProject {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasProjectWith(with...))
	}
	if i.HasCommit != nil {
		p := release.HasCommit()
		if !*i.HasCommit {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommitWith) > 0 {
		with := make([]predicate.GitCommit, 0, len(i.HasCommitWith))
		for _, w := range i.HasCommitWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasCommitWith(with...))
	}
	if i.HasLog != nil {
		p := release.HasLog()
		if !*i.HasLog {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasLogWith))
		for _, w := range i.HasLogWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasLogWith(with...))
	}
	if i.HasArtifacts != nil {
		p := release.HasArtifacts()
		if !*i.HasArtifacts {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactsWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactsWith))
		for _, w := range i.HasArtifactsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasArtifactsWith(with...))
	}
	if i.HasComponents != nil {
		p := release.HasComponents()
		if !*i.HasComponents {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasComponentsWith) > 0 {
		with := make([]predicate.ComponentUse, 0, len(i.HasComponentsWith))
		for _, w := range i.HasComponentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasComponentsWith(with...))
	}
	if i.HasCodeScans != nil {
		p := release.HasCodeScans()
		if !*i.HasCodeScans {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCodeScansWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasCodeScansWith))
		for _, w := range i.HasCodeScansWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasCodeScansWith(with...))
	}
	if i.HasTestRuns != nil {
		p := release.HasTestRuns()
		if !*i.HasTestRuns {
			p = release.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestRunsWith) > 0 {
		with := make([]predicate.TestRun, 0, len(i.HasTestRunsWith))
		for _, w := range i.HasTestRunsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, release.HasTestRunsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleaseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return release.And(predicates...), nil
	}
}

// ReleaseEntryWhereInput represents a where input for filtering ReleaseEntry queries.
type ReleaseEntryWhereInput struct {
	Not *ReleaseEntryWhereInput   `json:"not,omitempty"`
	Or  []*ReleaseEntryWhereInput `json:"or,omitempty"`
	And []*ReleaseEntryWhereInput `json:"and,omitempty"`

	// "type" field predicates.
	Type      *releaseentry.Type  `json:"type,omitempty"`
	TypeNEQ   *releaseentry.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []releaseentry.Type `json:"typeIn,omitempty"`
	TypeNotIn []releaseentry.Type `json:"typeNotIn,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "artifact" edge predicates.
	HasArtifact     *bool                 `json:"hasArtifact,omitempty"`
	HasArtifactWith []*ArtifactWhereInput `json:"hasArtifactWith,omitempty"`

	// "code_scan" edge predicates.
	HasCodeScan     *bool                 `json:"hasCodeScan,omitempty"`
	HasCodeScanWith []*CodeScanWhereInput `json:"hasCodeScanWith,omitempty"`

	// "test_run" edge predicates.
	HasTestRun     *bool                `json:"hasTestRun,omitempty"`
	HasTestRunWith []*TestRunWhereInput `json:"hasTestRunWith,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`
}

// Filter applies the ReleaseEntryWhereInput filter on the ReleaseEntryQuery builder.
func (i *ReleaseEntryWhereInput) Filter(q *ReleaseEntryQuery) (*ReleaseEntryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering releaseentries.
// An error is returned if the input is empty or invalid.
func (i *ReleaseEntryWhereInput) P() (predicate.ReleaseEntry, error) {
	var predicates []predicate.ReleaseEntry
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, releaseentry.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReleaseEntry, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, releaseentry.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReleaseEntry, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, releaseentry.And(and...))
	}
	if i.Type != nil {
		predicates = append(predicates, releaseentry.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, releaseentry.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, releaseentry.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, releaseentry.TypeNotIn(i.TypeNotIn...))
	}
	if i.Time != nil {
		predicates = append(predicates, releaseentry.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, releaseentry.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, releaseentry.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, releaseentry.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, releaseentry.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, releaseentry.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, releaseentry.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, releaseentry.TimeLTE(*i.TimeLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, releaseentry.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, releaseentry.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, releaseentry.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, releaseentry.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, releaseentry.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, releaseentry.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, releaseentry.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, releaseentry.IDLTE(*i.IDLTE))
	}

	if i.HasArtifact != nil {
		p := releaseentry.HasArtifact()
		if !*i.HasArtifact {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArtifactWith) > 0 {
		with := make([]predicate.Artifact, 0, len(i.HasArtifactWith))
		for _, w := range i.HasArtifactWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasArtifactWith(with...))
	}
	if i.HasCodeScan != nil {
		p := releaseentry.HasCodeScan()
		if !*i.HasCodeScan {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCodeScanWith) > 0 {
		with := make([]predicate.CodeScan, 0, len(i.HasCodeScanWith))
		for _, w := range i.HasCodeScanWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasCodeScanWith(with...))
	}
	if i.HasTestRun != nil {
		p := releaseentry.HasTestRun()
		if !*i.HasTestRun {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestRunWith) > 0 {
		with := make([]predicate.TestRun, 0, len(i.HasTestRunWith))
		for _, w := range i.HasTestRunWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasTestRunWith(with...))
	}
	if i.HasRelease != nil {
		p := releaseentry.HasRelease()
		if !*i.HasRelease {
			p = releaseentry.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, releaseentry.HasReleaseWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate ReleaseEntryWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return releaseentry.And(predicates...), nil
	}
}

// RepoWhereInput represents a where input for filtering Repo queries.
type RepoWhereInput struct {
	Not *RepoWhereInput   `json:"not,omitempty"`
	Or  []*RepoWhereInput `json:"or,omitempty"`
	And []*RepoWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "project" edge predicates.
	HasProject     *bool                `json:"hasProject,omitempty"`
	HasProjectWith []*ProjectWhereInput `json:"hasProjectWith,omitempty"`

	// "commits" edge predicates.
	HasCommits     *bool                  `json:"hasCommits,omitempty"`
	HasCommitsWith []*GitCommitWhereInput `json:"hasCommitsWith,omitempty"`

	// "cve_rules" edge predicates.
	HasCveRules     *bool                `json:"hasCveRules,omitempty"`
	HasCveRulesWith []*CVERuleWhereInput `json:"hasCveRulesWith,omitempty"`
}

// Filter applies the RepoWhereInput filter on the RepoQuery builder.
func (i *RepoWhereInput) Filter(q *RepoQuery) (*RepoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering repos.
// An error is returned if the input is empty or invalid.
func (i *RepoWhereInput) P() (predicate.Repo, error) {
	var predicates []predicate.Repo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, repo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Repo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, repo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Repo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, repo.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, repo.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, repo.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, repo.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, repo.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, repo.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, repo.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, repo.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, repo.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, repo.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, repo.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, repo.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, repo.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, repo.NameContainsFold(*i.NameContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, repo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, repo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, repo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, repo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, repo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, repo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, repo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, repo.IDLTE(*i.IDLTE))
	}

	if i.HasProject != nil {
		p := repo.HasProject()
		if !*i.HasProject {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProjectWith) > 0 {
		with := make([]predicate.Project, 0, len(i.HasProjectWith))
		for _, w := range i.HasProjectWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasProjectWith(with...))
	}
	if i.HasCommits != nil {
		p := repo.HasCommits()
		if !*i.HasCommits {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommitsWith) > 0 {
		with := make([]predicate.GitCommit, 0, len(i.HasCommitsWith))
		for _, w := range i.HasCommitsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasCommitsWith(with...))
	}
	if i.HasCveRules != nil {
		p := repo.HasCveRules()
		if !*i.HasCveRules {
			p = repo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCveRulesWith) > 0 {
		with := make([]predicate.CVERule, 0, len(i.HasCveRulesWith))
		for _, w := range i.HasCveRulesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, repo.HasCveRulesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate RepoWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return repo.And(predicates...), nil
	}
}

// TestCaseWhereInput represents a where input for filtering TestCase queries.
type TestCaseWhereInput struct {
	Not *TestCaseWhereInput   `json:"not,omitempty"`
	Or  []*TestCaseWhereInput `json:"or,omitempty"`
	And []*TestCaseWhereInput `json:"and,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "result" field predicates.
	Result    *bool `json:"result,omitempty"`
	ResultNEQ *bool `json:"resultNEQ,omitempty"`

	// "message" field predicates.
	Message             *string  `json:"message,omitempty"`
	MessageNEQ          *string  `json:"messageNEQ,omitempty"`
	MessageIn           []string `json:"messageIn,omitempty"`
	MessageNotIn        []string `json:"messageNotIn,omitempty"`
	MessageGT           *string  `json:"messageGT,omitempty"`
	MessageGTE          *string  `json:"messageGTE,omitempty"`
	MessageLT           *string  `json:"messageLT,omitempty"`
	MessageLTE          *string  `json:"messageLTE,omitempty"`
	MessageContains     *string  `json:"messageContains,omitempty"`
	MessageHasPrefix    *string  `json:"messageHasPrefix,omitempty"`
	MessageHasSuffix    *string  `json:"messageHasSuffix,omitempty"`
	MessageEqualFold    *string  `json:"messageEqualFold,omitempty"`
	MessageContainsFold *string  `json:"messageContainsFold,omitempty"`

	// "elapsed" field predicates.
	Elapsed      *float64  `json:"elapsed,omitempty"`
	ElapsedNEQ   *float64  `json:"elapsedNEQ,omitempty"`
	ElapsedIn    []float64 `json:"elapsedIn,omitempty"`
	ElapsedNotIn []float64 `json:"elapsedNotIn,omitempty"`
	ElapsedGT    *float64  `json:"elapsedGT,omitempty"`
	ElapsedGTE   *float64  `json:"elapsedGTE,omitempty"`
	ElapsedLT    *float64  `json:"elapsedLT,omitempty"`
	ElapsedLTE   *float64  `json:"elapsedLTE,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "run" edge predicates.
	HasRun     *bool                `json:"hasRun,omitempty"`
	HasRunWith []*TestRunWhereInput `json:"hasRunWith,omitempty"`
}

// Filter applies the TestCaseWhereInput filter on the TestCaseQuery builder.
func (i *TestCaseWhereInput) Filter(q *TestCaseQuery) (*TestCaseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering testcases.
// An error is returned if the input is empty or invalid.
func (i *TestCaseWhereInput) P() (predicate.TestCase, error) {
	var predicates []predicate.TestCase
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, testcase.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TestCase, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, testcase.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TestCase, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, testcase.And(and...))
	}
	if i.Name != nil {
		predicates = append(predicates, testcase.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, testcase.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, testcase.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, testcase.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, testcase.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, testcase.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, testcase.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, testcase.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, testcase.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, testcase.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, testcase.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, testcase.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, testcase.NameContainsFold(*i.NameContainsFold))
	}
	if i.Result != nil {
		predicates = append(predicates, testcase.ResultEQ(*i.Result))
	}
	if i.ResultNEQ != nil {
		predicates = append(predicates, testcase.ResultNEQ(*i.ResultNEQ))
	}
	if i.Message != nil {
		predicates = append(predicates, testcase.MessageEQ(*i.Message))
	}
	if i.MessageNEQ != nil {
		predicates = append(predicates, testcase.MessageNEQ(*i.MessageNEQ))
	}
	if len(i.MessageIn) > 0 {
		predicates = append(predicates, testcase.MessageIn(i.MessageIn...))
	}
	if len(i.MessageNotIn) > 0 {
		predicates = append(predicates, testcase.MessageNotIn(i.MessageNotIn...))
	}
	if i.MessageGT != nil {
		predicates = append(predicates, testcase.MessageGT(*i.MessageGT))
	}
	if i.MessageGTE != nil {
		predicates = append(predicates, testcase.MessageGTE(*i.MessageGTE))
	}
	if i.MessageLT != nil {
		predicates = append(predicates, testcase.MessageLT(*i.MessageLT))
	}
	if i.MessageLTE != nil {
		predicates = append(predicates, testcase.MessageLTE(*i.MessageLTE))
	}
	if i.MessageContains != nil {
		predicates = append(predicates, testcase.MessageContains(*i.MessageContains))
	}
	if i.MessageHasPrefix != nil {
		predicates = append(predicates, testcase.MessageHasPrefix(*i.MessageHasPrefix))
	}
	if i.MessageHasSuffix != nil {
		predicates = append(predicates, testcase.MessageHasSuffix(*i.MessageHasSuffix))
	}
	if i.MessageEqualFold != nil {
		predicates = append(predicates, testcase.MessageEqualFold(*i.MessageEqualFold))
	}
	if i.MessageContainsFold != nil {
		predicates = append(predicates, testcase.MessageContainsFold(*i.MessageContainsFold))
	}
	if i.Elapsed != nil {
		predicates = append(predicates, testcase.ElapsedEQ(*i.Elapsed))
	}
	if i.ElapsedNEQ != nil {
		predicates = append(predicates, testcase.ElapsedNEQ(*i.ElapsedNEQ))
	}
	if len(i.ElapsedIn) > 0 {
		predicates = append(predicates, testcase.ElapsedIn(i.ElapsedIn...))
	}
	if len(i.ElapsedNotIn) > 0 {
		predicates = append(predicates, testcase.ElapsedNotIn(i.ElapsedNotIn...))
	}
	if i.ElapsedGT != nil {
		predicates = append(predicates, testcase.ElapsedGT(*i.ElapsedGT))
	}
	if i.ElapsedGTE != nil {
		predicates = append(predicates, testcase.ElapsedGTE(*i.ElapsedGTE))
	}
	if i.ElapsedLT != nil {
		predicates = append(predicates, testcase.ElapsedLT(*i.ElapsedLT))
	}
	if i.ElapsedLTE != nil {
		predicates = append(predicates, testcase.ElapsedLTE(*i.ElapsedLTE))
	}
	if i.ID != nil {
		predicates = append(predicates, testcase.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, testcase.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, testcase.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, testcase.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, testcase.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, testcase.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, testcase.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, testcase.IDLTE(*i.IDLTE))
	}

	if i.HasRun != nil {
		p := testcase.HasRun()
		if !*i.HasRun {
			p = testcase.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRunWith) > 0 {
		with := make([]predicate.TestRun, 0, len(i.HasRunWith))
		for _, w := range i.HasRunWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testcase.HasRunWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate TestCaseWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return testcase.And(predicates...), nil
	}
}

// TestRunWhereInput represents a where input for filtering TestRun queries.
type TestRunWhereInput struct {
	Not *TestRunWhereInput   `json:"not,omitempty"`
	Or  []*TestRunWhereInput `json:"or,omitempty"`
	And []*TestRunWhereInput `json:"and,omitempty"`

	// "tool" field predicates.
	Tool             *string  `json:"tool,omitempty"`
	ToolNEQ          *string  `json:"toolNEQ,omitempty"`
	ToolIn           []string `json:"toolIn,omitempty"`
	ToolNotIn        []string `json:"toolNotIn,omitempty"`
	ToolGT           *string  `json:"toolGT,omitempty"`
	ToolGTE          *string  `json:"toolGTE,omitempty"`
	ToolLT           *string  `json:"toolLT,omitempty"`
	ToolLTE          *string  `json:"toolLTE,omitempty"`
	ToolContains     *string  `json:"toolContains,omitempty"`
	ToolHasPrefix    *string  `json:"toolHasPrefix,omitempty"`
	ToolHasSuffix    *string  `json:"toolHasSuffix,omitempty"`
	ToolEqualFold    *string  `json:"toolEqualFold,omitempty"`
	ToolContainsFold *string  `json:"toolContainsFold,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "release" edge predicates.
	HasRelease     *bool                `json:"hasRelease,omitempty"`
	HasReleaseWith []*ReleaseWhereInput `json:"hasReleaseWith,omitempty"`

	// "entry" edge predicates.
	HasEntry     *bool                     `json:"hasEntry,omitempty"`
	HasEntryWith []*ReleaseEntryWhereInput `json:"hasEntryWith,omitempty"`

	// "tests" edge predicates.
	HasTests     *bool                 `json:"hasTests,omitempty"`
	HasTestsWith []*TestCaseWhereInput `json:"hasTestsWith,omitempty"`
}

// Filter applies the TestRunWhereInput filter on the TestRunQuery builder.
func (i *TestRunWhereInput) Filter(q *TestRunQuery) (*TestRunQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering testruns.
// An error is returned if the input is empty or invalid.
func (i *TestRunWhereInput) P() (predicate.TestRun, error) {
	var predicates []predicate.TestRun
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, testrun.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TestRun, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, testrun.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TestRun, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, testrun.And(and...))
	}
	if i.Tool != nil {
		predicates = append(predicates, testrun.ToolEQ(*i.Tool))
	}
	if i.ToolNEQ != nil {
		predicates = append(predicates, testrun.ToolNEQ(*i.ToolNEQ))
	}
	if len(i.ToolIn) > 0 {
		predicates = append(predicates, testrun.ToolIn(i.ToolIn...))
	}
	if len(i.ToolNotIn) > 0 {
		predicates = append(predicates, testrun.ToolNotIn(i.ToolNotIn...))
	}
	if i.ToolGT != nil {
		predicates = append(predicates, testrun.ToolGT(*i.ToolGT))
	}
	if i.ToolGTE != nil {
		predicates = append(predicates, testrun.ToolGTE(*i.ToolGTE))
	}
	if i.ToolLT != nil {
		predicates = append(predicates, testrun.ToolLT(*i.ToolLT))
	}
	if i.ToolLTE != nil {
		predicates = append(predicates, testrun.ToolLTE(*i.ToolLTE))
	}
	if i.ToolContains != nil {
		predicates = append(predicates, testrun.ToolContains(*i.ToolContains))
	}
	if i.ToolHasPrefix != nil {
		predicates = append(predicates, testrun.ToolHasPrefix(*i.ToolHasPrefix))
	}
	if i.ToolHasSuffix != nil {
		predicates = append(predicates, testrun.ToolHasSuffix(*i.ToolHasSuffix))
	}
	if i.ToolEqualFold != nil {
		predicates = append(predicates, testrun.ToolEqualFold(*i.ToolEqualFold))
	}
	if i.ToolContainsFold != nil {
		predicates = append(predicates, testrun.ToolContainsFold(*i.ToolContainsFold))
	}
	if i.ID != nil {
		predicates = append(predicates, testrun.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, testrun.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, testrun.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, testrun.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, testrun.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, testrun.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, testrun.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, testrun.IDLTE(*i.IDLTE))
	}

	if i.HasRelease != nil {
		p := testrun.HasRelease()
		if !*i.HasRelease {
			p = testrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReleaseWith) > 0 {
		with := make([]predicate.Release, 0, len(i.HasReleaseWith))
		for _, w := range i.HasReleaseWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testrun.HasReleaseWith(with...))
	}
	if i.HasEntry != nil {
		p := testrun.HasEntry()
		if !*i.HasEntry {
			p = testrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEntryWith) > 0 {
		with := make([]predicate.ReleaseEntry, 0, len(i.HasEntryWith))
		for _, w := range i.HasEntryWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testrun.HasEntryWith(with...))
	}
	if i.HasTests != nil {
		p := testrun.HasTests()
		if !*i.HasTests {
			p = testrun.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTestsWith) > 0 {
		with := make([]predicate.TestCase, 0, len(i.HasTestsWith))
		for _, w := range i.HasTestsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, testrun.HasTestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate TestRunWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return testrun.And(predicates...), nil
	}
}

// VulnerabilityWhereInput represents a where input for filtering Vulnerability queries.
type VulnerabilityWhereInput struct {
	Not *VulnerabilityWhereInput   `json:"not,omitempty"`
	Or  []*VulnerabilityWhereInput `json:"or,omitempty"`
	And []*VulnerabilityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "cve" edge predicates.
	HasCve     *bool            `json:"hasCve,omitempty"`
	HasCveWith []*CVEWhereInput `json:"hasCveWith,omitempty"`
}

// Filter applies the VulnerabilityWhereInput filter on the VulnerabilityQuery builder.
func (i *VulnerabilityWhereInput) Filter(q *VulnerabilityQuery) (*VulnerabilityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering vulnerabilities.
// An error is returned if the input is empty or invalid.
func (i *VulnerabilityWhereInput) P() (predicate.Vulnerability, error) {
	var predicates []predicate.Vulnerability
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, vulnerability.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Vulnerability, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, vulnerability.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Vulnerability, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, vulnerability.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, vulnerability.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vulnerability.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vulnerability.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vulnerability.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vulnerability.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vulnerability.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vulnerability.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vulnerability.IDLTE(*i.IDLTE))
	}

	if i.HasCve != nil {
		p := vulnerability.HasCve()
		if !*i.HasCve {
			p = vulnerability.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCveWith) > 0 {
		with := make([]predicate.CVE, 0, len(i.HasCveWith))
		for _, w := range i.HasCveWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, vulnerability.HasCveWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/valocode/bubbly/ent: empty predicate VulnerabilityWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return vulnerability.And(predicates...), nil
	}
}
