// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/componentuse"
	"github.com/valocode/bubbly/ent/cve"
	"github.com/valocode/bubbly/ent/cverule"
	"github.com/valocode/bubbly/ent/cwe"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licenseuse"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// ArtifactEdge is the edge representation of Artifact.
type ArtifactEdge struct {
	Node   *Artifact `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtifactConnection is the connection containing edges to Artifact.
type ArtifactConnection struct {
	Edges      []*ArtifactEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// ArtifactPaginateOption enables pagination customization.
type ArtifactPaginateOption func(*artifactPager) error

// WithArtifactOrder configures pagination ordering.
func WithArtifactOrder(order *ArtifactOrder) ArtifactPaginateOption {
	if order == nil {
		order = DefaultArtifactOrder
	}
	o := *order
	return func(pager *artifactPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultArtifactOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithArtifactFilter configures pagination filter.
func WithArtifactFilter(filter func(*ArtifactQuery) (*ArtifactQuery, error)) ArtifactPaginateOption {
	return func(pager *artifactPager) error {
		if filter == nil {
			return errors.New("ArtifactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artifactPager struct {
	order  *ArtifactOrder
	filter func(*ArtifactQuery) (*ArtifactQuery, error)
}

func newArtifactPager(opts []ArtifactPaginateOption) (*artifactPager, error) {
	pager := &artifactPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultArtifactOrder
	}
	return pager, nil
}

func (p *artifactPager) applyFilter(query *ArtifactQuery) (*ArtifactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artifactPager) toCursor(a *Artifact) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *artifactPager) applyCursors(query *ArtifactQuery, after, before *Cursor) *ArtifactQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultArtifactOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *artifactPager) applyOrder(query *ArtifactQuery, reverse bool) *ArtifactQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultArtifactOrder.Field {
		query = query.Order(direction.orderFunc(DefaultArtifactOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Artifact.
func (a *ArtifactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ArtifactPaginateOption,
) (*ArtifactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtifactPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &ArtifactConnection{Edges: []*ArtifactEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Artifact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Artifact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Artifact {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ArtifactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ArtifactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ArtifactOrderFieldName orders Artifact by name.
	ArtifactOrderFieldName = &ArtifactOrderField{
		field: artifact.FieldName,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Name,
			}
		},
	}
	// ArtifactOrderFieldSha256 orders Artifact by sha256.
	ArtifactOrderFieldSha256 = &ArtifactOrderField{
		field: artifact.FieldSha256,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Sha256,
			}
		},
	}
	// ArtifactOrderFieldType orders Artifact by type.
	ArtifactOrderFieldType = &ArtifactOrderField{
		field: artifact.FieldType,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Type,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtifactOrderField) String() string {
	var str string
	switch f.field {
	case artifact.FieldName:
		str = "name"
	case artifact.FieldSha256:
		str = "sha256"
	case artifact.FieldType:
		str = "type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtifactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtifactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtifactOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ArtifactOrderFieldName
	case "sha256":
		*f = *ArtifactOrderFieldSha256
	case "type":
		*f = *ArtifactOrderFieldType
	default:
		return fmt.Errorf("%s is not a valid ArtifactOrderField", str)
	}
	return nil
}

// ArtifactOrderField defines the ordering field of Artifact.
type ArtifactOrderField struct {
	field    string
	toCursor func(*Artifact) Cursor
}

// ArtifactOrder defines the ordering of Artifact.
type ArtifactOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtifactOrderField `json:"field"`
}

// DefaultArtifactOrder is the default ordering of Artifact.
var DefaultArtifactOrder = &ArtifactOrder{
	Direction: OrderDirectionAsc,
	Field: &ArtifactOrderField{
		field: artifact.FieldID,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Artifact into ArtifactEdge.
func (a *Artifact) ToEdge(order *ArtifactOrder) *ArtifactEdge {
	if order == nil {
		order = DefaultArtifactOrder
	}
	return &ArtifactEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// CVEEdge is the edge representation of CVE.
type CVEEdge struct {
	Node   *CVE   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// CVEConnection is the connection containing edges to CVE.
type CVEConnection struct {
	Edges      []*CVEEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// CVEPaginateOption enables pagination customization.
type CVEPaginateOption func(*cVEPager) error

// WithCVEOrder configures pagination ordering.
func WithCVEOrder(order *CVEOrder) CVEPaginateOption {
	if order == nil {
		order = DefaultCVEOrder
	}
	o := *order
	return func(pager *cVEPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCVEOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCVEFilter configures pagination filter.
func WithCVEFilter(filter func(*CVEQuery) (*CVEQuery, error)) CVEPaginateOption {
	return func(pager *cVEPager) error {
		if filter == nil {
			return errors.New("CVEQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type cVEPager struct {
	order  *CVEOrder
	filter func(*CVEQuery) (*CVEQuery, error)
}

func newCVEPager(opts []CVEPaginateOption) (*cVEPager, error) {
	pager := &cVEPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCVEOrder
	}
	return pager, nil
}

func (p *cVEPager) applyFilter(query *CVEQuery) (*CVEQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *cVEPager) toCursor(c *CVE) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *cVEPager) applyCursors(query *CVEQuery, after, before *Cursor) *CVEQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCVEOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *cVEPager) applyOrder(query *CVEQuery, reverse bool) *CVEQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCVEOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCVEOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CVE.
func (c *CVEQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CVEPaginateOption,
) (*CVEConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCVEPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CVEConnection{Edges: []*CVEEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CVE
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CVE {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CVE {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CVEEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CVEEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CVEOrderFieldCveID orders CVE by cve_id.
	CVEOrderFieldCveID = &CVEOrderField{
		field: cve.FieldCveID,
		toCursor: func(c *CVE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CveID,
			}
		},
	}
	// CVEOrderFieldDescription orders CVE by description.
	CVEOrderFieldDescription = &CVEOrderField{
		field: cve.FieldDescription,
		toCursor: func(c *CVE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Description,
			}
		},
	}
	// CVEOrderFieldSeverityScore orders CVE by severity_score.
	CVEOrderFieldSeverityScore = &CVEOrderField{
		field: cve.FieldSeverityScore,
		toCursor: func(c *CVE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.SeverityScore,
			}
		},
	}
	// CVEOrderFieldSeverity orders CVE by severity.
	CVEOrderFieldSeverity = &CVEOrderField{
		field: cve.FieldSeverity,
		toCursor: func(c *CVE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Severity,
			}
		},
	}
	// CVEOrderFieldPublishedData orders CVE by published_data.
	CVEOrderFieldPublishedData = &CVEOrderField{
		field: cve.FieldPublishedData,
		toCursor: func(c *CVE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.PublishedData,
			}
		},
	}
	// CVEOrderFieldModifiedData orders CVE by modified_data.
	CVEOrderFieldModifiedData = &CVEOrderField{
		field: cve.FieldModifiedData,
		toCursor: func(c *CVE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.ModifiedData,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CVEOrderField) String() string {
	var str string
	switch f.field {
	case cve.FieldCveID:
		str = "cve_id"
	case cve.FieldDescription:
		str = "description"
	case cve.FieldSeverityScore:
		str = "severity_score"
	case cve.FieldSeverity:
		str = "severity"
	case cve.FieldPublishedData:
		str = "published_data"
	case cve.FieldModifiedData:
		str = "modified_data"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CVEOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CVEOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CVEOrderField %T must be a string", v)
	}
	switch str {
	case "cve_id":
		*f = *CVEOrderFieldCveID
	case "description":
		*f = *CVEOrderFieldDescription
	case "severity_score":
		*f = *CVEOrderFieldSeverityScore
	case "severity":
		*f = *CVEOrderFieldSeverity
	case "published_data":
		*f = *CVEOrderFieldPublishedData
	case "modified_data":
		*f = *CVEOrderFieldModifiedData
	default:
		return fmt.Errorf("%s is not a valid CVEOrderField", str)
	}
	return nil
}

// CVEOrderField defines the ordering field of CVE.
type CVEOrderField struct {
	field    string
	toCursor func(*CVE) Cursor
}

// CVEOrder defines the ordering of CVE.
type CVEOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *CVEOrderField `json:"field"`
}

// DefaultCVEOrder is the default ordering of CVE.
var DefaultCVEOrder = &CVEOrder{
	Direction: OrderDirectionAsc,
	Field: &CVEOrderField{
		field: cve.FieldID,
		toCursor: func(c *CVE) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts CVE into CVEEdge.
func (c *CVE) ToEdge(order *CVEOrder) *CVEEdge {
	if order == nil {
		order = DefaultCVEOrder
	}
	return &CVEEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CVERuleEdge is the edge representation of CVERule.
type CVERuleEdge struct {
	Node   *CVERule `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CVERuleConnection is the connection containing edges to CVERule.
type CVERuleConnection struct {
	Edges      []*CVERuleEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// CVERulePaginateOption enables pagination customization.
type CVERulePaginateOption func(*cVERulePager) error

// WithCVERuleOrder configures pagination ordering.
func WithCVERuleOrder(order *CVERuleOrder) CVERulePaginateOption {
	if order == nil {
		order = DefaultCVERuleOrder
	}
	o := *order
	return func(pager *cVERulePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCVERuleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCVERuleFilter configures pagination filter.
func WithCVERuleFilter(filter func(*CVERuleQuery) (*CVERuleQuery, error)) CVERulePaginateOption {
	return func(pager *cVERulePager) error {
		if filter == nil {
			return errors.New("CVERuleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type cVERulePager struct {
	order  *CVERuleOrder
	filter func(*CVERuleQuery) (*CVERuleQuery, error)
}

func newCVERulePager(opts []CVERulePaginateOption) (*cVERulePager, error) {
	pager := &cVERulePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCVERuleOrder
	}
	return pager, nil
}

func (p *cVERulePager) applyFilter(query *CVERuleQuery) (*CVERuleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *cVERulePager) toCursor(cr *CVERule) Cursor {
	return p.order.Field.toCursor(cr)
}

func (p *cVERulePager) applyCursors(query *CVERuleQuery, after, before *Cursor) *CVERuleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCVERuleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *cVERulePager) applyOrder(query *CVERuleQuery, reverse bool) *CVERuleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCVERuleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCVERuleOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CVERule.
func (cr *CVERuleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CVERulePaginateOption,
) (*CVERuleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCVERulePager(opts)
	if err != nil {
		return nil, err
	}

	if cr, err = pager.applyFilter(cr); err != nil {
		return nil, err
	}

	conn := &CVERuleConnection{Edges: []*CVERuleEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := cr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cr = pager.applyCursors(cr, after, before)
	cr = pager.applyOrder(cr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cr = cr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cr = cr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CVERule
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CVERule {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CVERule {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CVERuleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CVERuleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CVERuleOrderFieldName orders CVERule by name.
	CVERuleOrderFieldName = &CVERuleOrderField{
		field: cverule.FieldName,
		toCursor: func(cr *CVERule) Cursor {
			return Cursor{
				ID:    cr.ID,
				Value: cr.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CVERuleOrderField) String() string {
	var str string
	switch f.field {
	case cverule.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CVERuleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CVERuleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CVERuleOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *CVERuleOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid CVERuleOrderField", str)
	}
	return nil
}

// CVERuleOrderField defines the ordering field of CVERule.
type CVERuleOrderField struct {
	field    string
	toCursor func(*CVERule) Cursor
}

// CVERuleOrder defines the ordering of CVERule.
type CVERuleOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CVERuleOrderField `json:"field"`
}

// DefaultCVERuleOrder is the default ordering of CVERule.
var DefaultCVERuleOrder = &CVERuleOrder{
	Direction: OrderDirectionAsc,
	Field: &CVERuleOrderField{
		field: cverule.FieldID,
		toCursor: func(cr *CVERule) Cursor {
			return Cursor{ID: cr.ID}
		},
	},
}

// ToEdge converts CVERule into CVERuleEdge.
func (cr *CVERule) ToEdge(order *CVERuleOrder) *CVERuleEdge {
	if order == nil {
		order = DefaultCVERuleOrder
	}
	return &CVERuleEdge{
		Node:   cr,
		Cursor: order.Field.toCursor(cr),
	}
}

// CWEEdge is the edge representation of CWE.
type CWEEdge struct {
	Node   *CWE   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// CWEConnection is the connection containing edges to CWE.
type CWEConnection struct {
	Edges      []*CWEEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// CWEPaginateOption enables pagination customization.
type CWEPaginateOption func(*cWEPager) error

// WithCWEOrder configures pagination ordering.
func WithCWEOrder(order *CWEOrder) CWEPaginateOption {
	if order == nil {
		order = DefaultCWEOrder
	}
	o := *order
	return func(pager *cWEPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCWEOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCWEFilter configures pagination filter.
func WithCWEFilter(filter func(*CWEQuery) (*CWEQuery, error)) CWEPaginateOption {
	return func(pager *cWEPager) error {
		if filter == nil {
			return errors.New("CWEQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type cWEPager struct {
	order  *CWEOrder
	filter func(*CWEQuery) (*CWEQuery, error)
}

func newCWEPager(opts []CWEPaginateOption) (*cWEPager, error) {
	pager := &cWEPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCWEOrder
	}
	return pager, nil
}

func (p *cWEPager) applyFilter(query *CWEQuery) (*CWEQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *cWEPager) toCursor(c *CWE) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *cWEPager) applyCursors(query *CWEQuery, after, before *Cursor) *CWEQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCWEOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *cWEPager) applyOrder(query *CWEQuery, reverse bool) *CWEQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCWEOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCWEOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CWE.
func (c *CWEQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CWEPaginateOption,
) (*CWEConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCWEPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CWEConnection{Edges: []*CWEEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CWE
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CWE {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CWE {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CWEEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CWEEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CWEOrderFieldCweID orders CWE by cwe_id.
	CWEOrderFieldCweID = &CWEOrderField{
		field: cwe.FieldCweID,
		toCursor: func(c *CWE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CweID,
			}
		},
	}
	// CWEOrderFieldDescription orders CWE by description.
	CWEOrderFieldDescription = &CWEOrderField{
		field: cwe.FieldDescription,
		toCursor: func(c *CWE) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CWEOrderField) String() string {
	var str string
	switch f.field {
	case cwe.FieldCweID:
		str = "cwe_id"
	case cwe.FieldDescription:
		str = "description"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CWEOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CWEOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CWEOrderField %T must be a string", v)
	}
	switch str {
	case "cwe_id":
		*f = *CWEOrderFieldCweID
	case "description":
		*f = *CWEOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid CWEOrderField", str)
	}
	return nil
}

// CWEOrderField defines the ordering field of CWE.
type CWEOrderField struct {
	field    string
	toCursor func(*CWE) Cursor
}

// CWEOrder defines the ordering of CWE.
type CWEOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *CWEOrderField `json:"field"`
}

// DefaultCWEOrder is the default ordering of CWE.
var DefaultCWEOrder = &CWEOrder{
	Direction: OrderDirectionAsc,
	Field: &CWEOrderField{
		field: cwe.FieldID,
		toCursor: func(c *CWE) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts CWE into CWEEdge.
func (c *CWE) ToEdge(order *CWEOrder) *CWEEdge {
	if order == nil {
		order = DefaultCWEOrder
	}
	return &CWEEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CodeIssueEdge is the edge representation of CodeIssue.
type CodeIssueEdge struct {
	Node   *CodeIssue `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// CodeIssueConnection is the connection containing edges to CodeIssue.
type CodeIssueConnection struct {
	Edges      []*CodeIssueEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// CodeIssuePaginateOption enables pagination customization.
type CodeIssuePaginateOption func(*codeIssuePager) error

// WithCodeIssueOrder configures pagination ordering.
func WithCodeIssueOrder(order *CodeIssueOrder) CodeIssuePaginateOption {
	if order == nil {
		order = DefaultCodeIssueOrder
	}
	o := *order
	return func(pager *codeIssuePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCodeIssueOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCodeIssueFilter configures pagination filter.
func WithCodeIssueFilter(filter func(*CodeIssueQuery) (*CodeIssueQuery, error)) CodeIssuePaginateOption {
	return func(pager *codeIssuePager) error {
		if filter == nil {
			return errors.New("CodeIssueQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type codeIssuePager struct {
	order  *CodeIssueOrder
	filter func(*CodeIssueQuery) (*CodeIssueQuery, error)
}

func newCodeIssuePager(opts []CodeIssuePaginateOption) (*codeIssuePager, error) {
	pager := &codeIssuePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCodeIssueOrder
	}
	return pager, nil
}

func (p *codeIssuePager) applyFilter(query *CodeIssueQuery) (*CodeIssueQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *codeIssuePager) toCursor(ci *CodeIssue) Cursor {
	return p.order.Field.toCursor(ci)
}

func (p *codeIssuePager) applyCursors(query *CodeIssueQuery, after, before *Cursor) *CodeIssueQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCodeIssueOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *codeIssuePager) applyOrder(query *CodeIssueQuery, reverse bool) *CodeIssueQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCodeIssueOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCodeIssueOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CodeIssue.
func (ci *CodeIssueQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CodeIssuePaginateOption,
) (*CodeIssueConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCodeIssuePager(opts)
	if err != nil {
		return nil, err
	}

	if ci, err = pager.applyFilter(ci); err != nil {
		return nil, err
	}

	conn := &CodeIssueConnection{Edges: []*CodeIssueEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ci.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ci.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ci = pager.applyCursors(ci, after, before)
	ci = pager.applyOrder(ci, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ci = ci.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ci = ci.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ci.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CodeIssue
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CodeIssue {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CodeIssue {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CodeIssueEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CodeIssueEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CodeIssueOrderFieldRuleID orders CodeIssue by rule_id.
	CodeIssueOrderFieldRuleID = &CodeIssueOrderField{
		field: codeissue.FieldRuleID,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.RuleID,
			}
		},
	}
	// CodeIssueOrderFieldSeverity orders CodeIssue by severity.
	CodeIssueOrderFieldSeverity = &CodeIssueOrderField{
		field: codeissue.FieldSeverity,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.Severity,
			}
		},
	}
	// CodeIssueOrderFieldType orders CodeIssue by type.
	CodeIssueOrderFieldType = &CodeIssueOrderField{
		field: codeissue.FieldType,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.Type,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CodeIssueOrderField) String() string {
	var str string
	switch f.field {
	case codeissue.FieldRuleID:
		str = "rule_id"
	case codeissue.FieldSeverity:
		str = "severity"
	case codeissue.FieldType:
		str = "type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CodeIssueOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CodeIssueOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CodeIssueOrderField %T must be a string", v)
	}
	switch str {
	case "rule_id":
		*f = *CodeIssueOrderFieldRuleID
	case "severity":
		*f = *CodeIssueOrderFieldSeverity
	case "type":
		*f = *CodeIssueOrderFieldType
	default:
		return fmt.Errorf("%s is not a valid CodeIssueOrderField", str)
	}
	return nil
}

// CodeIssueOrderField defines the ordering field of CodeIssue.
type CodeIssueOrderField struct {
	field    string
	toCursor func(*CodeIssue) Cursor
}

// CodeIssueOrder defines the ordering of CodeIssue.
type CodeIssueOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *CodeIssueOrderField `json:"field"`
}

// DefaultCodeIssueOrder is the default ordering of CodeIssue.
var DefaultCodeIssueOrder = &CodeIssueOrder{
	Direction: OrderDirectionAsc,
	Field: &CodeIssueOrderField{
		field: codeissue.FieldID,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{ID: ci.ID}
		},
	},
}

// ToEdge converts CodeIssue into CodeIssueEdge.
func (ci *CodeIssue) ToEdge(order *CodeIssueOrder) *CodeIssueEdge {
	if order == nil {
		order = DefaultCodeIssueOrder
	}
	return &CodeIssueEdge{
		Node:   ci,
		Cursor: order.Field.toCursor(ci),
	}
}

// CodeScanEdge is the edge representation of CodeScan.
type CodeScanEdge struct {
	Node   *CodeScan `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CodeScanConnection is the connection containing edges to CodeScan.
type CodeScanConnection struct {
	Edges      []*CodeScanEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// CodeScanPaginateOption enables pagination customization.
type CodeScanPaginateOption func(*codeScanPager) error

// WithCodeScanOrder configures pagination ordering.
func WithCodeScanOrder(order *CodeScanOrder) CodeScanPaginateOption {
	if order == nil {
		order = DefaultCodeScanOrder
	}
	o := *order
	return func(pager *codeScanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCodeScanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCodeScanFilter configures pagination filter.
func WithCodeScanFilter(filter func(*CodeScanQuery) (*CodeScanQuery, error)) CodeScanPaginateOption {
	return func(pager *codeScanPager) error {
		if filter == nil {
			return errors.New("CodeScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type codeScanPager struct {
	order  *CodeScanOrder
	filter func(*CodeScanQuery) (*CodeScanQuery, error)
}

func newCodeScanPager(opts []CodeScanPaginateOption) (*codeScanPager, error) {
	pager := &codeScanPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCodeScanOrder
	}
	return pager, nil
}

func (p *codeScanPager) applyFilter(query *CodeScanQuery) (*CodeScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *codeScanPager) toCursor(cs *CodeScan) Cursor {
	return p.order.Field.toCursor(cs)
}

func (p *codeScanPager) applyCursors(query *CodeScanQuery, after, before *Cursor) *CodeScanQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCodeScanOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *codeScanPager) applyOrder(query *CodeScanQuery, reverse bool) *CodeScanQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCodeScanOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCodeScanOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CodeScan.
func (cs *CodeScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CodeScanPaginateOption,
) (*CodeScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCodeScanPager(opts)
	if err != nil {
		return nil, err
	}

	if cs, err = pager.applyFilter(cs); err != nil {
		return nil, err
	}

	conn := &CodeScanConnection{Edges: []*CodeScanEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cs.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := cs.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cs = pager.applyCursors(cs, after, before)
	cs = pager.applyOrder(cs, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cs = cs.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cs = cs.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cs.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CodeScan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CodeScan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CodeScan {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CodeScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CodeScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CodeScanOrderFieldTool orders CodeScan by tool.
	CodeScanOrderFieldTool = &CodeScanOrderField{
		field: codescan.FieldTool,
		toCursor: func(cs *CodeScan) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.Tool,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CodeScanOrderField) String() string {
	var str string
	switch f.field {
	case codescan.FieldTool:
		str = "tool"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CodeScanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CodeScanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CodeScanOrderField %T must be a string", v)
	}
	switch str {
	case "tool":
		*f = *CodeScanOrderFieldTool
	default:
		return fmt.Errorf("%s is not a valid CodeScanOrderField", str)
	}
	return nil
}

// CodeScanOrderField defines the ordering field of CodeScan.
type CodeScanOrderField struct {
	field    string
	toCursor func(*CodeScan) Cursor
}

// CodeScanOrder defines the ordering of CodeScan.
type CodeScanOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CodeScanOrderField `json:"field"`
}

// DefaultCodeScanOrder is the default ordering of CodeScan.
var DefaultCodeScanOrder = &CodeScanOrder{
	Direction: OrderDirectionAsc,
	Field: &CodeScanOrderField{
		field: codescan.FieldID,
		toCursor: func(cs *CodeScan) Cursor {
			return Cursor{ID: cs.ID}
		},
	},
}

// ToEdge converts CodeScan into CodeScanEdge.
func (cs *CodeScan) ToEdge(order *CodeScanOrder) *CodeScanEdge {
	if order == nil {
		order = DefaultCodeScanOrder
	}
	return &CodeScanEdge{
		Node:   cs,
		Cursor: order.Field.toCursor(cs),
	}
}

// ComponentEdge is the edge representation of Component.
type ComponentEdge struct {
	Node   *Component `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ComponentConnection is the connection containing edges to Component.
type ComponentConnection struct {
	Edges      []*ComponentEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// ComponentPaginateOption enables pagination customization.
type ComponentPaginateOption func(*componentPager) error

// WithComponentOrder configures pagination ordering.
func WithComponentOrder(order *ComponentOrder) ComponentPaginateOption {
	if order == nil {
		order = DefaultComponentOrder
	}
	o := *order
	return func(pager *componentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultComponentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithComponentFilter configures pagination filter.
func WithComponentFilter(filter func(*ComponentQuery) (*ComponentQuery, error)) ComponentPaginateOption {
	return func(pager *componentPager) error {
		if filter == nil {
			return errors.New("ComponentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type componentPager struct {
	order  *ComponentOrder
	filter func(*ComponentQuery) (*ComponentQuery, error)
}

func newComponentPager(opts []ComponentPaginateOption) (*componentPager, error) {
	pager := &componentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultComponentOrder
	}
	return pager, nil
}

func (p *componentPager) applyFilter(query *ComponentQuery) (*ComponentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *componentPager) toCursor(c *Component) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *componentPager) applyCursors(query *ComponentQuery, after, before *Cursor) *ComponentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultComponentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *componentPager) applyOrder(query *ComponentQuery, reverse bool) *ComponentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultComponentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultComponentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Component.
func (c *ComponentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ComponentPaginateOption,
) (*ComponentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newComponentPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &ComponentConnection{Edges: []*ComponentEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Component
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Component {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Component {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ComponentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ComponentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ComponentOrderFieldName orders Component by name.
	ComponentOrderFieldName = &ComponentOrderField{
		field: component.FieldName,
		toCursor: func(c *Component) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// ComponentOrderFieldVendor orders Component by vendor.
	ComponentOrderFieldVendor = &ComponentOrderField{
		field: component.FieldVendor,
		toCursor: func(c *Component) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Vendor,
			}
		},
	}
	// ComponentOrderFieldVersion orders Component by version.
	ComponentOrderFieldVersion = &ComponentOrderField{
		field: component.FieldVersion,
		toCursor: func(c *Component) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Version,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ComponentOrderField) String() string {
	var str string
	switch f.field {
	case component.FieldName:
		str = "name"
	case component.FieldVendor:
		str = "vendor"
	case component.FieldVersion:
		str = "version"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ComponentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ComponentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ComponentOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ComponentOrderFieldName
	case "vendor":
		*f = *ComponentOrderFieldVendor
	case "version":
		*f = *ComponentOrderFieldVersion
	default:
		return fmt.Errorf("%s is not a valid ComponentOrderField", str)
	}
	return nil
}

// ComponentOrderField defines the ordering field of Component.
type ComponentOrderField struct {
	field    string
	toCursor func(*Component) Cursor
}

// ComponentOrder defines the ordering of Component.
type ComponentOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ComponentOrderField `json:"field"`
}

// DefaultComponentOrder is the default ordering of Component.
var DefaultComponentOrder = &ComponentOrder{
	Direction: OrderDirectionAsc,
	Field: &ComponentOrderField{
		field: component.FieldID,
		toCursor: func(c *Component) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Component into ComponentEdge.
func (c *Component) ToEdge(order *ComponentOrder) *ComponentEdge {
	if order == nil {
		order = DefaultComponentOrder
	}
	return &ComponentEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ComponentUseEdge is the edge representation of ComponentUse.
type ComponentUseEdge struct {
	Node   *ComponentUse `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ComponentUseConnection is the connection containing edges to ComponentUse.
type ComponentUseConnection struct {
	Edges      []*ComponentUseEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// ComponentUsePaginateOption enables pagination customization.
type ComponentUsePaginateOption func(*componentUsePager) error

// WithComponentUseOrder configures pagination ordering.
func WithComponentUseOrder(order *ComponentUseOrder) ComponentUsePaginateOption {
	if order == nil {
		order = DefaultComponentUseOrder
	}
	o := *order
	return func(pager *componentUsePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultComponentUseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithComponentUseFilter configures pagination filter.
func WithComponentUseFilter(filter func(*ComponentUseQuery) (*ComponentUseQuery, error)) ComponentUsePaginateOption {
	return func(pager *componentUsePager) error {
		if filter == nil {
			return errors.New("ComponentUseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type componentUsePager struct {
	order  *ComponentUseOrder
	filter func(*ComponentUseQuery) (*ComponentUseQuery, error)
}

func newComponentUsePager(opts []ComponentUsePaginateOption) (*componentUsePager, error) {
	pager := &componentUsePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultComponentUseOrder
	}
	return pager, nil
}

func (p *componentUsePager) applyFilter(query *ComponentUseQuery) (*ComponentUseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *componentUsePager) toCursor(cu *ComponentUse) Cursor {
	return p.order.Field.toCursor(cu)
}

func (p *componentUsePager) applyCursors(query *ComponentUseQuery, after, before *Cursor) *ComponentUseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultComponentUseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *componentUsePager) applyOrder(query *ComponentUseQuery, reverse bool) *ComponentUseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultComponentUseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultComponentUseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ComponentUse.
func (cu *ComponentUseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ComponentUsePaginateOption,
) (*ComponentUseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newComponentUsePager(opts)
	if err != nil {
		return nil, err
	}

	if cu, err = pager.applyFilter(cu); err != nil {
		return nil, err
	}

	conn := &ComponentUseConnection{Edges: []*ComponentUseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cu.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := cu.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cu = pager.applyCursors(cu, after, before)
	cu = pager.applyOrder(cu, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cu = cu.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cu = cu.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cu.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ComponentUse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ComponentUse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ComponentUse {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ComponentUseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ComponentUseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ComponentUseOrderField defines the ordering field of ComponentUse.
type ComponentUseOrderField struct {
	field    string
	toCursor func(*ComponentUse) Cursor
}

// ComponentUseOrder defines the ordering of ComponentUse.
type ComponentUseOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ComponentUseOrderField `json:"field"`
}

// DefaultComponentUseOrder is the default ordering of ComponentUse.
var DefaultComponentUseOrder = &ComponentUseOrder{
	Direction: OrderDirectionAsc,
	Field: &ComponentUseOrderField{
		field: componentuse.FieldID,
		toCursor: func(cu *ComponentUse) Cursor {
			return Cursor{ID: cu.ID}
		},
	},
}

// ToEdge converts ComponentUse into ComponentUseEdge.
func (cu *ComponentUse) ToEdge(order *ComponentUseOrder) *ComponentUseEdge {
	if order == nil {
		order = DefaultComponentUseOrder
	}
	return &ComponentUseEdge{
		Node:   cu,
		Cursor: order.Field.toCursor(cu),
	}
}

// GitCommitEdge is the edge representation of GitCommit.
type GitCommitEdge struct {
	Node   *GitCommit `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// GitCommitConnection is the connection containing edges to GitCommit.
type GitCommitConnection struct {
	Edges      []*GitCommitEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// GitCommitPaginateOption enables pagination customization.
type GitCommitPaginateOption func(*gitCommitPager) error

// WithGitCommitOrder configures pagination ordering.
func WithGitCommitOrder(order *GitCommitOrder) GitCommitPaginateOption {
	if order == nil {
		order = DefaultGitCommitOrder
	}
	o := *order
	return func(pager *gitCommitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGitCommitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGitCommitFilter configures pagination filter.
func WithGitCommitFilter(filter func(*GitCommitQuery) (*GitCommitQuery, error)) GitCommitPaginateOption {
	return func(pager *gitCommitPager) error {
		if filter == nil {
			return errors.New("GitCommitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gitCommitPager struct {
	order  *GitCommitOrder
	filter func(*GitCommitQuery) (*GitCommitQuery, error)
}

func newGitCommitPager(opts []GitCommitPaginateOption) (*gitCommitPager, error) {
	pager := &gitCommitPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGitCommitOrder
	}
	return pager, nil
}

func (p *gitCommitPager) applyFilter(query *GitCommitQuery) (*GitCommitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gitCommitPager) toCursor(gc *GitCommit) Cursor {
	return p.order.Field.toCursor(gc)
}

func (p *gitCommitPager) applyCursors(query *GitCommitQuery, after, before *Cursor) *GitCommitQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultGitCommitOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *gitCommitPager) applyOrder(query *GitCommitQuery, reverse bool) *GitCommitQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultGitCommitOrder.Field {
		query = query.Order(direction.orderFunc(DefaultGitCommitOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to GitCommit.
func (gc *GitCommitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GitCommitPaginateOption,
) (*GitCommitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGitCommitPager(opts)
	if err != nil {
		return nil, err
	}

	if gc, err = pager.applyFilter(gc); err != nil {
		return nil, err
	}

	conn := &GitCommitConnection{Edges: []*GitCommitEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := gc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := gc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	gc = pager.applyCursors(gc, after, before)
	gc = pager.applyOrder(gc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		gc = gc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		gc = gc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := gc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *GitCommit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GitCommit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GitCommit {
			return nodes[i]
		}
	}

	conn.Edges = make([]*GitCommitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &GitCommitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// GitCommitOrderFieldHash orders GitCommit by hash.
	GitCommitOrderFieldHash = &GitCommitOrderField{
		field: gitcommit.FieldHash,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Hash,
			}
		},
	}
	// GitCommitOrderFieldBranch orders GitCommit by branch.
	GitCommitOrderFieldBranch = &GitCommitOrderField{
		field: gitcommit.FieldBranch,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Branch,
			}
		},
	}
	// GitCommitOrderFieldTag orders GitCommit by tag.
	GitCommitOrderFieldTag = &GitCommitOrderField{
		field: gitcommit.FieldTag,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Tag,
			}
		},
	}
	// GitCommitOrderFieldTime orders GitCommit by time.
	GitCommitOrderFieldTime = &GitCommitOrderField{
		field: gitcommit.FieldTime,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GitCommitOrderField) String() string {
	var str string
	switch f.field {
	case gitcommit.FieldHash:
		str = "hash"
	case gitcommit.FieldBranch:
		str = "branch"
	case gitcommit.FieldTag:
		str = "tag"
	case gitcommit.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GitCommitOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GitCommitOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GitCommitOrderField %T must be a string", v)
	}
	switch str {
	case "hash":
		*f = *GitCommitOrderFieldHash
	case "branch":
		*f = *GitCommitOrderFieldBranch
	case "tag":
		*f = *GitCommitOrderFieldTag
	case "time":
		*f = *GitCommitOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid GitCommitOrderField", str)
	}
	return nil
}

// GitCommitOrderField defines the ordering field of GitCommit.
type GitCommitOrderField struct {
	field    string
	toCursor func(*GitCommit) Cursor
}

// GitCommitOrder defines the ordering of GitCommit.
type GitCommitOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *GitCommitOrderField `json:"field"`
}

// DefaultGitCommitOrder is the default ordering of GitCommit.
var DefaultGitCommitOrder = &GitCommitOrder{
	Direction: OrderDirectionAsc,
	Field: &GitCommitOrderField{
		field: gitcommit.FieldID,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{ID: gc.ID}
		},
	},
}

// ToEdge converts GitCommit into GitCommitEdge.
func (gc *GitCommit) ToEdge(order *GitCommitOrder) *GitCommitEdge {
	if order == nil {
		order = DefaultGitCommitOrder
	}
	return &GitCommitEdge{
		Node:   gc,
		Cursor: order.Field.toCursor(gc),
	}
}

// LicenseEdge is the edge representation of License.
type LicenseEdge struct {
	Node   *License `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// LicenseConnection is the connection containing edges to License.
type LicenseConnection struct {
	Edges      []*LicenseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// LicensePaginateOption enables pagination customization.
type LicensePaginateOption func(*licensePager) error

// WithLicenseOrder configures pagination ordering.
func WithLicenseOrder(order *LicenseOrder) LicensePaginateOption {
	if order == nil {
		order = DefaultLicenseOrder
	}
	o := *order
	return func(pager *licensePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLicenseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLicenseFilter configures pagination filter.
func WithLicenseFilter(filter func(*LicenseQuery) (*LicenseQuery, error)) LicensePaginateOption {
	return func(pager *licensePager) error {
		if filter == nil {
			return errors.New("LicenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type licensePager struct {
	order  *LicenseOrder
	filter func(*LicenseQuery) (*LicenseQuery, error)
}

func newLicensePager(opts []LicensePaginateOption) (*licensePager, error) {
	pager := &licensePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLicenseOrder
	}
	return pager, nil
}

func (p *licensePager) applyFilter(query *LicenseQuery) (*LicenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *licensePager) toCursor(l *License) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *licensePager) applyCursors(query *LicenseQuery, after, before *Cursor) *LicenseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLicenseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *licensePager) applyOrder(query *LicenseQuery, reverse bool) *LicenseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLicenseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLicenseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to License.
func (l *LicenseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LicensePaginateOption,
) (*LicenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLicensePager(opts)
	if err != nil {
		return nil, err
	}

	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}

	conn := &LicenseConnection{Edges: []*LicenseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := l.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := l.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	l = pager.applyCursors(l, after, before)
	l = pager.applyOrder(l, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		l = l.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		l = l.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := l.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *License
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *License {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *License {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LicenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LicenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// LicenseOrderFieldSpdxID orders License by spdx_id.
	LicenseOrderFieldSpdxID = &LicenseOrderField{
		field: license.FieldSpdxID,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.SpdxID,
			}
		},
	}
	// LicenseOrderFieldName orders License by name.
	LicenseOrderFieldName = &LicenseOrderField{
		field: license.FieldName,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LicenseOrderField) String() string {
	var str string
	switch f.field {
	case license.FieldSpdxID:
		str = "spdx_id"
	case license.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LicenseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LicenseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LicenseOrderField %T must be a string", v)
	}
	switch str {
	case "spdx_id":
		*f = *LicenseOrderFieldSpdxID
	case "name":
		*f = *LicenseOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid LicenseOrderField", str)
	}
	return nil
}

// LicenseOrderField defines the ordering field of License.
type LicenseOrderField struct {
	field    string
	toCursor func(*License) Cursor
}

// LicenseOrder defines the ordering of License.
type LicenseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *LicenseOrderField `json:"field"`
}

// DefaultLicenseOrder is the default ordering of License.
var DefaultLicenseOrder = &LicenseOrder{
	Direction: OrderDirectionAsc,
	Field: &LicenseOrderField{
		field: license.FieldID,
		toCursor: func(l *License) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts License into LicenseEdge.
func (l *License) ToEdge(order *LicenseOrder) *LicenseEdge {
	if order == nil {
		order = DefaultLicenseOrder
	}
	return &LicenseEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// LicenseUseEdge is the edge representation of LicenseUse.
type LicenseUseEdge struct {
	Node   *LicenseUse `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// LicenseUseConnection is the connection containing edges to LicenseUse.
type LicenseUseConnection struct {
	Edges      []*LicenseUseEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// LicenseUsePaginateOption enables pagination customization.
type LicenseUsePaginateOption func(*licenseUsePager) error

// WithLicenseUseOrder configures pagination ordering.
func WithLicenseUseOrder(order *LicenseUseOrder) LicenseUsePaginateOption {
	if order == nil {
		order = DefaultLicenseUseOrder
	}
	o := *order
	return func(pager *licenseUsePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLicenseUseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLicenseUseFilter configures pagination filter.
func WithLicenseUseFilter(filter func(*LicenseUseQuery) (*LicenseUseQuery, error)) LicenseUsePaginateOption {
	return func(pager *licenseUsePager) error {
		if filter == nil {
			return errors.New("LicenseUseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type licenseUsePager struct {
	order  *LicenseUseOrder
	filter func(*LicenseUseQuery) (*LicenseUseQuery, error)
}

func newLicenseUsePager(opts []LicenseUsePaginateOption) (*licenseUsePager, error) {
	pager := &licenseUsePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLicenseUseOrder
	}
	return pager, nil
}

func (p *licenseUsePager) applyFilter(query *LicenseUseQuery) (*LicenseUseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *licenseUsePager) toCursor(lu *LicenseUse) Cursor {
	return p.order.Field.toCursor(lu)
}

func (p *licenseUsePager) applyCursors(query *LicenseUseQuery, after, before *Cursor) *LicenseUseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLicenseUseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *licenseUsePager) applyOrder(query *LicenseUseQuery, reverse bool) *LicenseUseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLicenseUseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLicenseUseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to LicenseUse.
func (lu *LicenseUseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LicenseUsePaginateOption,
) (*LicenseUseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLicenseUsePager(opts)
	if err != nil {
		return nil, err
	}

	if lu, err = pager.applyFilter(lu); err != nil {
		return nil, err
	}

	conn := &LicenseUseConnection{Edges: []*LicenseUseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := lu.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := lu.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	lu = pager.applyCursors(lu, after, before)
	lu = pager.applyOrder(lu, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		lu = lu.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		lu = lu.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := lu.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *LicenseUse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LicenseUse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LicenseUse {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LicenseUseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LicenseUseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// LicenseUseOrderField defines the ordering field of LicenseUse.
type LicenseUseOrderField struct {
	field    string
	toCursor func(*LicenseUse) Cursor
}

// LicenseUseOrder defines the ordering of LicenseUse.
type LicenseUseOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *LicenseUseOrderField `json:"field"`
}

// DefaultLicenseUseOrder is the default ordering of LicenseUse.
var DefaultLicenseUseOrder = &LicenseUseOrder{
	Direction: OrderDirectionAsc,
	Field: &LicenseUseOrderField{
		field: licenseuse.FieldID,
		toCursor: func(lu *LicenseUse) Cursor {
			return Cursor{ID: lu.ID}
		},
	},
}

// ToEdge converts LicenseUse into LicenseUseEdge.
func (lu *LicenseUse) ToEdge(order *LicenseUseOrder) *LicenseUseEdge {
	if order == nil {
		order = DefaultLicenseUseOrder
	}
	return &LicenseUseEdge{
		Node:   lu,
		Cursor: order.Field.toCursor(lu),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order *ProjectOrder) ProjectPaginateOption {
	if order == nil {
		order = DefaultProjectOrder
	}
	o := *order
	return func(pager *projectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	order  *ProjectOrder
	filter func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption) (*projectPager, error) {
	pager := &projectPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectOrder
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) *ProjectQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProjectOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *projectPager) applyOrder(query *ProjectQuery, reverse bool) *ProjectQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProjectOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProjectOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts)
	if err != nil {
		return nil, err
	}

	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}

	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pr = pr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ProjectOrderFieldName orders Project by name.
	ProjectOrderFieldName = &ProjectOrderField{
		field: project.FieldName,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectOrderField) String() string {
	var str string
	switch f.field {
	case project.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ProjectOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	field    string
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: OrderDirectionAsc,
	Field: &ProjectOrderField{
		field: project.FieldID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (pr *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ReleaseEdge is the edge representation of Release.
type ReleaseEdge struct {
	Node   *Release `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ReleaseConnection is the connection containing edges to Release.
type ReleaseConnection struct {
	Edges      []*ReleaseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ReleasePaginateOption enables pagination customization.
type ReleasePaginateOption func(*releasePager) error

// WithReleaseOrder configures pagination ordering.
func WithReleaseOrder(order *ReleaseOrder) ReleasePaginateOption {
	if order == nil {
		order = DefaultReleaseOrder
	}
	o := *order
	return func(pager *releasePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseFilter configures pagination filter.
func WithReleaseFilter(filter func(*ReleaseQuery) (*ReleaseQuery, error)) ReleasePaginateOption {
	return func(pager *releasePager) error {
		if filter == nil {
			return errors.New("ReleaseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releasePager struct {
	order  *ReleaseOrder
	filter func(*ReleaseQuery) (*ReleaseQuery, error)
}

func newReleasePager(opts []ReleasePaginateOption) (*releasePager, error) {
	pager := &releasePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseOrder
	}
	return pager, nil
}

func (p *releasePager) applyFilter(query *ReleaseQuery) (*ReleaseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releasePager) toCursor(r *Release) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *releasePager) applyCursors(query *ReleaseQuery, after, before *Cursor) *ReleaseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releasePager) applyOrder(query *ReleaseQuery, reverse bool) *ReleaseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Release.
func (r *ReleaseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleasePaginateOption,
) (*ReleaseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleasePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &ReleaseConnection{Edges: []*ReleaseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Release
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Release {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Release {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ReleaseOrderFieldName orders Release by name.
	ReleaseOrderFieldName = &ReleaseOrderField{
		field: release.FieldName,
		toCursor: func(r *Release) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Name,
			}
		},
	}
	// ReleaseOrderFieldVersion orders Release by version.
	ReleaseOrderFieldVersion = &ReleaseOrderField{
		field: release.FieldVersion,
		toCursor: func(r *Release) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Version,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReleaseOrderField) String() string {
	var str string
	switch f.field {
	case release.FieldName:
		str = "name"
	case release.FieldVersion:
		str = "version"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReleaseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReleaseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReleaseOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ReleaseOrderFieldName
	case "version":
		*f = *ReleaseOrderFieldVersion
	default:
		return fmt.Errorf("%s is not a valid ReleaseOrderField", str)
	}
	return nil
}

// ReleaseOrderField defines the ordering field of Release.
type ReleaseOrderField struct {
	field    string
	toCursor func(*Release) Cursor
}

// ReleaseOrder defines the ordering of Release.
type ReleaseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ReleaseOrderField `json:"field"`
}

// DefaultReleaseOrder is the default ordering of Release.
var DefaultReleaseOrder = &ReleaseOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseOrderField{
		field: release.FieldID,
		toCursor: func(r *Release) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Release into ReleaseEdge.
func (r *Release) ToEdge(order *ReleaseOrder) *ReleaseEdge {
	if order == nil {
		order = DefaultReleaseOrder
	}
	return &ReleaseEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// ReleaseEntryEdge is the edge representation of ReleaseEntry.
type ReleaseEntryEdge struct {
	Node   *ReleaseEntry `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ReleaseEntryConnection is the connection containing edges to ReleaseEntry.
type ReleaseEntryConnection struct {
	Edges      []*ReleaseEntryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// ReleaseEntryPaginateOption enables pagination customization.
type ReleaseEntryPaginateOption func(*releaseEntryPager) error

// WithReleaseEntryOrder configures pagination ordering.
func WithReleaseEntryOrder(order *ReleaseEntryOrder) ReleaseEntryPaginateOption {
	if order == nil {
		order = DefaultReleaseEntryOrder
	}
	o := *order
	return func(pager *releaseEntryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseEntryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseEntryFilter configures pagination filter.
func WithReleaseEntryFilter(filter func(*ReleaseEntryQuery) (*ReleaseEntryQuery, error)) ReleaseEntryPaginateOption {
	return func(pager *releaseEntryPager) error {
		if filter == nil {
			return errors.New("ReleaseEntryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releaseEntryPager struct {
	order  *ReleaseEntryOrder
	filter func(*ReleaseEntryQuery) (*ReleaseEntryQuery, error)
}

func newReleaseEntryPager(opts []ReleaseEntryPaginateOption) (*releaseEntryPager, error) {
	pager := &releaseEntryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseEntryOrder
	}
	return pager, nil
}

func (p *releaseEntryPager) applyFilter(query *ReleaseEntryQuery) (*ReleaseEntryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releaseEntryPager) toCursor(re *ReleaseEntry) Cursor {
	return p.order.Field.toCursor(re)
}

func (p *releaseEntryPager) applyCursors(query *ReleaseEntryQuery, after, before *Cursor) *ReleaseEntryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseEntryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releaseEntryPager) applyOrder(query *ReleaseEntryQuery, reverse bool) *ReleaseEntryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseEntryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseEntryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReleaseEntry.
func (re *ReleaseEntryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleaseEntryPaginateOption,
) (*ReleaseEntryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleaseEntryPager(opts)
	if err != nil {
		return nil, err
	}

	if re, err = pager.applyFilter(re); err != nil {
		return nil, err
	}

	conn := &ReleaseEntryConnection{Edges: []*ReleaseEntryEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := re.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := re.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	re = pager.applyCursors(re, after, before)
	re = pager.applyOrder(re, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		re = re.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		re = re.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := re.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReleaseEntry
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReleaseEntry {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReleaseEntry {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseEntryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseEntryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ReleaseEntryOrderFieldType orders ReleaseEntry by type.
	ReleaseEntryOrderFieldType = &ReleaseEntryOrderField{
		field: releaseentry.FieldType,
		toCursor: func(re *ReleaseEntry) Cursor {
			return Cursor{
				ID:    re.ID,
				Value: re.Type,
			}
		},
	}
	// ReleaseEntryOrderFieldTime orders ReleaseEntry by time.
	ReleaseEntryOrderFieldTime = &ReleaseEntryOrderField{
		field: releaseentry.FieldTime,
		toCursor: func(re *ReleaseEntry) Cursor {
			return Cursor{
				ID:    re.ID,
				Value: re.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReleaseEntryOrderField) String() string {
	var str string
	switch f.field {
	case releaseentry.FieldType:
		str = "type"
	case releaseentry.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReleaseEntryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReleaseEntryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReleaseEntryOrderField %T must be a string", v)
	}
	switch str {
	case "type":
		*f = *ReleaseEntryOrderFieldType
	case "time":
		*f = *ReleaseEntryOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid ReleaseEntryOrderField", str)
	}
	return nil
}

// ReleaseEntryOrderField defines the ordering field of ReleaseEntry.
type ReleaseEntryOrderField struct {
	field    string
	toCursor func(*ReleaseEntry) Cursor
}

// ReleaseEntryOrder defines the ordering of ReleaseEntry.
type ReleaseEntryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ReleaseEntryOrderField `json:"field"`
}

// DefaultReleaseEntryOrder is the default ordering of ReleaseEntry.
var DefaultReleaseEntryOrder = &ReleaseEntryOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseEntryOrderField{
		field: releaseentry.FieldID,
		toCursor: func(re *ReleaseEntry) Cursor {
			return Cursor{ID: re.ID}
		},
	},
}

// ToEdge converts ReleaseEntry into ReleaseEntryEdge.
func (re *ReleaseEntry) ToEdge(order *ReleaseEntryOrder) *ReleaseEntryEdge {
	if order == nil {
		order = DefaultReleaseEntryOrder
	}
	return &ReleaseEntryEdge{
		Node:   re,
		Cursor: order.Field.toCursor(re),
	}
}

// RepoEdge is the edge representation of Repo.
type RepoEdge struct {
	Node   *Repo  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RepoConnection is the connection containing edges to Repo.
type RepoConnection struct {
	Edges      []*RepoEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// RepoPaginateOption enables pagination customization.
type RepoPaginateOption func(*repoPager) error

// WithRepoOrder configures pagination ordering.
func WithRepoOrder(order *RepoOrder) RepoPaginateOption {
	if order == nil {
		order = DefaultRepoOrder
	}
	o := *order
	return func(pager *repoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRepoOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRepoFilter configures pagination filter.
func WithRepoFilter(filter func(*RepoQuery) (*RepoQuery, error)) RepoPaginateOption {
	return func(pager *repoPager) error {
		if filter == nil {
			return errors.New("RepoQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type repoPager struct {
	order  *RepoOrder
	filter func(*RepoQuery) (*RepoQuery, error)
}

func newRepoPager(opts []RepoPaginateOption) (*repoPager, error) {
	pager := &repoPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRepoOrder
	}
	return pager, nil
}

func (p *repoPager) applyFilter(query *RepoQuery) (*RepoQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *repoPager) toCursor(r *Repo) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *repoPager) applyCursors(query *RepoQuery, after, before *Cursor) *RepoQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRepoOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *repoPager) applyOrder(query *RepoQuery, reverse bool) *RepoQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRepoOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRepoOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Repo.
func (r *RepoQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RepoPaginateOption,
) (*RepoConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRepoPager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RepoConnection{Edges: []*RepoEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Repo
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Repo {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Repo {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RepoEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RepoEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RepoOrderFieldName orders Repo by name.
	RepoOrderFieldName = &RepoOrderField{
		field: repo.FieldName,
		toCursor: func(r *Repo) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RepoOrderField) String() string {
	var str string
	switch f.field {
	case repo.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RepoOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RepoOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RepoOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *RepoOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid RepoOrderField", str)
	}
	return nil
}

// RepoOrderField defines the ordering field of Repo.
type RepoOrderField struct {
	field    string
	toCursor func(*Repo) Cursor
}

// RepoOrder defines the ordering of Repo.
type RepoOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RepoOrderField `json:"field"`
}

// DefaultRepoOrder is the default ordering of Repo.
var DefaultRepoOrder = &RepoOrder{
	Direction: OrderDirectionAsc,
	Field: &RepoOrderField{
		field: repo.FieldID,
		toCursor: func(r *Repo) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Repo into RepoEdge.
func (r *Repo) ToEdge(order *RepoOrder) *RepoEdge {
	if order == nil {
		order = DefaultRepoOrder
	}
	return &RepoEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// TestCaseEdge is the edge representation of TestCase.
type TestCaseEdge struct {
	Node   *TestCase `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TestCaseConnection is the connection containing edges to TestCase.
type TestCaseConnection struct {
	Edges      []*TestCaseEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// TestCasePaginateOption enables pagination customization.
type TestCasePaginateOption func(*testCasePager) error

// WithTestCaseOrder configures pagination ordering.
func WithTestCaseOrder(order *TestCaseOrder) TestCasePaginateOption {
	if order == nil {
		order = DefaultTestCaseOrder
	}
	o := *order
	return func(pager *testCasePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTestCaseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTestCaseFilter configures pagination filter.
func WithTestCaseFilter(filter func(*TestCaseQuery) (*TestCaseQuery, error)) TestCasePaginateOption {
	return func(pager *testCasePager) error {
		if filter == nil {
			return errors.New("TestCaseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type testCasePager struct {
	order  *TestCaseOrder
	filter func(*TestCaseQuery) (*TestCaseQuery, error)
}

func newTestCasePager(opts []TestCasePaginateOption) (*testCasePager, error) {
	pager := &testCasePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTestCaseOrder
	}
	return pager, nil
}

func (p *testCasePager) applyFilter(query *TestCaseQuery) (*TestCaseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *testCasePager) toCursor(tc *TestCase) Cursor {
	return p.order.Field.toCursor(tc)
}

func (p *testCasePager) applyCursors(query *TestCaseQuery, after, before *Cursor) *TestCaseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTestCaseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *testCasePager) applyOrder(query *TestCaseQuery, reverse bool) *TestCaseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTestCaseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTestCaseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to TestCase.
func (tc *TestCaseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TestCasePaginateOption,
) (*TestCaseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTestCasePager(opts)
	if err != nil {
		return nil, err
	}

	if tc, err = pager.applyFilter(tc); err != nil {
		return nil, err
	}

	conn := &TestCaseConnection{Edges: []*TestCaseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := tc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := tc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	tc = pager.applyCursors(tc, after, before)
	tc = pager.applyOrder(tc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		tc = tc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		tc = tc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := tc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *TestCase
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TestCase {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TestCase {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TestCaseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TestCaseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TestCaseOrderFieldName orders TestCase by name.
	TestCaseOrderFieldName = &TestCaseOrderField{
		field: testcase.FieldName,
		toCursor: func(tc *TestCase) Cursor {
			return Cursor{
				ID:    tc.ID,
				Value: tc.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TestCaseOrderField) String() string {
	var str string
	switch f.field {
	case testcase.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TestCaseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TestCaseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TestCaseOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *TestCaseOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TestCaseOrderField", str)
	}
	return nil
}

// TestCaseOrderField defines the ordering field of TestCase.
type TestCaseOrderField struct {
	field    string
	toCursor func(*TestCase) Cursor
}

// TestCaseOrder defines the ordering of TestCase.
type TestCaseOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TestCaseOrderField `json:"field"`
}

// DefaultTestCaseOrder is the default ordering of TestCase.
var DefaultTestCaseOrder = &TestCaseOrder{
	Direction: OrderDirectionAsc,
	Field: &TestCaseOrderField{
		field: testcase.FieldID,
		toCursor: func(tc *TestCase) Cursor {
			return Cursor{ID: tc.ID}
		},
	},
}

// ToEdge converts TestCase into TestCaseEdge.
func (tc *TestCase) ToEdge(order *TestCaseOrder) *TestCaseEdge {
	if order == nil {
		order = DefaultTestCaseOrder
	}
	return &TestCaseEdge{
		Node:   tc,
		Cursor: order.Field.toCursor(tc),
	}
}

// TestRunEdge is the edge representation of TestRun.
type TestRunEdge struct {
	Node   *TestRun `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// TestRunConnection is the connection containing edges to TestRun.
type TestRunConnection struct {
	Edges      []*TestRunEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// TestRunPaginateOption enables pagination customization.
type TestRunPaginateOption func(*testRunPager) error

// WithTestRunOrder configures pagination ordering.
func WithTestRunOrder(order *TestRunOrder) TestRunPaginateOption {
	if order == nil {
		order = DefaultTestRunOrder
	}
	o := *order
	return func(pager *testRunPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTestRunOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTestRunFilter configures pagination filter.
func WithTestRunFilter(filter func(*TestRunQuery) (*TestRunQuery, error)) TestRunPaginateOption {
	return func(pager *testRunPager) error {
		if filter == nil {
			return errors.New("TestRunQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type testRunPager struct {
	order  *TestRunOrder
	filter func(*TestRunQuery) (*TestRunQuery, error)
}

func newTestRunPager(opts []TestRunPaginateOption) (*testRunPager, error) {
	pager := &testRunPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTestRunOrder
	}
	return pager, nil
}

func (p *testRunPager) applyFilter(query *TestRunQuery) (*TestRunQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *testRunPager) toCursor(tr *TestRun) Cursor {
	return p.order.Field.toCursor(tr)
}

func (p *testRunPager) applyCursors(query *TestRunQuery, after, before *Cursor) *TestRunQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTestRunOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *testRunPager) applyOrder(query *TestRunQuery, reverse bool) *TestRunQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTestRunOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTestRunOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to TestRun.
func (tr *TestRunQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TestRunPaginateOption,
) (*TestRunConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTestRunPager(opts)
	if err != nil {
		return nil, err
	}

	if tr, err = pager.applyFilter(tr); err != nil {
		return nil, err
	}

	conn := &TestRunConnection{Edges: []*TestRunEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := tr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := tr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	tr = pager.applyCursors(tr, after, before)
	tr = pager.applyOrder(tr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		tr = tr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		tr = tr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := tr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *TestRun
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TestRun {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TestRun {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TestRunEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TestRunEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TestRunOrderFieldTool orders TestRun by tool.
	TestRunOrderFieldTool = &TestRunOrderField{
		field: testrun.FieldTool,
		toCursor: func(tr *TestRun) Cursor {
			return Cursor{
				ID:    tr.ID,
				Value: tr.Tool,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TestRunOrderField) String() string {
	var str string
	switch f.field {
	case testrun.FieldTool:
		str = "tool"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TestRunOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TestRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TestRunOrderField %T must be a string", v)
	}
	switch str {
	case "tool":
		*f = *TestRunOrderFieldTool
	default:
		return fmt.Errorf("%s is not a valid TestRunOrderField", str)
	}
	return nil
}

// TestRunOrderField defines the ordering field of TestRun.
type TestRunOrderField struct {
	field    string
	toCursor func(*TestRun) Cursor
}

// TestRunOrder defines the ordering of TestRun.
type TestRunOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *TestRunOrderField `json:"field"`
}

// DefaultTestRunOrder is the default ordering of TestRun.
var DefaultTestRunOrder = &TestRunOrder{
	Direction: OrderDirectionAsc,
	Field: &TestRunOrderField{
		field: testrun.FieldID,
		toCursor: func(tr *TestRun) Cursor {
			return Cursor{ID: tr.ID}
		},
	},
}

// ToEdge converts TestRun into TestRunEdge.
func (tr *TestRun) ToEdge(order *TestRunOrder) *TestRunEdge {
	if order == nil {
		order = DefaultTestRunOrder
	}
	return &TestRunEdge{
		Node:   tr,
		Cursor: order.Field.toCursor(tr),
	}
}

// VulnerabilityEdge is the edge representation of Vulnerability.
type VulnerabilityEdge struct {
	Node   *Vulnerability `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// VulnerabilityConnection is the connection containing edges to Vulnerability.
type VulnerabilityConnection struct {
	Edges      []*VulnerabilityEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// VulnerabilityPaginateOption enables pagination customization.
type VulnerabilityPaginateOption func(*vulnerabilityPager) error

// WithVulnerabilityOrder configures pagination ordering.
func WithVulnerabilityOrder(order *VulnerabilityOrder) VulnerabilityPaginateOption {
	if order == nil {
		order = DefaultVulnerabilityOrder
	}
	o := *order
	return func(pager *vulnerabilityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVulnerabilityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVulnerabilityFilter configures pagination filter.
func WithVulnerabilityFilter(filter func(*VulnerabilityQuery) (*VulnerabilityQuery, error)) VulnerabilityPaginateOption {
	return func(pager *vulnerabilityPager) error {
		if filter == nil {
			return errors.New("VulnerabilityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vulnerabilityPager struct {
	order  *VulnerabilityOrder
	filter func(*VulnerabilityQuery) (*VulnerabilityQuery, error)
}

func newVulnerabilityPager(opts []VulnerabilityPaginateOption) (*vulnerabilityPager, error) {
	pager := &vulnerabilityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVulnerabilityOrder
	}
	return pager, nil
}

func (p *vulnerabilityPager) applyFilter(query *VulnerabilityQuery) (*VulnerabilityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vulnerabilityPager) toCursor(v *Vulnerability) Cursor {
	return p.order.Field.toCursor(v)
}

func (p *vulnerabilityPager) applyCursors(query *VulnerabilityQuery, after, before *Cursor) *VulnerabilityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVulnerabilityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vulnerabilityPager) applyOrder(query *VulnerabilityQuery, reverse bool) *VulnerabilityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVulnerabilityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVulnerabilityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Vulnerability.
func (v *VulnerabilityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VulnerabilityPaginateOption,
) (*VulnerabilityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVulnerabilityPager(opts)
	if err != nil {
		return nil, err
	}

	if v, err = pager.applyFilter(v); err != nil {
		return nil, err
	}

	conn := &VulnerabilityConnection{Edges: []*VulnerabilityEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := v.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := v.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	v = pager.applyCursors(v, after, before)
	v = pager.applyOrder(v, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		v = v.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		v = v.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := v.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Vulnerability
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vulnerability {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vulnerability {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VulnerabilityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VulnerabilityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// VulnerabilityOrderField defines the ordering field of Vulnerability.
type VulnerabilityOrderField struct {
	field    string
	toCursor func(*Vulnerability) Cursor
}

// VulnerabilityOrder defines the ordering of Vulnerability.
type VulnerabilityOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *VulnerabilityOrderField `json:"field"`
}

// DefaultVulnerabilityOrder is the default ordering of Vulnerability.
var DefaultVulnerabilityOrder = &VulnerabilityOrder{
	Direction: OrderDirectionAsc,
	Field: &VulnerabilityOrderField{
		field: vulnerability.FieldID,
		toCursor: func(v *Vulnerability) Cursor {
			return Cursor{ID: v.ID}
		},
	},
}

// ToEdge converts Vulnerability into VulnerabilityEdge.
func (v *Vulnerability) ToEdge(order *VulnerabilityOrder) *VulnerabilityEdge {
	if order == nil {
		order = DefaultVulnerabilityOrder
	}
	return &VulnerabilityEdge{
		Node:   v,
		Cursor: order.Field.toCursor(v),
	}
}
