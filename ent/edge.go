// Code generated by entc, DO NOT EDIT.

package ent

import "context"

func (a *Artifact) Release(ctx context.Context) (*Release, error) {
	result, err := a.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryRelease().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (a *Artifact) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := a.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *CVE) Components(ctx context.Context) ([]*Component, error) {
	result, err := c.Edges.ComponentsOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryComponents().All(ctx)
	}
	return result, err
}

func (c *CVE) Vulnerabilities(ctx context.Context) ([]*Vulnerability, error) {
	result, err := c.Edges.VulnerabilitiesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryVulnerabilities().All(ctx)
	}
	return result, err
}

func (c *CVE) Rules(ctx context.Context) ([]*CVERule, error) {
	result, err := c.Edges.RulesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryRules().All(ctx)
	}
	return result, err
}

func (cr *CVERule) Cve(ctx context.Context) (*CVE, error) {
	result, err := cr.Edges.CveOrErr()
	if IsNotLoaded(err) {
		result, err = cr.QueryCve().Only(ctx)
	}
	return result, err
}

func (cr *CVERule) Project(ctx context.Context) ([]*Project, error) {
	result, err := cr.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = cr.QueryProject().All(ctx)
	}
	return result, err
}

func (cr *CVERule) Repo(ctx context.Context) ([]*Repo, error) {
	result, err := cr.Edges.RepoOrErr()
	if IsNotLoaded(err) {
		result, err = cr.QueryRepo().All(ctx)
	}
	return result, err
}

func (c *CWE) Issues(ctx context.Context) ([]*CodeIssue, error) {
	result, err := c.Edges.IssuesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryIssues().All(ctx)
	}
	return result, err
}

func (ci *CodeIssue) Cwe(ctx context.Context) ([]*CWE, error) {
	result, err := ci.Edges.CweOrErr()
	if IsNotLoaded(err) {
		result, err = ci.QueryCwe().All(ctx)
	}
	return result, err
}

func (ci *CodeIssue) Scan(ctx context.Context) (*CodeScan, error) {
	result, err := ci.Edges.ScanOrErr()
	if IsNotLoaded(err) {
		result, err = ci.QueryScan().Only(ctx)
	}
	return result, err
}

func (cs *CodeScan) Release(ctx context.Context) (*Release, error) {
	result, err := cs.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryRelease().Only(ctx)
	}
	return result, err
}

func (cs *CodeScan) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := cs.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (cs *CodeScan) Issues(ctx context.Context) ([]*CodeIssue, error) {
	result, err := cs.Edges.IssuesOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryIssues().All(ctx)
	}
	return result, err
}

func (cs *CodeScan) Components(ctx context.Context) ([]*ComponentUse, error) {
	result, err := cs.Edges.ComponentsOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryComponents().All(ctx)
	}
	return result, err
}

func (c *Component) Cves(ctx context.Context) ([]*CVE, error) {
	result, err := c.Edges.CvesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryCves().All(ctx)
	}
	return result, err
}

func (c *Component) Licenses(ctx context.Context) ([]*License, error) {
	result, err := c.Edges.LicensesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryLicenses().All(ctx)
	}
	return result, err
}

func (c *Component) Uses(ctx context.Context) ([]*ComponentUse, error) {
	result, err := c.Edges.UsesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryUses().All(ctx)
	}
	return result, err
}

func (cu *ComponentUse) Release(ctx context.Context) (*Release, error) {
	result, err := cu.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = cu.QueryRelease().Only(ctx)
	}
	return result, err
}

func (cu *ComponentUse) Scans(ctx context.Context) ([]*CodeScan, error) {
	result, err := cu.Edges.ScansOrErr()
	if IsNotLoaded(err) {
		result, err = cu.QueryScans().All(ctx)
	}
	return result, err
}

func (cu *ComponentUse) Component(ctx context.Context) (*Component, error) {
	result, err := cu.Edges.ComponentOrErr()
	if IsNotLoaded(err) {
		result, err = cu.QueryComponent().Only(ctx)
	}
	return result, err
}

func (gc *GitCommit) Repo(ctx context.Context) (*Repo, error) {
	result, err := gc.Edges.RepoOrErr()
	if IsNotLoaded(err) {
		result, err = gc.QueryRepo().Only(ctx)
	}
	return result, err
}

func (gc *GitCommit) Release(ctx context.Context) (*Release, error) {
	result, err := gc.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = gc.QueryRelease().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (l *License) Components(ctx context.Context) ([]*Component, error) {
	result, err := l.Edges.ComponentsOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryComponents().All(ctx)
	}
	return result, err
}

func (l *License) Uses(ctx context.Context) ([]*LicenseUse, error) {
	result, err := l.Edges.UsesOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryUses().All(ctx)
	}
	return result, err
}

func (lu *LicenseUse) License(ctx context.Context) (*License, error) {
	result, err := lu.Edges.LicenseOrErr()
	if IsNotLoaded(err) {
		result, err = lu.QueryLicense().Only(ctx)
	}
	return result, err
}

func (pr *Project) Repos(ctx context.Context) ([]*Repo, error) {
	result, err := pr.Edges.ReposOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryRepos().All(ctx)
	}
	return result, err
}

func (pr *Project) Releases(ctx context.Context) ([]*Release, error) {
	result, err := pr.Edges.ReleasesOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryReleases().All(ctx)
	}
	return result, err
}

func (pr *Project) CveRules(ctx context.Context) ([]*CVERule, error) {
	result, err := pr.Edges.CveRulesOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryCveRules().All(ctx)
	}
	return result, err
}

func (r *Release) Subreleases(ctx context.Context) ([]*Release, error) {
	result, err := r.Edges.SubreleasesOrErr()
	if IsNotLoaded(err) {
		result, err = r.QuerySubreleases().All(ctx)
	}
	return result, err
}

func (r *Release) Dependencies(ctx context.Context) ([]*Release, error) {
	result, err := r.Edges.DependenciesOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryDependencies().All(ctx)
	}
	return result, err
}

func (r *Release) Project(ctx context.Context) (*Project, error) {
	result, err := r.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryProject().Only(ctx)
	}
	return result, err
}

func (r *Release) Commit(ctx context.Context) (*GitCommit, error) {
	result, err := r.Edges.CommitOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCommit().Only(ctx)
	}
	return result, err
}

func (r *Release) Log(ctx context.Context) ([]*ReleaseEntry, error) {
	result, err := r.Edges.LogOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryLog().All(ctx)
	}
	return result, err
}

func (r *Release) Artifacts(ctx context.Context) ([]*Artifact, error) {
	result, err := r.Edges.ArtifactsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryArtifacts().All(ctx)
	}
	return result, err
}

func (r *Release) Components(ctx context.Context) ([]*ComponentUse, error) {
	result, err := r.Edges.ComponentsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryComponents().All(ctx)
	}
	return result, err
}

func (r *Release) CodeScans(ctx context.Context) ([]*CodeScan, error) {
	result, err := r.Edges.CodeScansOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCodeScans().All(ctx)
	}
	return result, err
}

func (r *Release) TestRuns(ctx context.Context) ([]*TestRun, error) {
	result, err := r.Edges.TestRunsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryTestRuns().All(ctx)
	}
	return result, err
}

func (re *ReleaseEntry) Artifact(ctx context.Context) (*Artifact, error) {
	result, err := re.Edges.ArtifactOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryArtifact().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) CodeScan(ctx context.Context) (*CodeScan, error) {
	result, err := re.Edges.CodeScanOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryCodeScan().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) TestRun(ctx context.Context) (*TestRun, error) {
	result, err := re.Edges.TestRunOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryTestRun().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) Release(ctx context.Context) (*Release, error) {
	result, err := re.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryRelease().Only(ctx)
	}
	return result, err
}

func (r *Repo) Project(ctx context.Context) (*Project, error) {
	result, err := r.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryProject().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Repo) Commits(ctx context.Context) ([]*GitCommit, error) {
	result, err := r.Edges.CommitsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCommits().All(ctx)
	}
	return result, err
}

func (r *Repo) CveRules(ctx context.Context) ([]*CVERule, error) {
	result, err := r.Edges.CveRulesOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCveRules().All(ctx)
	}
	return result, err
}

func (tc *TestCase) Run(ctx context.Context) (*TestRun, error) {
	result, err := tc.Edges.RunOrErr()
	if IsNotLoaded(err) {
		result, err = tc.QueryRun().Only(ctx)
	}
	return result, err
}

func (tr *TestRun) Release(ctx context.Context) (*Release, error) {
	result, err := tr.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryRelease().Only(ctx)
	}
	return result, err
}

func (tr *TestRun) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := tr.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (tr *TestRun) Tests(ctx context.Context) ([]*TestCase, error) {
	result, err := tr.Edges.TestsOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryTests().All(ctx)
	}
	return result, err
}

func (v *Vulnerability) Cve(ctx context.Context) (*CVE, error) {
	result, err := v.Edges.CveOrErr()
	if IsNotLoaded(err) {
		result, err = v.QueryCve().Only(ctx)
	}
	return result, err
}
