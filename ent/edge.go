// Code generated by entc, DO NOT EDIT.

package ent

import "context"

func (a *Artifact) Release(ctx context.Context) (*Release, error) {
	result, err := a.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryRelease().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (a *Artifact) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := a.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = a.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *CVE) Found(ctx context.Context) ([]*Vulnerability, error) {
	result, err := c.Edges.FoundOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryFound().All(ctx)
	}
	return result, err
}

func (c *CVE) Rules(ctx context.Context) ([]*CVERule, error) {
	result, err := c.Edges.RulesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryRules().All(ctx)
	}
	return result, err
}

func (cr *CVERule) Cve(ctx context.Context) (*CVE, error) {
	result, err := cr.Edges.CveOrErr()
	if IsNotLoaded(err) {
		result, err = cr.QueryCve().Only(ctx)
	}
	return result, err
}

func (cr *CVERule) Project(ctx context.Context) ([]*Project, error) {
	result, err := cr.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = cr.QueryProject().All(ctx)
	}
	return result, err
}

func (cr *CVERule) Repo(ctx context.Context) ([]*Repo, error) {
	result, err := cr.Edges.RepoOrErr()
	if IsNotLoaded(err) {
		result, err = cr.QueryRepo().All(ctx)
	}
	return result, err
}

func (cs *CVEScan) Release(ctx context.Context) (*Release, error) {
	result, err := cs.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryRelease().Only(ctx)
	}
	return result, err
}

func (cs *CVEScan) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := cs.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (cs *CVEScan) Vulnerabilities(ctx context.Context) ([]*Vulnerability, error) {
	result, err := cs.Edges.VulnerabilitiesOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryVulnerabilities().All(ctx)
	}
	return result, err
}

func (c *CWE) Issues(ctx context.Context) ([]*CodeIssue, error) {
	result, err := c.Edges.IssuesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryIssues().All(ctx)
	}
	return result, err
}

func (ci *CodeIssue) Cwe(ctx context.Context) ([]*CWE, error) {
	result, err := ci.Edges.CweOrErr()
	if IsNotLoaded(err) {
		result, err = ci.QueryCwe().All(ctx)
	}
	return result, err
}

func (ci *CodeIssue) Scan(ctx context.Context) (*CodeScan, error) {
	result, err := ci.Edges.ScanOrErr()
	if IsNotLoaded(err) {
		result, err = ci.QueryScan().Only(ctx)
	}
	return result, err
}

func (cs *CodeScan) Release(ctx context.Context) (*Release, error) {
	result, err := cs.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryRelease().Only(ctx)
	}
	return result, err
}

func (cs *CodeScan) Issues(ctx context.Context) ([]*CodeIssue, error) {
	result, err := cs.Edges.IssuesOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryIssues().All(ctx)
	}
	return result, err
}

func (cs *CodeScan) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := cs.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = cs.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (c *Component) Vulnerabilities(ctx context.Context) ([]*Vulnerability, error) {
	result, err := c.Edges.VulnerabilitiesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryVulnerabilities().All(ctx)
	}
	return result, err
}

func (c *Component) Licenses(ctx context.Context) ([]*License, error) {
	result, err := c.Edges.LicensesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryLicenses().All(ctx)
	}
	return result, err
}

func (c *Component) Release(ctx context.Context) ([]*Release, error) {
	result, err := c.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryRelease().All(ctx)
	}
	return result, err
}

func (gc *GitCommit) Repo(ctx context.Context) (*Repo, error) {
	result, err := gc.Edges.RepoOrErr()
	if IsNotLoaded(err) {
		result, err = gc.QueryRepo().Only(ctx)
	}
	return result, err
}

func (gc *GitCommit) Release(ctx context.Context) (*Release, error) {
	result, err := gc.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = gc.QueryRelease().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (l *License) Components(ctx context.Context) ([]*Component, error) {
	result, err := l.Edges.ComponentsOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryComponents().All(ctx)
	}
	return result, err
}

func (l *License) Usages(ctx context.Context) ([]*LicenseUsage, error) {
	result, err := l.Edges.UsagesOrErr()
	if IsNotLoaded(err) {
		result, err = l.QueryUsages().All(ctx)
	}
	return result, err
}

func (ls *LicenseScan) Release(ctx context.Context) (*Release, error) {
	result, err := ls.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = ls.QueryRelease().Only(ctx)
	}
	return result, err
}

func (ls *LicenseScan) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := ls.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = ls.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (ls *LicenseScan) Licenses(ctx context.Context) ([]*LicenseUsage, error) {
	result, err := ls.Edges.LicensesOrErr()
	if IsNotLoaded(err) {
		result, err = ls.QueryLicenses().All(ctx)
	}
	return result, err
}

func (lu *LicenseUsage) License(ctx context.Context) (*License, error) {
	result, err := lu.Edges.LicenseOrErr()
	if IsNotLoaded(err) {
		result, err = lu.QueryLicense().Only(ctx)
	}
	return result, err
}

func (lu *LicenseUsage) Scan(ctx context.Context) (*LicenseScan, error) {
	result, err := lu.Edges.ScanOrErr()
	if IsNotLoaded(err) {
		result, err = lu.QueryScan().Only(ctx)
	}
	return result, err
}

func (pr *Project) Repos(ctx context.Context) ([]*Repo, error) {
	result, err := pr.Edges.ReposOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryRepos().All(ctx)
	}
	return result, err
}

func (pr *Project) Releases(ctx context.Context) ([]*Release, error) {
	result, err := pr.Edges.ReleasesOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryReleases().All(ctx)
	}
	return result, err
}

func (pr *Project) CveRules(ctx context.Context) ([]*CVERule, error) {
	result, err := pr.Edges.CveRulesOrErr()
	if IsNotLoaded(err) {
		result, err = pr.QueryCveRules().All(ctx)
	}
	return result, err
}

func (r *Release) Subreleases(ctx context.Context) ([]*Release, error) {
	result, err := r.Edges.SubreleasesOrErr()
	if IsNotLoaded(err) {
		result, err = r.QuerySubreleases().All(ctx)
	}
	return result, err
}

func (r *Release) Dependencies(ctx context.Context) ([]*Release, error) {
	result, err := r.Edges.DependenciesOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryDependencies().All(ctx)
	}
	return result, err
}

func (r *Release) Project(ctx context.Context) (*Project, error) {
	result, err := r.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryProject().Only(ctx)
	}
	return result, err
}

func (r *Release) Commit(ctx context.Context) (*GitCommit, error) {
	result, err := r.Edges.CommitOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCommit().Only(ctx)
	}
	return result, err
}

func (r *Release) Artifacts(ctx context.Context) ([]*Artifact, error) {
	result, err := r.Edges.ArtifactsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryArtifacts().All(ctx)
	}
	return result, err
}

func (r *Release) Checks(ctx context.Context) ([]*ReleaseCheck, error) {
	result, err := r.Edges.ChecksOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryChecks().All(ctx)
	}
	return result, err
}

func (r *Release) Log(ctx context.Context) ([]*ReleaseEntry, error) {
	result, err := r.Edges.LogOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryLog().All(ctx)
	}
	return result, err
}

func (r *Release) CodeScans(ctx context.Context) ([]*CodeScan, error) {
	result, err := r.Edges.CodeScansOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCodeScans().All(ctx)
	}
	return result, err
}

func (r *Release) CveScans(ctx context.Context) ([]*CVEScan, error) {
	result, err := r.Edges.CveScansOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCveScans().All(ctx)
	}
	return result, err
}

func (r *Release) LicenseScans(ctx context.Context) ([]*LicenseScan, error) {
	result, err := r.Edges.LicenseScansOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryLicenseScans().All(ctx)
	}
	return result, err
}

func (r *Release) TestRuns(ctx context.Context) ([]*TestRun, error) {
	result, err := r.Edges.TestRunsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryTestRuns().All(ctx)
	}
	return result, err
}

func (r *Release) Components(ctx context.Context) ([]*Component, error) {
	result, err := r.Edges.ComponentsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryComponents().All(ctx)
	}
	return result, err
}

func (rc *ReleaseCheck) Release(ctx context.Context) (*Release, error) {
	result, err := rc.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = rc.QueryRelease().Only(ctx)
	}
	return result, err
}

func (re *ReleaseEntry) Artifact(ctx context.Context) (*Artifact, error) {
	result, err := re.Edges.ArtifactOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryArtifact().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) CodeScan(ctx context.Context) (*CodeScan, error) {
	result, err := re.Edges.CodeScanOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryCodeScan().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) TestRun(ctx context.Context) (*TestRun, error) {
	result, err := re.Edges.TestRunOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryTestRun().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) CveScan(ctx context.Context) (*CVEScan, error) {
	result, err := re.Edges.CveScanOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryCveScan().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) LicenseScan(ctx context.Context) (*LicenseScan, error) {
	result, err := re.Edges.LicenseScanOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryLicenseScan().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (re *ReleaseEntry) Release(ctx context.Context) (*Release, error) {
	result, err := re.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = re.QueryRelease().Only(ctx)
	}
	return result, err
}

func (r *Repo) Project(ctx context.Context) (*Project, error) {
	result, err := r.Edges.ProjectOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryProject().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (r *Repo) Commits(ctx context.Context) ([]*GitCommit, error) {
	result, err := r.Edges.CommitsOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCommits().All(ctx)
	}
	return result, err
}

func (r *Repo) CveRules(ctx context.Context) ([]*CVERule, error) {
	result, err := r.Edges.CveRulesOrErr()
	if IsNotLoaded(err) {
		result, err = r.QueryCveRules().All(ctx)
	}
	return result, err
}

func (tc *TestCase) Run(ctx context.Context) (*TestRun, error) {
	result, err := tc.Edges.RunOrErr()
	if IsNotLoaded(err) {
		result, err = tc.QueryRun().Only(ctx)
	}
	return result, err
}

func (tr *TestRun) Release(ctx context.Context) (*Release, error) {
	result, err := tr.Edges.ReleaseOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryRelease().Only(ctx)
	}
	return result, err
}

func (tr *TestRun) Entry(ctx context.Context) (*ReleaseEntry, error) {
	result, err := tr.Edges.EntryOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryEntry().Only(ctx)
	}
	return result, MaskNotFound(err)
}

func (tr *TestRun) Tests(ctx context.Context) ([]*TestCase, error) {
	result, err := tr.Edges.TestsOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryTests().All(ctx)
	}
	return result, err
}

func (v *Vulnerability) Cve(ctx context.Context) (*CVE, error) {
	result, err := v.Edges.CveOrErr()
	if IsNotLoaded(err) {
		result, err = v.QueryCve().Only(ctx)
	}
	return result, err
}

func (v *Vulnerability) Scan(ctx context.Context) (*CVEScan, error) {
	result, err := v.Edges.ScanOrErr()
	if IsNotLoaded(err) {
		result, err = v.QueryScan().Only(ctx)
	}
	return result, err
}

func (v *Vulnerability) Component(ctx context.Context) (*Component, error) {
	result, err := v.Edges.ComponentOrErr()
	if IsNotLoaded(err) {
		result, err = v.QueryComponent().Only(ctx)
	}
	return result, err
}
