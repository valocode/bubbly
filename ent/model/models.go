// Code generated by entc, DO NOT EDIT.

package model

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/hashicorp/go-multierror"
	"github.com/valocode/bubbly/ent"
	"github.com/valocode/bubbly/ent/adapter"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/vulnerability"
)

type AdapterHCL struct {
	Name        string              `hcl:"name,attr"`
	Tag         string              `hcl:"tag,attr"`
	Type        adapter.Type        `hcl:"type,attr"`
	Operation   *json.RawMessage    `hcl:"operation,optional"`
	ResultsType adapter.ResultsType `hcl:"results_type,attr"`
	Results     []byte              `hcl:"results,attr"`
}

func (a AdapterHCL) Model() AdapterModel {
	return AdapterModel{
		Name:        &a.Name,
		Tag:         &a.Tag,
		Type:        &a.Type,
		Operation:   a.Operation,
		ResultsType: &a.ResultsType,
		Results:     &a.Results,
	}
}

type AdapterModel struct {
	Name        *string              `json:"name,omitempty" hcl:"name,optional"`
	Tag         *string              `json:"tag,omitempty" hcl:"tag,optional"`
	Type        *adapter.Type        `json:"type,omitempty" hcl:"type,optional"`
	Operation   *json.RawMessage     `json:"operation,omitempty" hcl:"operation,optional"`
	ResultsType *adapter.ResultsType `json:"results_type,omitempty" hcl:"results_type,optional"`
	Results     *[]byte              `json:"results,omitempty" hcl:"results,optional"`
	ID          *int                 `json:"id,omitempty" hcl:"id,optional"`
}

func NewAdapterModel() *AdapterModel {
	return &AdapterModel{}
}

func (a *AdapterModel) SetMutatorFields(mutator *ent.AdapterMutation) {
	if a.Name != nil {
		mutator.SetName(*a.Name)
	}
	if a.Tag != nil {
		mutator.SetTag(*a.Tag)
	}
	if a.Type != nil {
		mutator.SetType(*a.Type)
	}
	if a.Operation != nil {
		mutator.SetOperation(*a.Operation)
	}
	if a.ResultsType != nil {
		mutator.SetResultsType(*a.ResultsType)
	}
	if a.Results != nil {
		mutator.SetResults(*a.Results)
	}
}
func (a *AdapterModel) GetNameOrErr(vErr error) *string {
	if a.Name == nil {
		vErr = multierror.Append(vErr, errors.New(`"name" is required for adapter`))
		return nil
	}
	return a.Name
}

func (a *AdapterModel) SetName(value string) *AdapterModel {
	a.Name = &value
	return a
}
func (a *AdapterModel) GetTagOrErr(vErr error) *string {
	if a.Tag == nil {
		vErr = multierror.Append(vErr, errors.New(`"tag" is required for adapter`))
		return nil
	}
	return a.Tag
}

func (a *AdapterModel) SetTag(value string) *AdapterModel {
	a.Tag = &value
	return a
}
func (a *AdapterModel) GetTypeOrErr(vErr error) *adapter.Type {
	if a.Type == nil {
		vErr = multierror.Append(vErr, errors.New(`"type" is required for adapter`))
		return nil
	}
	return a.Type
}

func (a *AdapterModel) SetType(value adapter.Type) *AdapterModel {
	a.Type = &value
	return a
}
func (a *AdapterModel) GetOperationOrErr(vErr error) *json.RawMessage {
	if a.Operation == nil {
		vErr = multierror.Append(vErr, errors.New(`"operation" is required for adapter`))
		return nil
	}
	return a.Operation
}

func (a *AdapterModel) SetOperation(value json.RawMessage) *AdapterModel {
	a.Operation = &value
	return a
}
func (a *AdapterModel) GetResultsTypeOrErr(vErr error) *adapter.ResultsType {
	if a.ResultsType == nil {
		vErr = multierror.Append(vErr, errors.New(`"results_type" is required for adapter`))
		return nil
	}
	return a.ResultsType
}

func (a *AdapterModel) SetResultsType(value adapter.ResultsType) *AdapterModel {
	a.ResultsType = &value
	return a
}
func (a *AdapterModel) GetResultsOrErr(vErr error) *[]byte {
	if a.Results == nil {
		vErr = multierror.Append(vErr, errors.New(`"results" is required for adapter`))
		return nil
	}
	return a.Results
}

func (a *AdapterModel) SetResults(value []byte) *AdapterModel {
	a.Results = &value
	return a
}
func (a *AdapterModel) GetIDOrErr(vErr error) *int {
	if a.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for adapter`))
		return nil
	}
	return a.ID
}

func (a *AdapterModel) SetID(value int) *AdapterModel {
	a.ID = &value
	return a
}

func (a *AdapterModel) Validate() error {
	if a.Name == nil {
		return errors.New("field \"name\" is required for type \"adapter\"")
	}
	if a.Tag == nil {
		return errors.New("field \"tag\" is required for type \"adapter\"")
	}
	if a.Type == nil {
		return errors.New("field \"type\" is required for type \"adapter\"")
	}
	if a.ResultsType == nil {
		return errors.New("field \"results_type\" is required for type \"adapter\"")
	}
	if a.Results == nil {
		return errors.New("field \"results\" is required for type \"adapter\"")
	}
	return nil
}

type ArtifactHCL struct {
	Name   string        `hcl:"name,attr"`
	Sha256 string        `hcl:"sha256,attr"`
	Type   artifact.Type `hcl:"type,attr"`
}

func (a ArtifactHCL) Model() ArtifactModel {
	return ArtifactModel{
		Name:   &a.Name,
		Sha256: &a.Sha256,
		Type:   &a.Type,
	}
}

type ArtifactModel struct {
	Name   *string        `json:"name,omitempty" hcl:"name,optional"`
	Sha256 *string        `json:"sha256,omitempty" hcl:"sha256,optional"`
	Type   *artifact.Type `json:"type,omitempty" hcl:"type,optional"`
	ID     *int           `json:"id,omitempty" hcl:"id,optional"`
}

func NewArtifactModel() *ArtifactModel {
	return &ArtifactModel{}
}

func (a *ArtifactModel) SetMutatorFields(mutator *ent.ArtifactMutation) {
	if a.Name != nil {
		mutator.SetName(*a.Name)
	}
	if a.Sha256 != nil {
		mutator.SetSha256(*a.Sha256)
	}
	if a.Type != nil {
		mutator.SetType(*a.Type)
	}
}
func (a *ArtifactModel) GetNameOrErr(vErr error) *string {
	if a.Name == nil {
		vErr = multierror.Append(vErr, errors.New(`"name" is required for artifact`))
		return nil
	}
	return a.Name
}

func (a *ArtifactModel) SetName(value string) *ArtifactModel {
	a.Name = &value
	return a
}
func (a *ArtifactModel) GetSha256OrErr(vErr error) *string {
	if a.Sha256 == nil {
		vErr = multierror.Append(vErr, errors.New(`"sha256" is required for artifact`))
		return nil
	}
	return a.Sha256
}

func (a *ArtifactModel) SetSha256(value string) *ArtifactModel {
	a.Sha256 = &value
	return a
}
func (a *ArtifactModel) GetTypeOrErr(vErr error) *artifact.Type {
	if a.Type == nil {
		vErr = multierror.Append(vErr, errors.New(`"type" is required for artifact`))
		return nil
	}
	return a.Type
}

func (a *ArtifactModel) SetType(value artifact.Type) *ArtifactModel {
	a.Type = &value
	return a
}
func (a *ArtifactModel) GetIDOrErr(vErr error) *int {
	if a.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for artifact`))
		return nil
	}
	return a.ID
}

func (a *ArtifactModel) SetID(value int) *ArtifactModel {
	a.ID = &value
	return a
}

func (a *ArtifactModel) Validate() error {
	if a.Name == nil {
		return errors.New("field \"name\" is required for type \"artifact\"")
	}
	if a.Sha256 == nil {
		return errors.New("field \"sha256\" is required for type \"artifact\"")
	}
	if a.Type == nil {
		return errors.New("field \"type\" is required for type \"artifact\"")
	}
	return nil
}

type CodeIssueHCL struct {
	RuleID   string             `hcl:"rule_id,attr"`
	Message  string             `hcl:"message,attr"`
	Severity codeissue.Severity `hcl:"severity,attr"`
	Type     codeissue.Type     `hcl:"type,attr"`
}

func (ci CodeIssueHCL) Model() CodeIssueModel {
	return CodeIssueModel{
		RuleID:   &ci.RuleID,
		Message:  &ci.Message,
		Severity: &ci.Severity,
		Type:     &ci.Type,
	}
}

type CodeIssueModel struct {
	RuleID   *string             `json:"rule_id,omitempty" hcl:"rule_id,optional"`
	Message  *string             `json:"message,omitempty" hcl:"message,optional"`
	Severity *codeissue.Severity `json:"severity,omitempty" hcl:"severity,optional"`
	Type     *codeissue.Type     `json:"type,omitempty" hcl:"type,optional"`
	ID       *int                `json:"id,omitempty" hcl:"id,optional"`
}

func NewCodeIssueModel() *CodeIssueModel {
	return &CodeIssueModel{}
}

func (ci *CodeIssueModel) SetMutatorFields(mutator *ent.CodeIssueMutation) {
	if ci.RuleID != nil {
		mutator.SetRuleID(*ci.RuleID)
	}
	if ci.Message != nil {
		mutator.SetMessage(*ci.Message)
	}
	if ci.Severity != nil {
		mutator.SetSeverity(*ci.Severity)
	}
	if ci.Type != nil {
		mutator.SetType(*ci.Type)
	}
}
func (ci *CodeIssueModel) GetRuleIDOrErr(vErr error) *string {
	if ci.RuleID == nil {
		vErr = multierror.Append(vErr, errors.New(`"rule_id" is required for code_issue`))
		return nil
	}
	return ci.RuleID
}

func (ci *CodeIssueModel) SetRuleID(value string) *CodeIssueModel {
	ci.RuleID = &value
	return ci
}
func (ci *CodeIssueModel) GetMessageOrErr(vErr error) *string {
	if ci.Message == nil {
		vErr = multierror.Append(vErr, errors.New(`"message" is required for code_issue`))
		return nil
	}
	return ci.Message
}

func (ci *CodeIssueModel) SetMessage(value string) *CodeIssueModel {
	ci.Message = &value
	return ci
}
func (ci *CodeIssueModel) GetSeverityOrErr(vErr error) *codeissue.Severity {
	if ci.Severity == nil {
		vErr = multierror.Append(vErr, errors.New(`"severity" is required for code_issue`))
		return nil
	}
	return ci.Severity
}

func (ci *CodeIssueModel) SetSeverity(value codeissue.Severity) *CodeIssueModel {
	ci.Severity = &value
	return ci
}
func (ci *CodeIssueModel) GetTypeOrErr(vErr error) *codeissue.Type {
	if ci.Type == nil {
		vErr = multierror.Append(vErr, errors.New(`"type" is required for code_issue`))
		return nil
	}
	return ci.Type
}

func (ci *CodeIssueModel) SetType(value codeissue.Type) *CodeIssueModel {
	ci.Type = &value
	return ci
}
func (ci *CodeIssueModel) GetIDOrErr(vErr error) *int {
	if ci.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for code_issue`))
		return nil
	}
	return ci.ID
}

func (ci *CodeIssueModel) SetID(value int) *CodeIssueModel {
	ci.ID = &value
	return ci
}

func (ci *CodeIssueModel) Validate() error {
	if ci.RuleID == nil {
		return errors.New("field \"rule_id\" is required for type \"code_issue\"")
	}
	if ci.Message == nil {
		return errors.New("field \"message\" is required for type \"code_issue\"")
	}
	if ci.Severity == nil {
		return errors.New("field \"severity\" is required for type \"code_issue\"")
	}
	if ci.Type == nil {
		return errors.New("field \"type\" is required for type \"code_issue\"")
	}
	return nil
}

type CodeScanHCL struct {
	Tool string `hcl:"tool,attr"`
}

func (cs CodeScanHCL) Model() CodeScanModel {
	return CodeScanModel{
		Tool: &cs.Tool,
	}
}

type CodeScanModel struct {
	Tool *string `json:"tool,omitempty" hcl:"tool,optional"`
	ID   *int    `json:"id,omitempty" hcl:"id,optional"`
}

func NewCodeScanModel() *CodeScanModel {
	return &CodeScanModel{}
}

func (cs *CodeScanModel) SetMutatorFields(mutator *ent.CodeScanMutation) {
	if cs.Tool != nil {
		mutator.SetTool(*cs.Tool)
	}
}
func (cs *CodeScanModel) GetToolOrErr(vErr error) *string {
	if cs.Tool == nil {
		vErr = multierror.Append(vErr, errors.New(`"tool" is required for code_scan`))
		return nil
	}
	return cs.Tool
}

func (cs *CodeScanModel) SetTool(value string) *CodeScanModel {
	cs.Tool = &value
	return cs
}
func (cs *CodeScanModel) GetIDOrErr(vErr error) *int {
	if cs.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for code_scan`))
		return nil
	}
	return cs.ID
}

func (cs *CodeScanModel) SetID(value int) *CodeScanModel {
	cs.ID = &value
	return cs
}

func (cs *CodeScanModel) Validate() error {
	if cs.Tool == nil {
		return errors.New("field \"tool\" is required for type \"code_scan\"")
	}
	return nil
}

type ComponentHCL struct {
	Name        string  `hcl:"name,attr"`
	Vendor      string  `hcl:"vendor,attr"`
	Version     string  `hcl:"version,attr"`
	Description *string `hcl:"description,optional"`
	URL         *string `hcl:"url,optional"`
}

func (c ComponentHCL) Model() ComponentModel {
	return ComponentModel{
		Name:        &c.Name,
		Vendor:      &c.Vendor,
		Version:     &c.Version,
		Description: c.Description,
		URL:         c.URL,
	}
}

type ComponentModel struct {
	Name        *string `json:"name,omitempty" hcl:"name,optional"`
	Vendor      *string `json:"vendor,omitempty" hcl:"vendor,optional"`
	Version     *string `json:"version,omitempty" hcl:"version,optional"`
	Description *string `json:"description,omitempty" hcl:"description,optional"`
	URL         *string `json:"url,omitempty" hcl:"url,optional"`
	ID          *int    `json:"id,omitempty" hcl:"id,optional"`
}

func NewComponentModel() *ComponentModel {
	return &ComponentModel{}
}

func (c *ComponentModel) SetMutatorFields(mutator *ent.ComponentMutation) {
	if c.Name != nil {
		mutator.SetName(*c.Name)
	}
	if c.Vendor != nil {
		mutator.SetVendor(*c.Vendor)
	}
	if c.Version != nil {
		mutator.SetVersion(*c.Version)
	}
	if c.Description != nil {
		mutator.SetDescription(*c.Description)
	}
	if c.URL != nil {
		mutator.SetURL(*c.URL)
	}
}
func (c *ComponentModel) GetNameOrErr(vErr error) *string {
	if c.Name == nil {
		vErr = multierror.Append(vErr, errors.New(`"name" is required for component`))
		return nil
	}
	return c.Name
}

func (c *ComponentModel) SetName(value string) *ComponentModel {
	c.Name = &value
	return c
}
func (c *ComponentModel) GetVendorOrErr(vErr error) *string {
	if c.Vendor == nil {
		vErr = multierror.Append(vErr, errors.New(`"vendor" is required for component`))
		return nil
	}
	return c.Vendor
}

func (c *ComponentModel) SetVendor(value string) *ComponentModel {
	c.Vendor = &value
	return c
}
func (c *ComponentModel) GetVersionOrErr(vErr error) *string {
	if c.Version == nil {
		vErr = multierror.Append(vErr, errors.New(`"version" is required for component`))
		return nil
	}
	return c.Version
}

func (c *ComponentModel) SetVersion(value string) *ComponentModel {
	c.Version = &value
	return c
}
func (c *ComponentModel) GetDescriptionOrErr(vErr error) *string {
	if c.Description == nil {
		vErr = multierror.Append(vErr, errors.New(`"description" is required for component`))
		return nil
	}
	return c.Description
}

func (c *ComponentModel) SetDescription(value string) *ComponentModel {
	c.Description = &value
	return c
}
func (c *ComponentModel) GetURLOrErr(vErr error) *string {
	if c.URL == nil {
		vErr = multierror.Append(vErr, errors.New(`"url" is required for component`))
		return nil
	}
	return c.URL
}

func (c *ComponentModel) SetURL(value string) *ComponentModel {
	c.URL = &value
	return c
}
func (c *ComponentModel) GetIDOrErr(vErr error) *int {
	if c.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for component`))
		return nil
	}
	return c.ID
}

func (c *ComponentModel) SetID(value int) *ComponentModel {
	c.ID = &value
	return c
}

func (c *ComponentModel) Validate() error {
	if c.Name == nil {
		return errors.New("field \"name\" is required for type \"component\"")
	}
	if c.Vendor == nil {
		return errors.New("field \"vendor\" is required for type \"component\"")
	}
	if c.Version == nil {
		return errors.New("field \"version\" is required for type \"component\"")
	}
	return nil
}

type GitCommitHCL struct {
	Hash   string    `hcl:"hash,attr"`
	Branch string    `hcl:"branch,attr"`
	Tag    *string   `hcl:"tag,optional"`
	Time   time.Time `hcl:"time,attr"`
}

func (gc GitCommitHCL) Model() GitCommitModel {
	return GitCommitModel{
		Hash:   &gc.Hash,
		Branch: &gc.Branch,
		Tag:    gc.Tag,
		Time:   &gc.Time,
	}
}

type GitCommitModel struct {
	Hash   *string    `json:"hash,omitempty" hcl:"hash,optional"`
	Branch *string    `json:"branch,omitempty" hcl:"branch,optional"`
	Tag    *string    `json:"tag,omitempty" hcl:"tag,optional"`
	Time   *time.Time `json:"time,omitempty" hcl:"time,optional"`
	ID     *int       `json:"id,omitempty" hcl:"id,optional"`
}

func NewGitCommitModel() *GitCommitModel {
	return &GitCommitModel{}
}

func (gc *GitCommitModel) SetMutatorFields(mutator *ent.GitCommitMutation) {
	if gc.Hash != nil {
		mutator.SetHash(*gc.Hash)
	}
	if gc.Branch != nil {
		mutator.SetBranch(*gc.Branch)
	}
	if gc.Tag != nil {
		mutator.SetTag(*gc.Tag)
	}
	if gc.Time != nil {
		mutator.SetTime(*gc.Time)
	}
}
func (gc *GitCommitModel) GetHashOrErr(vErr error) *string {
	if gc.Hash == nil {
		vErr = multierror.Append(vErr, errors.New(`"hash" is required for commit`))
		return nil
	}
	return gc.Hash
}

func (gc *GitCommitModel) SetHash(value string) *GitCommitModel {
	gc.Hash = &value
	return gc
}
func (gc *GitCommitModel) GetBranchOrErr(vErr error) *string {
	if gc.Branch == nil {
		vErr = multierror.Append(vErr, errors.New(`"branch" is required for commit`))
		return nil
	}
	return gc.Branch
}

func (gc *GitCommitModel) SetBranch(value string) *GitCommitModel {
	gc.Branch = &value
	return gc
}
func (gc *GitCommitModel) GetTagOrErr(vErr error) *string {
	if gc.Tag == nil {
		vErr = multierror.Append(vErr, errors.New(`"tag" is required for commit`))
		return nil
	}
	return gc.Tag
}

func (gc *GitCommitModel) SetTag(value string) *GitCommitModel {
	gc.Tag = &value
	return gc
}
func (gc *GitCommitModel) GetTimeOrErr(vErr error) *time.Time {
	if gc.Time == nil {
		vErr = multierror.Append(vErr, errors.New(`"time" is required for commit`))
		return nil
	}
	return gc.Time
}

func (gc *GitCommitModel) SetTime(value time.Time) *GitCommitModel {
	gc.Time = &value
	return gc
}
func (gc *GitCommitModel) GetIDOrErr(vErr error) *int {
	if gc.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for commit`))
		return nil
	}
	return gc.ID
}

func (gc *GitCommitModel) SetID(value int) *GitCommitModel {
	gc.ID = &value
	return gc
}

func (gc *GitCommitModel) Validate() error {
	if gc.Hash == nil {
		return errors.New("field \"hash\" is required for type \"commit\"")
	}
	if gc.Branch == nil {
		return errors.New("field \"branch\" is required for type \"commit\"")
	}
	if gc.Time == nil {
		return errors.New("field \"time\" is required for type \"commit\"")
	}
	return nil
}

type ProjectHCL struct {
	Name string `hcl:"name,attr"`
}

func (pr ProjectHCL) Model() ProjectModel {
	return ProjectModel{
		Name: &pr.Name,
	}
}

type ProjectModel struct {
	Name *string `json:"name,omitempty" hcl:"name,optional"`
	ID   *int    `json:"id,omitempty" hcl:"id,optional"`
}

func NewProjectModel() *ProjectModel {
	return &ProjectModel{}
}

func (pr *ProjectModel) SetMutatorFields(mutator *ent.ProjectMutation) {
	if pr.Name != nil {
		mutator.SetName(*pr.Name)
	}
}
func (pr *ProjectModel) GetNameOrErr(vErr error) *string {
	if pr.Name == nil {
		vErr = multierror.Append(vErr, errors.New(`"name" is required for project`))
		return nil
	}
	return pr.Name
}

func (pr *ProjectModel) SetName(value string) *ProjectModel {
	pr.Name = &value
	return pr
}
func (pr *ProjectModel) GetIDOrErr(vErr error) *int {
	if pr.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for project`))
		return nil
	}
	return pr.ID
}

func (pr *ProjectModel) SetID(value int) *ProjectModel {
	pr.ID = &value
	return pr
}

func (pr *ProjectModel) Validate() error {
	if pr.Name == nil {
		return errors.New("field \"name\" is required for type \"project\"")
	}
	return nil
}

type ReleaseHCL struct {
	Name    string         `hcl:"name,attr"`
	Version string         `hcl:"version,attr"`
	Status  release.Status `hcl:"status,attr"`
}

func (r ReleaseHCL) Model() ReleaseModel {
	return ReleaseModel{
		Name:    &r.Name,
		Version: &r.Version,
		Status:  &r.Status,
	}
}

type ReleaseModel struct {
	Name    *string         `json:"name,omitempty" hcl:"name,optional"`
	Version *string         `json:"version,omitempty" hcl:"version,optional"`
	Status  *release.Status `json:"status,omitempty" hcl:"status,optional"`
	ID      *int            `json:"id,omitempty" hcl:"id,optional"`
}

func NewReleaseModel() *ReleaseModel {
	return &ReleaseModel{}
}

func (r *ReleaseModel) SetMutatorFields(mutator *ent.ReleaseMutation) {
	if r.Name != nil {
		mutator.SetName(*r.Name)
	}
	if r.Version != nil {
		mutator.SetVersion(*r.Version)
	}
	if r.Status != nil {
		mutator.SetStatus(*r.Status)
	}
}
func (r *ReleaseModel) GetNameOrErr(vErr error) *string {
	if r.Name == nil {
		vErr = multierror.Append(vErr, errors.New(`"name" is required for release`))
		return nil
	}
	return r.Name
}

func (r *ReleaseModel) SetName(value string) *ReleaseModel {
	r.Name = &value
	return r
}
func (r *ReleaseModel) GetVersionOrErr(vErr error) *string {
	if r.Version == nil {
		vErr = multierror.Append(vErr, errors.New(`"version" is required for release`))
		return nil
	}
	return r.Version
}

func (r *ReleaseModel) SetVersion(value string) *ReleaseModel {
	r.Version = &value
	return r
}
func (r *ReleaseModel) GetStatusOrErr(vErr error) *release.Status {
	if r.Status == nil {
		vErr = multierror.Append(vErr, errors.New(`"status" is required for release`))
		return nil
	}
	return r.Status
}

func (r *ReleaseModel) SetStatus(value release.Status) *ReleaseModel {
	r.Status = &value
	return r
}
func (r *ReleaseModel) GetIDOrErr(vErr error) *int {
	if r.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for release`))
		return nil
	}
	return r.ID
}

func (r *ReleaseModel) SetID(value int) *ReleaseModel {
	r.ID = &value
	return r
}

func (r *ReleaseModel) Validate() error {
	if r.Name == nil {
		return errors.New("field \"name\" is required for type \"release\"")
	}
	if r.Version == nil {
		return errors.New("field \"version\" is required for type \"release\"")
	}
	if r.Status == nil {
		return errors.New("field \"status\" is required for type \"release\"")
	}
	return nil
}

type RepoHCL struct {
	Name string `hcl:"name,attr"`
}

func (r RepoHCL) Model() RepoModel {
	return RepoModel{
		Name: &r.Name,
	}
}

type RepoModel struct {
	Name *string `json:"name,omitempty" hcl:"name,optional"`
	ID   *int    `json:"id,omitempty" hcl:"id,optional"`
}

func NewRepoModel() *RepoModel {
	return &RepoModel{}
}

func (r *RepoModel) SetMutatorFields(mutator *ent.RepoMutation) {
	if r.Name != nil {
		mutator.SetName(*r.Name)
	}
}
func (r *RepoModel) GetNameOrErr(vErr error) *string {
	if r.Name == nil {
		vErr = multierror.Append(vErr, errors.New(`"name" is required for repo`))
		return nil
	}
	return r.Name
}

func (r *RepoModel) SetName(value string) *RepoModel {
	r.Name = &value
	return r
}
func (r *RepoModel) GetIDOrErr(vErr error) *int {
	if r.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for repo`))
		return nil
	}
	return r.ID
}

func (r *RepoModel) SetID(value int) *RepoModel {
	r.ID = &value
	return r
}

func (r *RepoModel) Validate() error {
	if r.Name == nil {
		return errors.New("field \"name\" is required for type \"repo\"")
	}
	return nil
}

type TestCaseHCL struct {
	Name    string  `hcl:"name,attr"`
	Result  bool    `hcl:"result,attr"`
	Message string  `hcl:"message,attr"`
	Elapsed float64 `hcl:"elapsed,attr"`
}

func (tc TestCaseHCL) Model() TestCaseModel {
	return TestCaseModel{
		Name:    &tc.Name,
		Result:  &tc.Result,
		Message: &tc.Message,
		Elapsed: &tc.Elapsed,
	}
}

type TestCaseModel struct {
	Name    *string  `json:"name,omitempty" hcl:"name,optional"`
	Result  *bool    `json:"result,omitempty" hcl:"result,optional"`
	Message *string  `json:"message,omitempty" hcl:"message,optional"`
	Elapsed *float64 `json:"elapsed,omitempty" hcl:"elapsed,optional"`
	ID      *int     `json:"id,omitempty" hcl:"id,optional"`
}

func NewTestCaseModel() *TestCaseModel {
	return &TestCaseModel{}
}

func (tc *TestCaseModel) SetMutatorFields(mutator *ent.TestCaseMutation) {
	if tc.Name != nil {
		mutator.SetName(*tc.Name)
	}
	if tc.Result != nil {
		mutator.SetResult(*tc.Result)
	}
	if tc.Message != nil {
		mutator.SetMessage(*tc.Message)
	}
	if tc.Elapsed != nil {
		mutator.SetElapsed(*tc.Elapsed)
	}
}
func (tc *TestCaseModel) GetNameOrErr(vErr error) *string {
	if tc.Name == nil {
		vErr = multierror.Append(vErr, errors.New(`"name" is required for test_case`))
		return nil
	}
	return tc.Name
}

func (tc *TestCaseModel) SetName(value string) *TestCaseModel {
	tc.Name = &value
	return tc
}
func (tc *TestCaseModel) GetResultOrErr(vErr error) *bool {
	if tc.Result == nil {
		vErr = multierror.Append(vErr, errors.New(`"result" is required for test_case`))
		return nil
	}
	return tc.Result
}

func (tc *TestCaseModel) SetResult(value bool) *TestCaseModel {
	tc.Result = &value
	return tc
}
func (tc *TestCaseModel) GetMessageOrErr(vErr error) *string {
	if tc.Message == nil {
		vErr = multierror.Append(vErr, errors.New(`"message" is required for test_case`))
		return nil
	}
	return tc.Message
}

func (tc *TestCaseModel) SetMessage(value string) *TestCaseModel {
	tc.Message = &value
	return tc
}
func (tc *TestCaseModel) GetElapsedOrErr(vErr error) *float64 {
	if tc.Elapsed == nil {
		vErr = multierror.Append(vErr, errors.New(`"elapsed" is required for test_case`))
		return nil
	}
	return tc.Elapsed
}

func (tc *TestCaseModel) SetElapsed(value float64) *TestCaseModel {
	tc.Elapsed = &value
	return tc
}
func (tc *TestCaseModel) GetIDOrErr(vErr error) *int {
	if tc.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for test_case`))
		return nil
	}
	return tc.ID
}

func (tc *TestCaseModel) SetID(value int) *TestCaseModel {
	tc.ID = &value
	return tc
}

func (tc *TestCaseModel) Validate() error {
	if tc.Name == nil {
		return errors.New("field \"name\" is required for type \"test_case\"")
	}
	if tc.Result == nil {
		return errors.New("field \"result\" is required for type \"test_case\"")
	}
	if tc.Message == nil {
		return errors.New("field \"message\" is required for type \"test_case\"")
	}
	if tc.Elapsed == nil {
		return errors.New("field \"elapsed\" is required for type \"test_case\"")
	}
	return nil
}

type TestRunHCL struct {
	Tool string `hcl:"tool,attr"`
}

func (tr TestRunHCL) Model() TestRunModel {
	return TestRunModel{
		Tool: &tr.Tool,
	}
}

type TestRunModel struct {
	Tool *string `json:"tool,omitempty" hcl:"tool,optional"`
	ID   *int    `json:"id,omitempty" hcl:"id,optional"`
}

func NewTestRunModel() *TestRunModel {
	return &TestRunModel{}
}

func (tr *TestRunModel) SetMutatorFields(mutator *ent.TestRunMutation) {
	if tr.Tool != nil {
		mutator.SetTool(*tr.Tool)
	}
}
func (tr *TestRunModel) GetToolOrErr(vErr error) *string {
	if tr.Tool == nil {
		vErr = multierror.Append(vErr, errors.New(`"tool" is required for test_run`))
		return nil
	}
	return tr.Tool
}

func (tr *TestRunModel) SetTool(value string) *TestRunModel {
	tr.Tool = &value
	return tr
}
func (tr *TestRunModel) GetIDOrErr(vErr error) *int {
	if tr.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for test_run`))
		return nil
	}
	return tr.ID
}

func (tr *TestRunModel) SetID(value int) *TestRunModel {
	tr.ID = &value
	return tr
}

func (tr *TestRunModel) Validate() error {
	if tr.Tool == nil {
		return errors.New("field \"tool\" is required for type \"test_run\"")
	}
	return nil
}

type VulnerabilityHCL struct {
	Vid           string                 `hcl:"vid,attr"`
	Summary       *string                `hcl:"summary,optional"`
	Description   *string                `hcl:"description,optional"`
	SeverityScore float64                `hcl:"severity_score,attr"`
	Severity      vulnerability.Severity `hcl:"severity,attr"`
	Published     *time.Time             `hcl:"published,optional"`
	Modified      *time.Time             `hcl:"modified,optional"`
}

func (v VulnerabilityHCL) Model() VulnerabilityModel {
	return VulnerabilityModel{
		Vid:           &v.Vid,
		Summary:       v.Summary,
		Description:   v.Description,
		SeverityScore: &v.SeverityScore,
		Severity:      &v.Severity,
		Published:     v.Published,
		Modified:      v.Modified,
	}
}

type VulnerabilityModel struct {
	Vid           *string                 `json:"vid,omitempty" hcl:"vid,optional"`
	Summary       *string                 `json:"summary,omitempty" hcl:"summary,optional"`
	Description   *string                 `json:"description,omitempty" hcl:"description,optional"`
	SeverityScore *float64                `json:"severity_score,omitempty" hcl:"severity_score,optional"`
	Severity      *vulnerability.Severity `json:"severity,omitempty" hcl:"severity,optional"`
	Published     *time.Time              `json:"published,omitempty" hcl:"published,optional"`
	Modified      *time.Time              `json:"modified,omitempty" hcl:"modified,optional"`
	ID            *int                    `json:"id,omitempty" hcl:"id,optional"`
}

func NewVulnerabilityModel() *VulnerabilityModel {
	return &VulnerabilityModel{}
}

func (v *VulnerabilityModel) SetMutatorFields(mutator *ent.VulnerabilityMutation) {
	if v.Vid != nil {
		mutator.SetVid(*v.Vid)
	}
	if v.Summary != nil {
		mutator.SetSummary(*v.Summary)
	}
	if v.Description != nil {
		mutator.SetDescription(*v.Description)
	}
	if v.SeverityScore != nil {
		mutator.SetSeverityScore(*v.SeverityScore)
	}
	if v.Severity != nil {
		mutator.SetSeverity(*v.Severity)
	}
	if v.Published != nil {
		mutator.SetPublished(*v.Published)
	}
	if v.Modified != nil {
		mutator.SetModified(*v.Modified)
	}
}
func (v *VulnerabilityModel) GetVidOrErr(vErr error) *string {
	if v.Vid == nil {
		vErr = multierror.Append(vErr, errors.New(`"vid" is required for vulnerability`))
		return nil
	}
	return v.Vid
}

func (v *VulnerabilityModel) SetVid(value string) *VulnerabilityModel {
	v.Vid = &value
	return v
}
func (v *VulnerabilityModel) GetSummaryOrErr(vErr error) *string {
	if v.Summary == nil {
		vErr = multierror.Append(vErr, errors.New(`"summary" is required for vulnerability`))
		return nil
	}
	return v.Summary
}

func (v *VulnerabilityModel) SetSummary(value string) *VulnerabilityModel {
	v.Summary = &value
	return v
}
func (v *VulnerabilityModel) GetDescriptionOrErr(vErr error) *string {
	if v.Description == nil {
		vErr = multierror.Append(vErr, errors.New(`"description" is required for vulnerability`))
		return nil
	}
	return v.Description
}

func (v *VulnerabilityModel) SetDescription(value string) *VulnerabilityModel {
	v.Description = &value
	return v
}
func (v *VulnerabilityModel) GetSeverityScoreOrErr(vErr error) *float64 {
	if v.SeverityScore == nil {
		vErr = multierror.Append(vErr, errors.New(`"severity_score" is required for vulnerability`))
		return nil
	}
	return v.SeverityScore
}

func (v *VulnerabilityModel) SetSeverityScore(value float64) *VulnerabilityModel {
	v.SeverityScore = &value
	return v
}
func (v *VulnerabilityModel) GetSeverityOrErr(vErr error) *vulnerability.Severity {
	if v.Severity == nil {
		vErr = multierror.Append(vErr, errors.New(`"severity" is required for vulnerability`))
		return nil
	}
	return v.Severity
}

func (v *VulnerabilityModel) SetSeverity(value vulnerability.Severity) *VulnerabilityModel {
	v.Severity = &value
	return v
}
func (v *VulnerabilityModel) GetPublishedOrErr(vErr error) *time.Time {
	if v.Published == nil {
		vErr = multierror.Append(vErr, errors.New(`"published" is required for vulnerability`))
		return nil
	}
	return v.Published
}

func (v *VulnerabilityModel) SetPublished(value time.Time) *VulnerabilityModel {
	v.Published = &value
	return v
}
func (v *VulnerabilityModel) GetModifiedOrErr(vErr error) *time.Time {
	if v.Modified == nil {
		vErr = multierror.Append(vErr, errors.New(`"modified" is required for vulnerability`))
		return nil
	}
	return v.Modified
}

func (v *VulnerabilityModel) SetModified(value time.Time) *VulnerabilityModel {
	v.Modified = &value
	return v
}
func (v *VulnerabilityModel) GetIDOrErr(vErr error) *int {
	if v.ID == nil {
		vErr = multierror.Append(vErr, errors.New(`"id" is required for vulnerability`))
		return nil
	}
	return v.ID
}

func (v *VulnerabilityModel) SetID(value int) *VulnerabilityModel {
	v.ID = &value
	return v
}

func (v *VulnerabilityModel) Validate() error {
	if v.Vid == nil {
		return errors.New("field \"vid\" is required for type \"vulnerability\"")
	}
	if v.SeverityScore == nil {
		return errors.New("field \"severity_score\" is required for type \"vulnerability\"")
	}
	if v.Severity == nil {
		return errors.New("field \"severity\" is required for type \"vulnerability\"")
	}
	return nil
}
