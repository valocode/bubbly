// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
)

func (a *AdapterQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *AdapterOrder, where *AdapterWhereInput,
) ([]*Adapter, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultAdapterOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultAdapterOrder.Field
	}

	a, err := where.Filter(a)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	a = a.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultAdapterOrder.Field {
		a = a.Order(orderBy.Direction.orderFunc(DefaultAdapterOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	return a.All(ctx)
}

func (a *ArtifactQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ArtifactOrder, where *ArtifactWhereInput,
) ([]*Artifact, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultArtifactOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultArtifactOrder.Field
	}

	a, err := where.Filter(a)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	a = a.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultArtifactOrder.Field {
		a = a.Order(orderBy.Direction.orderFunc(DefaultArtifactOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	return a.All(ctx)
}

func (ci *CodeIssueQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CodeIssueOrder, where *CodeIssueWhereInput,
) ([]*CodeIssue, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCodeIssueOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCodeIssueOrder.Field
	}

	ci, err := where.Filter(ci)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	ci = ci.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCodeIssueOrder.Field {
		ci = ci.Order(orderBy.Direction.orderFunc(DefaultCodeIssueOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		ci = ci.Limit(limit)
	}

	return ci.All(ctx)
}

func (cs *CodeScanQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CodeScanOrder, where *CodeScanWhereInput,
) ([]*CodeScan, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCodeScanOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCodeScanOrder.Field
	}

	cs, err := where.Filter(cs)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	cs = cs.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCodeScanOrder.Field {
		cs = cs.Order(orderBy.Direction.orderFunc(DefaultCodeScanOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		cs = cs.Limit(limit)
	}

	return cs.All(ctx)
}

func (c *ComponentQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ComponentOrder, where *ComponentWhereInput,
) ([]*Component, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultComponentOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultComponentOrder.Field
	}

	c, err := where.Filter(c)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	c = c.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultComponentOrder.Field {
		c = c.Order(orderBy.Direction.orderFunc(DefaultComponentOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	return c.All(ctx)
}

func (e *EventQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *EventOrder, where *EventWhereInput,
) ([]*Event, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultEventOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultEventOrder.Field
	}

	e, err := where.Filter(e)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	e = e.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultEventOrder.Field {
		e = e.Order(orderBy.Direction.orderFunc(DefaultEventOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	return e.All(ctx)
}

func (gc *GitCommitQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *GitCommitOrder, where *GitCommitWhereInput,
) ([]*GitCommit, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultGitCommitOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultGitCommitOrder.Field
	}

	gc, err := where.Filter(gc)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	gc = gc.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultGitCommitOrder.Field {
		gc = gc.Order(orderBy.Direction.orderFunc(DefaultGitCommitOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		gc = gc.Limit(limit)
	}

	return gc.All(ctx)
}

func (l *LicenseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *LicenseOrder, where *LicenseWhereInput,
) ([]*License, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultLicenseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultLicenseOrder.Field
	}

	l, err := where.Filter(l)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	l = l.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultLicenseOrder.Field {
		l = l.Order(orderBy.Direction.orderFunc(DefaultLicenseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		l = l.Limit(limit)
	}

	return l.All(ctx)
}

func (o *OrganizationQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *OrganizationOrder, where *OrganizationWhereInput,
) ([]*Organization, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultOrganizationOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultOrganizationOrder.Field
	}

	o, err := where.Filter(o)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	o = o.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultOrganizationOrder.Field {
		o = o.Order(orderBy.Direction.orderFunc(DefaultOrganizationOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		o = o.Limit(limit)
	}

	return o.All(ctx)
}

func (pr *ProjectQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ProjectOrder, where *ProjectWhereInput,
) ([]*Project, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultProjectOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultProjectOrder.Field
	}

	pr, err := where.Filter(pr)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	pr = pr.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultProjectOrder.Field {
		pr = pr.Order(orderBy.Direction.orderFunc(DefaultProjectOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	return pr.All(ctx)
}

func (r *ReleaseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseOrder, where *ReleaseWhereInput,
) ([]*Release, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseOrder.Field
	}

	r, err := where.Filter(r)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	r = r.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseOrder.Field {
		r = r.Order(orderBy.Direction.orderFunc(DefaultReleaseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	return r.All(ctx)
}

func (rc *ReleaseComponentQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseComponentOrder, where *ReleaseComponentWhereInput,
) ([]*ReleaseComponent, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseComponentOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseComponentOrder.Field
	}

	rc, err := where.Filter(rc)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	rc = rc.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseComponentOrder.Field {
		rc = rc.Order(orderBy.Direction.orderFunc(DefaultReleaseComponentOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		rc = rc.Limit(limit)
	}

	return rc.All(ctx)
}

func (re *ReleaseEntryQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseEntryOrder, where *ReleaseEntryWhereInput,
) ([]*ReleaseEntry, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseEntryOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseEntryOrder.Field
	}

	re, err := where.Filter(re)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	re = re.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseEntryOrder.Field {
		re = re.Order(orderBy.Direction.orderFunc(DefaultReleaseEntryOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		re = re.Limit(limit)
	}

	return re.All(ctx)
}

func (rl *ReleaseLicenseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseLicenseOrder, where *ReleaseLicenseWhereInput,
) ([]*ReleaseLicense, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseLicenseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseLicenseOrder.Field
	}

	rl, err := where.Filter(rl)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	rl = rl.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseLicenseOrder.Field {
		rl = rl.Order(orderBy.Direction.orderFunc(DefaultReleaseLicenseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		rl = rl.Limit(limit)
	}

	return rl.All(ctx)
}

func (rp *ReleasePolicyQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleasePolicyOrder, where *ReleasePolicyWhereInput,
) ([]*ReleasePolicy, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleasePolicyOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleasePolicyOrder.Field
	}

	rp, err := where.Filter(rp)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	rp = rp.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleasePolicyOrder.Field {
		rp = rp.Order(orderBy.Direction.orderFunc(DefaultReleasePolicyOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		rp = rp.Limit(limit)
	}

	return rp.All(ctx)
}

func (rpv *ReleasePolicyViolationQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleasePolicyViolationOrder, where *ReleasePolicyViolationWhereInput,
) ([]*ReleasePolicyViolation, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleasePolicyViolationOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleasePolicyViolationOrder.Field
	}

	rpv, err := where.Filter(rpv)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	rpv = rpv.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleasePolicyViolationOrder.Field {
		rpv = rpv.Order(orderBy.Direction.orderFunc(DefaultReleasePolicyViolationOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		rpv = rpv.Limit(limit)
	}

	return rpv.All(ctx)
}

func (rv *ReleaseVulnerabilityQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseVulnerabilityOrder, where *ReleaseVulnerabilityWhereInput,
) ([]*ReleaseVulnerability, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseVulnerabilityOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseVulnerabilityOrder.Field
	}

	rv, err := where.Filter(rv)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	rv = rv.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseVulnerabilityOrder.Field {
		rv = rv.Order(orderBy.Direction.orderFunc(DefaultReleaseVulnerabilityOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		rv = rv.Limit(limit)
	}

	return rv.All(ctx)
}

func (r *RepoQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *RepoOrder, where *RepoWhereInput,
) ([]*Repo, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultRepoOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultRepoOrder.Field
	}

	r, err := where.Filter(r)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	r = r.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultRepoOrder.Field {
		r = r.Order(orderBy.Direction.orderFunc(DefaultRepoOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	return r.All(ctx)
}

func (sl *SPDXLicenseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *SPDXLicenseOrder, where *SPDXLicenseWhereInput,
) ([]*SPDXLicense, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultSPDXLicenseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultSPDXLicenseOrder.Field
	}

	sl, err := where.Filter(sl)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	sl = sl.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultSPDXLicenseOrder.Field {
		sl = sl.Order(orderBy.Direction.orderFunc(DefaultSPDXLicenseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		sl = sl.Limit(limit)
	}

	return sl.All(ctx)
}

func (tc *TestCaseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *TestCaseOrder, where *TestCaseWhereInput,
) ([]*TestCase, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultTestCaseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultTestCaseOrder.Field
	}

	tc, err := where.Filter(tc)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	tc = tc.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultTestCaseOrder.Field {
		tc = tc.Order(orderBy.Direction.orderFunc(DefaultTestCaseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		tc = tc.Limit(limit)
	}

	return tc.All(ctx)
}

func (tr *TestRunQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *TestRunOrder, where *TestRunWhereInput,
) ([]*TestRun, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultTestRunOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultTestRunOrder.Field
	}

	tr, err := where.Filter(tr)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	tr = tr.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultTestRunOrder.Field {
		tr = tr.Order(orderBy.Direction.orderFunc(DefaultTestRunOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		tr = tr.Limit(limit)
	}

	return tr.All(ctx)
}

func (v *VulnerabilityQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *VulnerabilityOrder, where *VulnerabilityWhereInput,
) ([]*Vulnerability, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultVulnerabilityOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultVulnerabilityOrder.Field
	}

	v, err := where.Filter(v)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	v = v.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultVulnerabilityOrder.Field {
		v = v.Order(orderBy.Direction.orderFunc(DefaultVulnerabilityOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		v = v.Limit(limit)
	}

	return v.All(ctx)
}

func (vr *VulnerabilityReviewQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *VulnerabilityReviewOrder, where *VulnerabilityReviewWhereInput,
) ([]*VulnerabilityReview, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultVulnerabilityReviewOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultVulnerabilityReviewOrder.Field
	}

	vr, err := where.Filter(vr)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	vr = vr.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultVulnerabilityReviewOrder.Field {
		vr = vr.Order(orderBy.Direction.orderFunc(DefaultVulnerabilityReviewOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		vr = vr.Limit(limit)
	}

	return vr.All(ctx)
}
