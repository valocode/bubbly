// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
)

func (a *ArtifactQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ArtifactOrder, where *ArtifactWhereInput,
) ([]*Artifact, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultArtifactOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultArtifactOrder.Field
	}

	a, err := where.Filter(a)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	a = a.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultArtifactOrder.Field {
		a = a.Order(orderBy.Direction.orderFunc(DefaultArtifactOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	return a.All(ctx)
}

func (c *CVEQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CVEOrder, where *CVEWhereInput,
) ([]*CVE, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCVEOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCVEOrder.Field
	}

	c, err := where.Filter(c)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	c = c.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCVEOrder.Field {
		c = c.Order(orderBy.Direction.orderFunc(DefaultCVEOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	return c.All(ctx)
}

func (cr *CVERuleQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CVERuleOrder, where *CVERuleWhereInput,
) ([]*CVERule, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCVERuleOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCVERuleOrder.Field
	}

	cr, err := where.Filter(cr)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	cr = cr.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCVERuleOrder.Field {
		cr = cr.Order(orderBy.Direction.orderFunc(DefaultCVERuleOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		cr = cr.Limit(limit)
	}

	return cr.All(ctx)
}

func (cs *CVEScanQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CVEScanOrder, where *CVEScanWhereInput,
) ([]*CVEScan, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCVEScanOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCVEScanOrder.Field
	}

	cs, err := where.Filter(cs)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	cs = cs.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCVEScanOrder.Field {
		cs = cs.Order(orderBy.Direction.orderFunc(DefaultCVEScanOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		cs = cs.Limit(limit)
	}

	return cs.All(ctx)
}

func (c *CWEQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CWEOrder, where *CWEWhereInput,
) ([]*CWE, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCWEOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCWEOrder.Field
	}

	c, err := where.Filter(c)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	c = c.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCWEOrder.Field {
		c = c.Order(orderBy.Direction.orderFunc(DefaultCWEOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	return c.All(ctx)
}

func (ci *CodeIssueQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CodeIssueOrder, where *CodeIssueWhereInput,
) ([]*CodeIssue, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCodeIssueOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCodeIssueOrder.Field
	}

	ci, err := where.Filter(ci)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	ci = ci.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCodeIssueOrder.Field {
		ci = ci.Order(orderBy.Direction.orderFunc(DefaultCodeIssueOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		ci = ci.Limit(limit)
	}

	return ci.All(ctx)
}

func (cs *CodeScanQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *CodeScanOrder, where *CodeScanWhereInput,
) ([]*CodeScan, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultCodeScanOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultCodeScanOrder.Field
	}

	cs, err := where.Filter(cs)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	cs = cs.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultCodeScanOrder.Field {
		cs = cs.Order(orderBy.Direction.orderFunc(DefaultCodeScanOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		cs = cs.Limit(limit)
	}

	return cs.All(ctx)
}

func (c *ComponentQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ComponentOrder, where *ComponentWhereInput,
) ([]*Component, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultComponentOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultComponentOrder.Field
	}

	c, err := where.Filter(c)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	c = c.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultComponentOrder.Field {
		c = c.Order(orderBy.Direction.orderFunc(DefaultComponentOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	return c.All(ctx)
}

func (gc *GitCommitQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *GitCommitOrder, where *GitCommitWhereInput,
) ([]*GitCommit, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultGitCommitOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultGitCommitOrder.Field
	}

	gc, err := where.Filter(gc)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	gc = gc.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultGitCommitOrder.Field {
		gc = gc.Order(orderBy.Direction.orderFunc(DefaultGitCommitOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		gc = gc.Limit(limit)
	}

	return gc.All(ctx)
}

func (l *LicenseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *LicenseOrder, where *LicenseWhereInput,
) ([]*License, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultLicenseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultLicenseOrder.Field
	}

	l, err := where.Filter(l)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	l = l.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultLicenseOrder.Field {
		l = l.Order(orderBy.Direction.orderFunc(DefaultLicenseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		l = l.Limit(limit)
	}

	return l.All(ctx)
}

func (ls *LicenseScanQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *LicenseScanOrder, where *LicenseScanWhereInput,
) ([]*LicenseScan, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultLicenseScanOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultLicenseScanOrder.Field
	}

	ls, err := where.Filter(ls)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	ls = ls.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultLicenseScanOrder.Field {
		ls = ls.Order(orderBy.Direction.orderFunc(DefaultLicenseScanOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		ls = ls.Limit(limit)
	}

	return ls.All(ctx)
}

func (lu *LicenseUsageQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *LicenseUsageOrder, where *LicenseUsageWhereInput,
) ([]*LicenseUsage, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultLicenseUsageOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultLicenseUsageOrder.Field
	}

	lu, err := where.Filter(lu)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	lu = lu.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultLicenseUsageOrder.Field {
		lu = lu.Order(orderBy.Direction.orderFunc(DefaultLicenseUsageOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		lu = lu.Limit(limit)
	}

	return lu.All(ctx)
}

func (pr *ProjectQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ProjectOrder, where *ProjectWhereInput,
) ([]*Project, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultProjectOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultProjectOrder.Field
	}

	pr, err := where.Filter(pr)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	pr = pr.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultProjectOrder.Field {
		pr = pr.Order(orderBy.Direction.orderFunc(DefaultProjectOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	return pr.All(ctx)
}

func (r *ReleaseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseOrder, where *ReleaseWhereInput,
) ([]*Release, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseOrder.Field
	}

	r, err := where.Filter(r)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	r = r.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseOrder.Field {
		r = r.Order(orderBy.Direction.orderFunc(DefaultReleaseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	return r.All(ctx)
}

func (rc *ReleaseCheckQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseCheckOrder, where *ReleaseCheckWhereInput,
) ([]*ReleaseCheck, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseCheckOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseCheckOrder.Field
	}

	rc, err := where.Filter(rc)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	rc = rc.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseCheckOrder.Field {
		rc = rc.Order(orderBy.Direction.orderFunc(DefaultReleaseCheckOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		rc = rc.Limit(limit)
	}

	return rc.All(ctx)
}

func (re *ReleaseEntryQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *ReleaseEntryOrder, where *ReleaseEntryWhereInput,
) ([]*ReleaseEntry, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultReleaseEntryOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultReleaseEntryOrder.Field
	}

	re, err := where.Filter(re)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	re = re.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultReleaseEntryOrder.Field {
		re = re.Order(orderBy.Direction.orderFunc(DefaultReleaseEntryOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		re = re.Limit(limit)
	}

	return re.All(ctx)
}

func (r *RepoQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *RepoOrder, where *RepoWhereInput,
) ([]*Repo, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultRepoOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultRepoOrder.Field
	}

	r, err := where.Filter(r)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	r = r.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultRepoOrder.Field {
		r = r.Order(orderBy.Direction.orderFunc(DefaultRepoOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	return r.All(ctx)
}

func (tc *TestCaseQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *TestCaseOrder, where *TestCaseWhereInput,
) ([]*TestCase, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultTestCaseOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultTestCaseOrder.Field
	}

	tc, err := where.Filter(tc)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	tc = tc.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultTestCaseOrder.Field {
		tc = tc.Order(orderBy.Direction.orderFunc(DefaultTestCaseOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		tc = tc.Limit(limit)
	}

	return tc.All(ctx)
}

func (tr *TestRunQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *TestRunOrder, where *TestRunWhereInput,
) ([]*TestRun, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultTestRunOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultTestRunOrder.Field
	}

	tr, err := where.Filter(tr)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	tr = tr.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultTestRunOrder.Field {
		tr = tr.Order(orderBy.Direction.orderFunc(DefaultTestRunOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		tr = tr.Limit(limit)
	}

	return tr.All(ctx)
}

func (v *VulnerabilityQuery) Filter(
	ctx context.Context, first *int, last *int,
	orderBy *VulnerabilityOrder, where *VulnerabilityWhereInput,
) ([]*Vulnerability, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	if orderBy == nil {
		orderBy = DefaultVulnerabilityOrder
	}
	if err := orderBy.Direction.Validate(); err != nil {
		return nil, err
	}
	if orderBy.Field == nil {
		orderBy.Field = DefaultVulnerabilityOrder.Field
	}

	v, err := where.Filter(v)
	if err != nil {
		return nil, err
	}

	// If getting last then reverse the direction
	if last != nil {
		orderBy.Direction = orderBy.Direction.reverse()
	}
	v = v.Order(orderBy.Direction.orderFunc(orderBy.Field.field))
	// If a custom order was given, also apply the default order
	if orderBy.Field != DefaultVulnerabilityOrder.Field {
		v = v.Order(orderBy.Direction.orderFunc(DefaultVulnerabilityOrder.Field.field))
	}

	var limit int
	if first != nil {
		limit = *first
	} else if last != nil {
		limit = *last
	}
	if limit > 0 {
		v = v.Limit(limit)
	}

	return v.All(ctx)
}
