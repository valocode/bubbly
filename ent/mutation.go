// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/valocode/bubbly/ent/adapter"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/cwe"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licenseuse"
	"github.com/valocode/bubbly/ent/predicate"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecomponent"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/releasevulnerability"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/valocode/bubbly/ent/vulnerabilityreview"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdapter              = "Adapter"
	TypeArtifact             = "Artifact"
	TypeCWE                  = "CWE"
	TypeCodeIssue            = "CodeIssue"
	TypeCodeScan             = "CodeScan"
	TypeComponent            = "Component"
	TypeGitCommit            = "GitCommit"
	TypeLicense              = "License"
	TypeLicenseUse           = "LicenseUse"
	TypeProject              = "Project"
	TypeRelease              = "Release"
	TypeReleaseComponent     = "ReleaseComponent"
	TypeReleaseEntry         = "ReleaseEntry"
	TypeReleaseVulnerability = "ReleaseVulnerability"
	TypeRepo                 = "Repo"
	TypeTestCase             = "TestCase"
	TypeTestRun              = "TestRun"
	TypeVulnerability        = "Vulnerability"
	TypeVulnerabilityReview  = "VulnerabilityReview"
)

// AdapterMutation represents an operation that mutates the Adapter nodes in the graph.
type AdapterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	tag           *string
	_type         *adapter.Type
	operation     *json.RawMessage
	results_type  *adapter.ResultsType
	results       *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Adapter, error)
	predicates    []predicate.Adapter
}

var _ ent.Mutation = (*AdapterMutation)(nil)

// adapterOption allows management of the mutation configuration using functional options.
type adapterOption func(*AdapterMutation)

// newAdapterMutation creates new mutation for the Adapter entity.
func newAdapterMutation(c config, op Op, opts ...adapterOption) *AdapterMutation {
	m := &AdapterMutation{
		config:        c,
		op:            op,
		typ:           TypeAdapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdapterID sets the ID field of the mutation.
func withAdapterID(id int) adapterOption {
	return func(m *AdapterMutation) {
		var (
			err   error
			once  sync.Once
			value *Adapter
		)
		m.oldValue = func(ctx context.Context) (*Adapter, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Adapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdapter sets the old Adapter of the mutation.
func withAdapter(node *Adapter) adapterOption {
	return func(m *AdapterMutation) {
		m.oldValue = func(context.Context) (*Adapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *AdapterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdapterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdapterMutation) ResetName() {
	m.name = nil
}

// SetTag sets the "tag" field.
func (m *AdapterMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *AdapterMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *AdapterMutation) ResetTag() {
	m.tag = nil
}

// SetType sets the "type" field.
func (m *AdapterMutation) SetType(a adapter.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AdapterMutation) GetType() (r adapter.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldType(ctx context.Context) (v adapter.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AdapterMutation) ResetType() {
	m._type = nil
}

// SetOperation sets the "operation" field.
func (m *AdapterMutation) SetOperation(jm json.RawMessage) {
	m.operation = &jm
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AdapterMutation) Operation() (r json.RawMessage, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldOperation(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ClearOperation clears the value of the "operation" field.
func (m *AdapterMutation) ClearOperation() {
	m.operation = nil
	m.clearedFields[adapter.FieldOperation] = struct{}{}
}

// OperationCleared returns if the "operation" field was cleared in this mutation.
func (m *AdapterMutation) OperationCleared() bool {
	_, ok := m.clearedFields[adapter.FieldOperation]
	return ok
}

// ResetOperation resets all changes to the "operation" field.
func (m *AdapterMutation) ResetOperation() {
	m.operation = nil
	delete(m.clearedFields, adapter.FieldOperation)
}

// SetResultsType sets the "results_type" field.
func (m *AdapterMutation) SetResultsType(at adapter.ResultsType) {
	m.results_type = &at
}

// ResultsType returns the value of the "results_type" field in the mutation.
func (m *AdapterMutation) ResultsType() (r adapter.ResultsType, exists bool) {
	v := m.results_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResultsType returns the old "results_type" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldResultsType(ctx context.Context) (v adapter.ResultsType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResultsType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResultsType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultsType: %w", err)
	}
	return oldValue.ResultsType, nil
}

// ResetResultsType resets all changes to the "results_type" field.
func (m *AdapterMutation) ResetResultsType() {
	m.results_type = nil
}

// SetResults sets the "results" field.
func (m *AdapterMutation) SetResults(b []byte) {
	m.results = &b
}

// Results returns the value of the "results" field in the mutation.
func (m *AdapterMutation) Results() (r []byte, exists bool) {
	v := m.results
	if v == nil {
		return
	}
	return *v, true
}

// OldResults returns the old "results" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldResults(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResults is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResults requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResults: %w", err)
	}
	return oldValue.Results, nil
}

// ResetResults resets all changes to the "results" field.
func (m *AdapterMutation) ResetResults() {
	m.results = nil
}

// Where appends a list predicates to the AdapterMutation builder.
func (m *AdapterMutation) Where(ps ...predicate.Adapter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdapterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Adapter).
func (m *AdapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdapterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, adapter.FieldName)
	}
	if m.tag != nil {
		fields = append(fields, adapter.FieldTag)
	}
	if m._type != nil {
		fields = append(fields, adapter.FieldType)
	}
	if m.operation != nil {
		fields = append(fields, adapter.FieldOperation)
	}
	if m.results_type != nil {
		fields = append(fields, adapter.FieldResultsType)
	}
	if m.results != nil {
		fields = append(fields, adapter.FieldResults)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adapter.FieldName:
		return m.Name()
	case adapter.FieldTag:
		return m.Tag()
	case adapter.FieldType:
		return m.GetType()
	case adapter.FieldOperation:
		return m.Operation()
	case adapter.FieldResultsType:
		return m.ResultsType()
	case adapter.FieldResults:
		return m.Results()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adapter.FieldName:
		return m.OldName(ctx)
	case adapter.FieldTag:
		return m.OldTag(ctx)
	case adapter.FieldType:
		return m.OldType(ctx)
	case adapter.FieldOperation:
		return m.OldOperation(ctx)
	case adapter.FieldResultsType:
		return m.OldResultsType(ctx)
	case adapter.FieldResults:
		return m.OldResults(ctx)
	}
	return nil, fmt.Errorf("unknown Adapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adapter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case adapter.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case adapter.FieldType:
		v, ok := value.(adapter.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case adapter.FieldOperation:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case adapter.FieldResultsType:
		v, ok := value.(adapter.ResultsType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultsType(v)
		return nil
	case adapter.FieldResults:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResults(v)
		return nil
	}
	return fmt.Errorf("unknown Adapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdapterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdapterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Adapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adapter.FieldOperation) {
		fields = append(fields, adapter.FieldOperation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdapterMutation) ClearField(name string) error {
	switch name {
	case adapter.FieldOperation:
		m.ClearOperation()
		return nil
	}
	return fmt.Errorf("unknown Adapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdapterMutation) ResetField(name string) error {
	switch name {
	case adapter.FieldName:
		m.ResetName()
		return nil
	case adapter.FieldTag:
		m.ResetTag()
		return nil
	case adapter.FieldType:
		m.ResetType()
		return nil
	case adapter.FieldOperation:
		m.ResetOperation()
		return nil
	case adapter.FieldResultsType:
		m.ResetResultsType()
		return nil
	case adapter.FieldResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown Adapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdapterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdapterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdapterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdapterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Adapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdapterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Adapter edge %s", name)
}

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	sha256         *string
	_type          *artifact.Type
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	entry          *int
	clearedentry   bool
	done           bool
	oldValue       func(context.Context) (*Artifact, error)
	predicates     []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ArtifactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtifactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtifactMutation) ResetName() {
	m.name = nil
}

// SetSha256 sets the "sha256" field.
func (m *ArtifactMutation) SetSha256(s string) {
	m.sha256 = &s
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *ArtifactMutation) Sha256() (r string, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *ArtifactMutation) ResetSha256() {
	m.sha256 = nil
}

// SetType sets the "type" field.
func (m *ArtifactMutation) SetType(a artifact.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *ArtifactMutation) GetType() (r artifact.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldType(ctx context.Context) (v artifact.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ArtifactMutation) ResetType() {
	m._type = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ArtifactMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ArtifactMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ArtifactMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ArtifactMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ArtifactMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *ArtifactMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *ArtifactMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *ArtifactMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *ArtifactMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *ArtifactMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, artifact.FieldName)
	}
	if m.sha256 != nil {
		fields = append(fields, artifact.FieldSha256)
	}
	if m._type != nil {
		fields = append(fields, artifact.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldName:
		return m.Name()
	case artifact.FieldSha256:
		return m.Sha256()
	case artifact.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldName:
		return m.OldName(ctx)
	case artifact.FieldSha256:
		return m.OldSha256(ctx)
	case artifact.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artifact.FieldSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case artifact.FieldType:
		v, ok := value.(artifact.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldName:
		m.ResetName()
		return nil
	case artifact.FieldSha256:
		m.ResetSha256()
		return nil
	case artifact.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.release != nil {
		edges = append(edges, artifact.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, artifact.EdgeEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrelease {
		edges = append(edges, artifact.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, artifact.EdgeEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeRelease:
		return m.clearedrelease
	case artifact.EdgeEntry:
		return m.clearedentry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	case artifact.EdgeRelease:
		m.ClearRelease()
		return nil
	case artifact.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeRelease:
		m.ResetRelease()
		return nil
	case artifact.EdgeEntry:
		m.ResetEntry()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// CWEMutation represents an operation that mutates the CWE nodes in the graph.
type CWEMutation struct {
	config
	op            Op
	typ           string
	id            *int
	cwe_id        *string
	description   *string
	url           *float64
	addurl        *float64
	clearedFields map[string]struct{}
	issues        map[int]struct{}
	removedissues map[int]struct{}
	clearedissues bool
	done          bool
	oldValue      func(context.Context) (*CWE, error)
	predicates    []predicate.CWE
}

var _ ent.Mutation = (*CWEMutation)(nil)

// cweOption allows management of the mutation configuration using functional options.
type cweOption func(*CWEMutation)

// newCWEMutation creates new mutation for the CWE entity.
func newCWEMutation(c config, op Op, opts ...cweOption) *CWEMutation {
	m := &CWEMutation{
		config:        c,
		op:            op,
		typ:           TypeCWE,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCWEID sets the ID field of the mutation.
func withCWEID(id int) cweOption {
	return func(m *CWEMutation) {
		var (
			err   error
			once  sync.Once
			value *CWE
		)
		m.oldValue = func(ctx context.Context) (*CWE, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CWE.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCWE sets the old CWE of the mutation.
func withCWE(node *CWE) cweOption {
	return func(m *CWEMutation) {
		m.oldValue = func(context.Context) (*CWE, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CWEMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CWEMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CWEMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCweID sets the "cwe_id" field.
func (m *CWEMutation) SetCweID(s string) {
	m.cwe_id = &s
}

// CweID returns the value of the "cwe_id" field in the mutation.
func (m *CWEMutation) CweID() (r string, exists bool) {
	v := m.cwe_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCweID returns the old "cwe_id" field's value of the CWE entity.
// If the CWE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CWEMutation) OldCweID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCweID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCweID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCweID: %w", err)
	}
	return oldValue.CweID, nil
}

// ResetCweID resets all changes to the "cwe_id" field.
func (m *CWEMutation) ResetCweID() {
	m.cwe_id = nil
}

// SetDescription sets the "description" field.
func (m *CWEMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CWEMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CWE entity.
// If the CWE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CWEMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CWEMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cwe.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CWEMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cwe.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CWEMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cwe.FieldDescription)
}

// SetURL sets the "url" field.
func (m *CWEMutation) SetURL(f float64) {
	m.url = &f
	m.addurl = nil
}

// URL returns the value of the "url" field in the mutation.
func (m *CWEMutation) URL() (r float64, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the CWE entity.
// If the CWE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CWEMutation) OldURL(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// AddURL adds f to the "url" field.
func (m *CWEMutation) AddURL(f float64) {
	if m.addurl != nil {
		*m.addurl += f
	} else {
		m.addurl = &f
	}
}

// AddedURL returns the value that was added to the "url" field in this mutation.
func (m *CWEMutation) AddedURL() (r float64, exists bool) {
	v := m.addurl
	if v == nil {
		return
	}
	return *v, true
}

// ClearURL clears the value of the "url" field.
func (m *CWEMutation) ClearURL() {
	m.url = nil
	m.addurl = nil
	m.clearedFields[cwe.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *CWEMutation) URLCleared() bool {
	_, ok := m.clearedFields[cwe.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *CWEMutation) ResetURL() {
	m.url = nil
	m.addurl = nil
	delete(m.clearedFields, cwe.FieldURL)
}

// AddIssueIDs adds the "issues" edge to the CodeIssue entity by ids.
func (m *CWEMutation) AddIssueIDs(ids ...int) {
	if m.issues == nil {
		m.issues = make(map[int]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the CodeIssue entity.
func (m *CWEMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the CodeIssue entity was cleared.
func (m *CWEMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the CodeIssue entity by IDs.
func (m *CWEMutation) RemoveIssueIDs(ids ...int) {
	if m.removedissues == nil {
		m.removedissues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the CodeIssue entity.
func (m *CWEMutation) RemovedIssuesIDs() (ids []int) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *CWEMutation) IssuesIDs() (ids []int) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *CWEMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// Where appends a list predicates to the CWEMutation builder.
func (m *CWEMutation) Where(ps ...predicate.CWE) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CWEMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CWE).
func (m *CWEMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CWEMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.cwe_id != nil {
		fields = append(fields, cwe.FieldCweID)
	}
	if m.description != nil {
		fields = append(fields, cwe.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, cwe.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CWEMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cwe.FieldCweID:
		return m.CweID()
	case cwe.FieldDescription:
		return m.Description()
	case cwe.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CWEMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cwe.FieldCweID:
		return m.OldCweID(ctx)
	case cwe.FieldDescription:
		return m.OldDescription(ctx)
	case cwe.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown CWE field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CWEMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cwe.FieldCweID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCweID(v)
		return nil
	case cwe.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cwe.FieldURL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown CWE field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CWEMutation) AddedFields() []string {
	var fields []string
	if m.addurl != nil {
		fields = append(fields, cwe.FieldURL)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CWEMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cwe.FieldURL:
		return m.AddedURL()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CWEMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cwe.FieldURL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddURL(v)
		return nil
	}
	return fmt.Errorf("unknown CWE numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CWEMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cwe.FieldDescription) {
		fields = append(fields, cwe.FieldDescription)
	}
	if m.FieldCleared(cwe.FieldURL) {
		fields = append(fields, cwe.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CWEMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CWEMutation) ClearField(name string) error {
	switch name {
	case cwe.FieldDescription:
		m.ClearDescription()
		return nil
	case cwe.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown CWE nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CWEMutation) ResetField(name string) error {
	switch name {
	case cwe.FieldCweID:
		m.ResetCweID()
		return nil
	case cwe.FieldDescription:
		m.ResetDescription()
		return nil
	case cwe.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown CWE field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CWEMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.issues != nil {
		edges = append(edges, cwe.EdgeIssues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CWEMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cwe.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CWEMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedissues != nil {
		edges = append(edges, cwe.EdgeIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CWEMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cwe.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CWEMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedissues {
		edges = append(edges, cwe.EdgeIssues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CWEMutation) EdgeCleared(name string) bool {
	switch name {
	case cwe.EdgeIssues:
		return m.clearedissues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CWEMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CWE unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CWEMutation) ResetEdge(name string) error {
	switch name {
	case cwe.EdgeIssues:
		m.ResetIssues()
		return nil
	}
	return fmt.Errorf("unknown CWE edge %s", name)
}

// CodeIssueMutation represents an operation that mutates the CodeIssue nodes in the graph.
type CodeIssueMutation struct {
	config
	op            Op
	typ           string
	id            *int
	rule_id       *string
	message       *string
	severity      *codeissue.Severity
	_type         *codeissue.Type
	clearedFields map[string]struct{}
	cwe           map[int]struct{}
	removedcwe    map[int]struct{}
	clearedcwe    bool
	scan          *int
	clearedscan   bool
	done          bool
	oldValue      func(context.Context) (*CodeIssue, error)
	predicates    []predicate.CodeIssue
}

var _ ent.Mutation = (*CodeIssueMutation)(nil)

// codeissueOption allows management of the mutation configuration using functional options.
type codeissueOption func(*CodeIssueMutation)

// newCodeIssueMutation creates new mutation for the CodeIssue entity.
func newCodeIssueMutation(c config, op Op, opts ...codeissueOption) *CodeIssueMutation {
	m := &CodeIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeIssueID sets the ID field of the mutation.
func withCodeIssueID(id int) codeissueOption {
	return func(m *CodeIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeIssue
		)
		m.oldValue = func(ctx context.Context) (*CodeIssue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeIssue sets the old CodeIssue of the mutation.
func withCodeIssue(node *CodeIssue) codeissueOption {
	return func(m *CodeIssueMutation) {
		m.oldValue = func(context.Context) (*CodeIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeIssueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRuleID sets the "rule_id" field.
func (m *CodeIssueMutation) SetRuleID(s string) {
	m.rule_id = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *CodeIssueMutation) RuleID() (r string, exists bool) {
	v := m.rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *CodeIssueMutation) ResetRuleID() {
	m.rule_id = nil
}

// SetMessage sets the "message" field.
func (m *CodeIssueMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CodeIssueMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CodeIssueMutation) ResetMessage() {
	m.message = nil
}

// SetSeverity sets the "severity" field.
func (m *CodeIssueMutation) SetSeverity(c codeissue.Severity) {
	m.severity = &c
}

// Severity returns the value of the "severity" field in the mutation.
func (m *CodeIssueMutation) Severity() (r codeissue.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldSeverity(ctx context.Context) (v codeissue.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *CodeIssueMutation) ResetSeverity() {
	m.severity = nil
}

// SetType sets the "type" field.
func (m *CodeIssueMutation) SetType(c codeissue.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CodeIssueMutation) GetType() (r codeissue.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldType(ctx context.Context) (v codeissue.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CodeIssueMutation) ResetType() {
	m._type = nil
}

// AddCweIDs adds the "cwe" edge to the CWE entity by ids.
func (m *CodeIssueMutation) AddCweIDs(ids ...int) {
	if m.cwe == nil {
		m.cwe = make(map[int]struct{})
	}
	for i := range ids {
		m.cwe[ids[i]] = struct{}{}
	}
}

// ClearCwe clears the "cwe" edge to the CWE entity.
func (m *CodeIssueMutation) ClearCwe() {
	m.clearedcwe = true
}

// CweCleared reports if the "cwe" edge to the CWE entity was cleared.
func (m *CodeIssueMutation) CweCleared() bool {
	return m.clearedcwe
}

// RemoveCweIDs removes the "cwe" edge to the CWE entity by IDs.
func (m *CodeIssueMutation) RemoveCweIDs(ids ...int) {
	if m.removedcwe == nil {
		m.removedcwe = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cwe, ids[i])
		m.removedcwe[ids[i]] = struct{}{}
	}
}

// RemovedCwe returns the removed IDs of the "cwe" edge to the CWE entity.
func (m *CodeIssueMutation) RemovedCweIDs() (ids []int) {
	for id := range m.removedcwe {
		ids = append(ids, id)
	}
	return
}

// CweIDs returns the "cwe" edge IDs in the mutation.
func (m *CodeIssueMutation) CweIDs() (ids []int) {
	for id := range m.cwe {
		ids = append(ids, id)
	}
	return
}

// ResetCwe resets all changes to the "cwe" edge.
func (m *CodeIssueMutation) ResetCwe() {
	m.cwe = nil
	m.clearedcwe = false
	m.removedcwe = nil
}

// SetScanID sets the "scan" edge to the CodeScan entity by id.
func (m *CodeIssueMutation) SetScanID(id int) {
	m.scan = &id
}

// ClearScan clears the "scan" edge to the CodeScan entity.
func (m *CodeIssueMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the CodeScan entity was cleared.
func (m *CodeIssueMutation) ScanCleared() bool {
	return m.clearedscan
}

// ScanID returns the "scan" edge ID in the mutation.
func (m *CodeIssueMutation) ScanID() (id int, exists bool) {
	if m.scan != nil {
		return *m.scan, true
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScanID instead. It exists only for internal usage by the builders.
func (m *CodeIssueMutation) ScanIDs() (ids []int) {
	if id := m.scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *CodeIssueMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
}

// Where appends a list predicates to the CodeIssueMutation builder.
func (m *CodeIssueMutation) Where(ps ...predicate.CodeIssue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodeIssueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodeIssue).
func (m *CodeIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeIssueMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.rule_id != nil {
		fields = append(fields, codeissue.FieldRuleID)
	}
	if m.message != nil {
		fields = append(fields, codeissue.FieldMessage)
	}
	if m.severity != nil {
		fields = append(fields, codeissue.FieldSeverity)
	}
	if m._type != nil {
		fields = append(fields, codeissue.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codeissue.FieldRuleID:
		return m.RuleID()
	case codeissue.FieldMessage:
		return m.Message()
	case codeissue.FieldSeverity:
		return m.Severity()
	case codeissue.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codeissue.FieldRuleID:
		return m.OldRuleID(ctx)
	case codeissue.FieldMessage:
		return m.OldMessage(ctx)
	case codeissue.FieldSeverity:
		return m.OldSeverity(ctx)
	case codeissue.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown CodeIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codeissue.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case codeissue.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case codeissue.FieldSeverity:
		v, ok := value.(codeissue.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case codeissue.FieldType:
		v, ok := value.(codeissue.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown CodeIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeIssueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeIssueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodeIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeIssueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeIssueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodeIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeIssueMutation) ResetField(name string) error {
	switch name {
	case codeissue.FieldRuleID:
		m.ResetRuleID()
		return nil
	case codeissue.FieldMessage:
		m.ResetMessage()
		return nil
	case codeissue.FieldSeverity:
		m.ResetSeverity()
		return nil
	case codeissue.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cwe != nil {
		edges = append(edges, codeissue.EdgeCwe)
	}
	if m.scan != nil {
		edges = append(edges, codeissue.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeIssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codeissue.EdgeCwe:
		ids := make([]ent.Value, 0, len(m.cwe))
		for id := range m.cwe {
			ids = append(ids, id)
		}
		return ids
	case codeissue.EdgeScan:
		if id := m.scan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcwe != nil {
		edges = append(edges, codeissue.EdgeCwe)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeIssueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case codeissue.EdgeCwe:
		ids := make([]ent.Value, 0, len(m.removedcwe))
		for id := range m.removedcwe {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcwe {
		edges = append(edges, codeissue.EdgeCwe)
	}
	if m.clearedscan {
		edges = append(edges, codeissue.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeIssueMutation) EdgeCleared(name string) bool {
	switch name {
	case codeissue.EdgeCwe:
		return m.clearedcwe
	case codeissue.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeIssueMutation) ClearEdge(name string) error {
	switch name {
	case codeissue.EdgeScan:
		m.ClearScan()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeIssueMutation) ResetEdge(name string) error {
	switch name {
	case codeissue.EdgeCwe:
		m.ResetCwe()
		return nil
	case codeissue.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue edge %s", name)
}

// CodeScanMutation represents an operation that mutates the CodeScan nodes in the graph.
type CodeScanMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	tool                   *string
	clearedFields          map[string]struct{}
	release                *int
	clearedrelease         bool
	entry                  *int
	clearedentry           bool
	issues                 map[int]struct{}
	removedissues          map[int]struct{}
	clearedissues          bool
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	components             map[int]struct{}
	removedcomponents      map[int]struct{}
	clearedcomponents      bool
	done                   bool
	oldValue               func(context.Context) (*CodeScan, error)
	predicates             []predicate.CodeScan
}

var _ ent.Mutation = (*CodeScanMutation)(nil)

// codescanOption allows management of the mutation configuration using functional options.
type codescanOption func(*CodeScanMutation)

// newCodeScanMutation creates new mutation for the CodeScan entity.
func newCodeScanMutation(c config, op Op, opts ...codescanOption) *CodeScanMutation {
	m := &CodeScanMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeScanID sets the ID field of the mutation.
func withCodeScanID(id int) codescanOption {
	return func(m *CodeScanMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeScan
		)
		m.oldValue = func(ctx context.Context) (*CodeScan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeScan sets the old CodeScan of the mutation.
func withCodeScan(node *CodeScan) codescanOption {
	return func(m *CodeScanMutation) {
		m.oldValue = func(context.Context) (*CodeScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *CodeScanMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *CodeScanMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the CodeScan entity.
// If the CodeScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeScanMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *CodeScanMutation) ResetTool() {
	m.tool = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *CodeScanMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *CodeScanMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *CodeScanMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *CodeScanMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *CodeScanMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *CodeScanMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *CodeScanMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *CodeScanMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *CodeScanMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *CodeScanMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *CodeScanMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *CodeScanMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// AddIssueIDs adds the "issues" edge to the CodeIssue entity by ids.
func (m *CodeScanMutation) AddIssueIDs(ids ...int) {
	if m.issues == nil {
		m.issues = make(map[int]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the CodeIssue entity.
func (m *CodeScanMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the CodeIssue entity was cleared.
func (m *CodeScanMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the CodeIssue entity by IDs.
func (m *CodeScanMutation) RemoveIssueIDs(ids ...int) {
	if m.removedissues == nil {
		m.removedissues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the CodeIssue entity.
func (m *CodeScanMutation) RemovedIssuesIDs() (ids []int) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *CodeScanMutation) IssuesIDs() (ids []int) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *CodeScanMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the ReleaseVulnerability entity by ids.
func (m *CodeScanMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *CodeScanMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the ReleaseVulnerability entity was cleared.
func (m *CodeScanMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the ReleaseVulnerability entity by IDs.
func (m *CodeScanMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *CodeScanMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *CodeScanMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *CodeScanMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddComponentIDs adds the "components" edge to the ReleaseComponent entity by ids.
func (m *CodeScanMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ReleaseComponent entity.
func (m *CodeScanMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ReleaseComponent entity was cleared.
func (m *CodeScanMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ReleaseComponent entity by IDs.
func (m *CodeScanMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ReleaseComponent entity.
func (m *CodeScanMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *CodeScanMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *CodeScanMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// Where appends a list predicates to the CodeScanMutation builder.
func (m *CodeScanMutation) Where(ps ...predicate.CodeScan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodeScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodeScan).
func (m *CodeScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeScanMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tool != nil {
		fields = append(fields, codescan.FieldTool)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codescan.FieldTool:
		return m.Tool()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codescan.FieldTool:
		return m.OldTool(ctx)
	}
	return nil, fmt.Errorf("unknown CodeScan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codescan.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	}
	return fmt.Errorf("unknown CodeScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodeScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeScanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeScanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodeScan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeScanMutation) ResetField(name string) error {
	switch name {
	case codescan.FieldTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown CodeScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.release != nil {
		edges = append(edges, codescan.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, codescan.EdgeEntry)
	}
	if m.issues != nil {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, codescan.EdgeVulnerabilities)
	}
	if m.components != nil {
		edges = append(edges, codescan.EdgeComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codescan.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case codescan.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case codescan.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedissues != nil {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, codescan.EdgeVulnerabilities)
	}
	if m.removedcomponents != nil {
		edges = append(edges, codescan.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case codescan.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrelease {
		edges = append(edges, codescan.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, codescan.EdgeEntry)
	}
	if m.clearedissues {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, codescan.EdgeVulnerabilities)
	}
	if m.clearedcomponents {
		edges = append(edges, codescan.EdgeComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeScanMutation) EdgeCleared(name string) bool {
	switch name {
	case codescan.EdgeRelease:
		return m.clearedrelease
	case codescan.EdgeEntry:
		return m.clearedentry
	case codescan.EdgeIssues:
		return m.clearedissues
	case codescan.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case codescan.EdgeComponents:
		return m.clearedcomponents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeScanMutation) ClearEdge(name string) error {
	switch name {
	case codescan.EdgeRelease:
		m.ClearRelease()
		return nil
	case codescan.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown CodeScan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeScanMutation) ResetEdge(name string) error {
	switch name {
	case codescan.EdgeRelease:
		m.ResetRelease()
		return nil
	case codescan.EdgeEntry:
		m.ResetEntry()
		return nil
	case codescan.EdgeIssues:
		m.ResetIssues()
		return nil
	case codescan.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case codescan.EdgeComponents:
		m.ResetComponents()
		return nil
	}
	return fmt.Errorf("unknown CodeScan edge %s", name)
}

// ComponentMutation represents an operation that mutates the Component nodes in the graph.
type ComponentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	vendor                 *string
	version                *string
	description            *string
	url                    *string
	clearedFields          map[string]struct{}
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	licenses               map[int]struct{}
	removedlicenses        map[int]struct{}
	clearedlicenses        bool
	uses                   map[int]struct{}
	removeduses            map[int]struct{}
	cleareduses            bool
	done                   bool
	oldValue               func(context.Context) (*Component, error)
	predicates             []predicate.Component
}

var _ ent.Mutation = (*ComponentMutation)(nil)

// componentOption allows management of the mutation configuration using functional options.
type componentOption func(*ComponentMutation)

// newComponentMutation creates new mutation for the Component entity.
func newComponentMutation(c config, op Op, opts ...componentOption) *ComponentMutation {
	m := &ComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComponentID sets the ID field of the mutation.
func withComponentID(id int) componentOption {
	return func(m *ComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *Component
		)
		m.oldValue = func(ctx context.Context) (*Component, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Component.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComponent sets the old Component of the mutation.
func withComponent(node *Component) componentOption {
	return func(m *ComponentMutation) {
		m.oldValue = func(context.Context) (*Component, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComponentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ComponentMutation) ResetName() {
	m.name = nil
}

// SetVendor sets the "vendor" field.
func (m *ComponentMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ComponentMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ComponentMutation) ResetVendor() {
	m.vendor = nil
}

// SetVersion sets the "version" field.
func (m *ComponentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ComponentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ComponentMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *ComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ComponentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[component.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ComponentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[component.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ComponentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, component.FieldDescription)
}

// SetURL sets the "url" field.
func (m *ComponentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ComponentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ComponentMutation) ClearURL() {
	m.url = nil
	m.clearedFields[component.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ComponentMutation) URLCleared() bool {
	_, ok := m.clearedFields[component.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ComponentMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, component.FieldURL)
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the Vulnerability entity by ids.
func (m *ComponentMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the Vulnerability entity.
func (m *ComponentMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the Vulnerability entity was cleared.
func (m *ComponentMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the Vulnerability entity by IDs.
func (m *ComponentMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the Vulnerability entity.
func (m *ComponentMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *ComponentMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *ComponentMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddLicenseIDs adds the "licenses" edge to the License entity by ids.
func (m *ComponentMutation) AddLicenseIDs(ids ...int) {
	if m.licenses == nil {
		m.licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.licenses[ids[i]] = struct{}{}
	}
}

// ClearLicenses clears the "licenses" edge to the License entity.
func (m *ComponentMutation) ClearLicenses() {
	m.clearedlicenses = true
}

// LicensesCleared reports if the "licenses" edge to the License entity was cleared.
func (m *ComponentMutation) LicensesCleared() bool {
	return m.clearedlicenses
}

// RemoveLicenseIDs removes the "licenses" edge to the License entity by IDs.
func (m *ComponentMutation) RemoveLicenseIDs(ids ...int) {
	if m.removedlicenses == nil {
		m.removedlicenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.licenses, ids[i])
		m.removedlicenses[ids[i]] = struct{}{}
	}
}

// RemovedLicenses returns the removed IDs of the "licenses" edge to the License entity.
func (m *ComponentMutation) RemovedLicensesIDs() (ids []int) {
	for id := range m.removedlicenses {
		ids = append(ids, id)
	}
	return
}

// LicensesIDs returns the "licenses" edge IDs in the mutation.
func (m *ComponentMutation) LicensesIDs() (ids []int) {
	for id := range m.licenses {
		ids = append(ids, id)
	}
	return
}

// ResetLicenses resets all changes to the "licenses" edge.
func (m *ComponentMutation) ResetLicenses() {
	m.licenses = nil
	m.clearedlicenses = false
	m.removedlicenses = nil
}

// AddUseIDs adds the "uses" edge to the ReleaseComponent entity by ids.
func (m *ComponentMutation) AddUseIDs(ids ...int) {
	if m.uses == nil {
		m.uses = make(map[int]struct{})
	}
	for i := range ids {
		m.uses[ids[i]] = struct{}{}
	}
}

// ClearUses clears the "uses" edge to the ReleaseComponent entity.
func (m *ComponentMutation) ClearUses() {
	m.cleareduses = true
}

// UsesCleared reports if the "uses" edge to the ReleaseComponent entity was cleared.
func (m *ComponentMutation) UsesCleared() bool {
	return m.cleareduses
}

// RemoveUseIDs removes the "uses" edge to the ReleaseComponent entity by IDs.
func (m *ComponentMutation) RemoveUseIDs(ids ...int) {
	if m.removeduses == nil {
		m.removeduses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.uses, ids[i])
		m.removeduses[ids[i]] = struct{}{}
	}
}

// RemovedUses returns the removed IDs of the "uses" edge to the ReleaseComponent entity.
func (m *ComponentMutation) RemovedUsesIDs() (ids []int) {
	for id := range m.removeduses {
		ids = append(ids, id)
	}
	return
}

// UsesIDs returns the "uses" edge IDs in the mutation.
func (m *ComponentMutation) UsesIDs() (ids []int) {
	for id := range m.uses {
		ids = append(ids, id)
	}
	return
}

// ResetUses resets all changes to the "uses" edge.
func (m *ComponentMutation) ResetUses() {
	m.uses = nil
	m.cleareduses = false
	m.removeduses = nil
}

// Where appends a list predicates to the ComponentMutation builder.
func (m *ComponentMutation) Where(ps ...predicate.Component) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ComponentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Component).
func (m *ComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComponentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, component.FieldName)
	}
	if m.vendor != nil {
		fields = append(fields, component.FieldVendor)
	}
	if m.version != nil {
		fields = append(fields, component.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, component.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, component.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case component.FieldName:
		return m.Name()
	case component.FieldVendor:
		return m.Vendor()
	case component.FieldVersion:
		return m.Version()
	case component.FieldDescription:
		return m.Description()
	case component.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case component.FieldName:
		return m.OldName(ctx)
	case component.FieldVendor:
		return m.OldVendor(ctx)
	case component.FieldVersion:
		return m.OldVersion(ctx)
	case component.FieldDescription:
		return m.OldDescription(ctx)
	case component.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Component field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case component.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case component.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case component.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case component.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case component.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Component numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(component.FieldDescription) {
		fields = append(fields, component.FieldDescription)
	}
	if m.FieldCleared(component.FieldURL) {
		fields = append(fields, component.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComponentMutation) ClearField(name string) error {
	switch name {
	case component.FieldDescription:
		m.ClearDescription()
		return nil
	case component.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Component nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComponentMutation) ResetField(name string) error {
	switch name {
	case component.FieldName:
		m.ResetName()
		return nil
	case component.FieldVendor:
		m.ResetVendor()
		return nil
	case component.FieldVersion:
		m.ResetVersion()
		return nil
	case component.FieldDescription:
		m.ResetDescription()
		return nil
	case component.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.vulnerabilities != nil {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.licenses != nil {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.uses != nil {
		edges = append(edges, component.EdgeUses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.licenses))
		for id := range m.licenses {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeUses:
		ids := make([]ent.Value, 0, len(m.uses))
		for id := range m.uses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvulnerabilities != nil {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.removedlicenses != nil {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.removeduses != nil {
		edges = append(edges, component.EdgeUses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.removedlicenses))
		for id := range m.removedlicenses {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeUses:
		ids := make([]ent.Value, 0, len(m.removeduses))
		for id := range m.removeduses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedvulnerabilities {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.clearedlicenses {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.cleareduses {
		edges = append(edges, component.EdgeUses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case component.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case component.EdgeLicenses:
		return m.clearedlicenses
	case component.EdgeUses:
		return m.cleareduses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComponentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Component unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComponentMutation) ResetEdge(name string) error {
	switch name {
	case component.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case component.EdgeLicenses:
		m.ResetLicenses()
		return nil
	case component.EdgeUses:
		m.ResetUses()
		return nil
	}
	return fmt.Errorf("unknown Component edge %s", name)
}

// GitCommitMutation represents an operation that mutates the GitCommit nodes in the graph.
type GitCommitMutation struct {
	config
	op             Op
	typ            string
	id             *int
	hash           *string
	branch         *string
	tag            *string
	time           *time.Time
	clearedFields  map[string]struct{}
	repo           *int
	clearedrepo    bool
	release        *int
	clearedrelease bool
	done           bool
	oldValue       func(context.Context) (*GitCommit, error)
	predicates     []predicate.GitCommit
}

var _ ent.Mutation = (*GitCommitMutation)(nil)

// gitcommitOption allows management of the mutation configuration using functional options.
type gitcommitOption func(*GitCommitMutation)

// newGitCommitMutation creates new mutation for the GitCommit entity.
func newGitCommitMutation(c config, op Op, opts ...gitcommitOption) *GitCommitMutation {
	m := &GitCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeGitCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitCommitID sets the ID field of the mutation.
func withGitCommitID(id int) gitcommitOption {
	return func(m *GitCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *GitCommit
		)
		m.oldValue = func(ctx context.Context) (*GitCommit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitCommit sets the old GitCommit of the mutation.
func withGitCommit(node *GitCommit) gitcommitOption {
	return func(m *GitCommitMutation) {
		m.oldValue = func(context.Context) (*GitCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitCommitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHash sets the "hash" field.
func (m *GitCommitMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *GitCommitMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *GitCommitMutation) ResetHash() {
	m.hash = nil
}

// SetBranch sets the "branch" field.
func (m *GitCommitMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *GitCommitMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *GitCommitMutation) ResetBranch() {
	m.branch = nil
}

// SetTag sets the "tag" field.
func (m *GitCommitMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *GitCommitMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *GitCommitMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[gitcommit.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *GitCommitMutation) TagCleared() bool {
	_, ok := m.clearedFields[gitcommit.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *GitCommitMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, gitcommit.FieldTag)
}

// SetTime sets the "time" field.
func (m *GitCommitMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *GitCommitMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *GitCommitMutation) ResetTime() {
	m.time = nil
}

// SetRepoID sets the "repo" edge to the Repo entity by id.
func (m *GitCommitMutation) SetRepoID(id int) {
	m.repo = &id
}

// ClearRepo clears the "repo" edge to the Repo entity.
func (m *GitCommitMutation) ClearRepo() {
	m.clearedrepo = true
}

// RepoCleared reports if the "repo" edge to the Repo entity was cleared.
func (m *GitCommitMutation) RepoCleared() bool {
	return m.clearedrepo
}

// RepoID returns the "repo" edge ID in the mutation.
func (m *GitCommitMutation) RepoID() (id int, exists bool) {
	if m.repo != nil {
		return *m.repo, true
	}
	return
}

// RepoIDs returns the "repo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepoID instead. It exists only for internal usage by the builders.
func (m *GitCommitMutation) RepoIDs() (ids []int) {
	if id := m.repo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepo resets all changes to the "repo" edge.
func (m *GitCommitMutation) ResetRepo() {
	m.repo = nil
	m.clearedrepo = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *GitCommitMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *GitCommitMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *GitCommitMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *GitCommitMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *GitCommitMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *GitCommitMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Where appends a list predicates to the GitCommitMutation builder.
func (m *GitCommitMutation) Where(ps ...predicate.GitCommit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GitCommitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GitCommit).
func (m *GitCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitCommitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.hash != nil {
		fields = append(fields, gitcommit.FieldHash)
	}
	if m.branch != nil {
		fields = append(fields, gitcommit.FieldBranch)
	}
	if m.tag != nil {
		fields = append(fields, gitcommit.FieldTag)
	}
	if m.time != nil {
		fields = append(fields, gitcommit.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gitcommit.FieldHash:
		return m.Hash()
	case gitcommit.FieldBranch:
		return m.Branch()
	case gitcommit.FieldTag:
		return m.Tag()
	case gitcommit.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gitcommit.FieldHash:
		return m.OldHash(ctx)
	case gitcommit.FieldBranch:
		return m.OldBranch(ctx)
	case gitcommit.FieldTag:
		return m.OldTag(ctx)
	case gitcommit.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown GitCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gitcommit.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case gitcommit.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case gitcommit.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case gitcommit.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitCommitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitCommitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GitCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitCommitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gitcommit.FieldTag) {
		fields = append(fields, gitcommit.FieldTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitCommitMutation) ClearField(name string) error {
	switch name {
	case gitcommit.FieldTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown GitCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitCommitMutation) ResetField(name string) error {
	switch name {
	case gitcommit.FieldHash:
		m.ResetHash()
		return nil
	case gitcommit.FieldBranch:
		m.ResetBranch()
		return nil
	case gitcommit.FieldTag:
		m.ResetTag()
		return nil
	case gitcommit.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repo != nil {
		edges = append(edges, gitcommit.EdgeRepo)
	}
	if m.release != nil {
		edges = append(edges, gitcommit.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gitcommit.EdgeRepo:
		if id := m.repo; id != nil {
			return []ent.Value{*id}
		}
	case gitcommit.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepo {
		edges = append(edges, gitcommit.EdgeRepo)
	}
	if m.clearedrelease {
		edges = append(edges, gitcommit.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case gitcommit.EdgeRepo:
		return m.clearedrepo
	case gitcommit.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitCommitMutation) ClearEdge(name string) error {
	switch name {
	case gitcommit.EdgeRepo:
		m.ClearRepo()
		return nil
	case gitcommit.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown GitCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitCommitMutation) ResetEdge(name string) error {
	switch name {
	case gitcommit.EdgeRepo:
		m.ResetRepo()
		return nil
	case gitcommit.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown GitCommit edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                Op
	typ               string
	id                *int
	spdx_id           *string
	name              *string
	reference         *string
	details_url       *string
	is_osi_approved   *bool
	clearedFields     map[string]struct{}
	components        map[int]struct{}
	removedcomponents map[int]struct{}
	clearedcomponents bool
	uses              map[int]struct{}
	removeduses       map[int]struct{}
	cleareduses       bool
	done              bool
	oldValue          func(context.Context) (*License, error)
	predicates        []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id int) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSpdxID sets the "spdx_id" field.
func (m *LicenseMutation) SetSpdxID(s string) {
	m.spdx_id = &s
}

// SpdxID returns the value of the "spdx_id" field in the mutation.
func (m *LicenseMutation) SpdxID() (r string, exists bool) {
	v := m.spdx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpdxID returns the old "spdx_id" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldSpdxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpdxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpdxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpdxID: %w", err)
	}
	return oldValue.SpdxID, nil
}

// ResetSpdxID resets all changes to the "spdx_id" field.
func (m *LicenseMutation) ResetSpdxID() {
	m.spdx_id = nil
}

// SetName sets the "name" field.
func (m *LicenseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LicenseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LicenseMutation) ResetName() {
	m.name = nil
}

// SetReference sets the "reference" field.
func (m *LicenseMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *LicenseMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *LicenseMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[license.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *LicenseMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[license.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *LicenseMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, license.FieldReference)
}

// SetDetailsURL sets the "details_url" field.
func (m *LicenseMutation) SetDetailsURL(s string) {
	m.details_url = &s
}

// DetailsURL returns the value of the "details_url" field in the mutation.
func (m *LicenseMutation) DetailsURL() (r string, exists bool) {
	v := m.details_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailsURL returns the old "details_url" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldDetailsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailsURL: %w", err)
	}
	return oldValue.DetailsURL, nil
}

// ClearDetailsURL clears the value of the "details_url" field.
func (m *LicenseMutation) ClearDetailsURL() {
	m.details_url = nil
	m.clearedFields[license.FieldDetailsURL] = struct{}{}
}

// DetailsURLCleared returns if the "details_url" field was cleared in this mutation.
func (m *LicenseMutation) DetailsURLCleared() bool {
	_, ok := m.clearedFields[license.FieldDetailsURL]
	return ok
}

// ResetDetailsURL resets all changes to the "details_url" field.
func (m *LicenseMutation) ResetDetailsURL() {
	m.details_url = nil
	delete(m.clearedFields, license.FieldDetailsURL)
}

// SetIsOsiApproved sets the "is_osi_approved" field.
func (m *LicenseMutation) SetIsOsiApproved(b bool) {
	m.is_osi_approved = &b
}

// IsOsiApproved returns the value of the "is_osi_approved" field in the mutation.
func (m *LicenseMutation) IsOsiApproved() (r bool, exists bool) {
	v := m.is_osi_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOsiApproved returns the old "is_osi_approved" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldIsOsiApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsOsiApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsOsiApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOsiApproved: %w", err)
	}
	return oldValue.IsOsiApproved, nil
}

// ResetIsOsiApproved resets all changes to the "is_osi_approved" field.
func (m *LicenseMutation) ResetIsOsiApproved() {
	m.is_osi_approved = nil
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *LicenseMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *LicenseMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *LicenseMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *LicenseMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *LicenseMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *LicenseMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *LicenseMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddUseIDs adds the "uses" edge to the LicenseUse entity by ids.
func (m *LicenseMutation) AddUseIDs(ids ...int) {
	if m.uses == nil {
		m.uses = make(map[int]struct{})
	}
	for i := range ids {
		m.uses[ids[i]] = struct{}{}
	}
}

// ClearUses clears the "uses" edge to the LicenseUse entity.
func (m *LicenseMutation) ClearUses() {
	m.cleareduses = true
}

// UsesCleared reports if the "uses" edge to the LicenseUse entity was cleared.
func (m *LicenseMutation) UsesCleared() bool {
	return m.cleareduses
}

// RemoveUseIDs removes the "uses" edge to the LicenseUse entity by IDs.
func (m *LicenseMutation) RemoveUseIDs(ids ...int) {
	if m.removeduses == nil {
		m.removeduses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.uses, ids[i])
		m.removeduses[ids[i]] = struct{}{}
	}
}

// RemovedUses returns the removed IDs of the "uses" edge to the LicenseUse entity.
func (m *LicenseMutation) RemovedUsesIDs() (ids []int) {
	for id := range m.removeduses {
		ids = append(ids, id)
	}
	return
}

// UsesIDs returns the "uses" edge IDs in the mutation.
func (m *LicenseMutation) UsesIDs() (ids []int) {
	for id := range m.uses {
		ids = append(ids, id)
	}
	return
}

// ResetUses resets all changes to the "uses" edge.
func (m *LicenseMutation) ResetUses() {
	m.uses = nil
	m.cleareduses = false
	m.removeduses = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.spdx_id != nil {
		fields = append(fields, license.FieldSpdxID)
	}
	if m.name != nil {
		fields = append(fields, license.FieldName)
	}
	if m.reference != nil {
		fields = append(fields, license.FieldReference)
	}
	if m.details_url != nil {
		fields = append(fields, license.FieldDetailsURL)
	}
	if m.is_osi_approved != nil {
		fields = append(fields, license.FieldIsOsiApproved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldSpdxID:
		return m.SpdxID()
	case license.FieldName:
		return m.Name()
	case license.FieldReference:
		return m.Reference()
	case license.FieldDetailsURL:
		return m.DetailsURL()
	case license.FieldIsOsiApproved:
		return m.IsOsiApproved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldSpdxID:
		return m.OldSpdxID(ctx)
	case license.FieldName:
		return m.OldName(ctx)
	case license.FieldReference:
		return m.OldReference(ctx)
	case license.FieldDetailsURL:
		return m.OldDetailsURL(ctx)
	case license.FieldIsOsiApproved:
		return m.OldIsOsiApproved(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldSpdxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpdxID(v)
		return nil
	case license.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case license.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case license.FieldDetailsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailsURL(v)
		return nil
	case license.FieldIsOsiApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOsiApproved(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldReference) {
		fields = append(fields, license.FieldReference)
	}
	if m.FieldCleared(license.FieldDetailsURL) {
		fields = append(fields, license.FieldDetailsURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldReference:
		m.ClearReference()
		return nil
	case license.FieldDetailsURL:
		m.ClearDetailsURL()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldSpdxID:
		m.ResetSpdxID()
		return nil
	case license.FieldName:
		m.ResetName()
		return nil
	case license.FieldReference:
		m.ResetReference()
		return nil
	case license.FieldDetailsURL:
		m.ResetDetailsURL()
		return nil
	case license.FieldIsOsiApproved:
		m.ResetIsOsiApproved()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.components != nil {
		edges = append(edges, license.EdgeComponents)
	}
	if m.uses != nil {
		edges = append(edges, license.EdgeUses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeUses:
		ids := make([]ent.Value, 0, len(m.uses))
		for id := range m.uses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomponents != nil {
		edges = append(edges, license.EdgeComponents)
	}
	if m.removeduses != nil {
		edges = append(edges, license.EdgeUses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeUses:
		ids := make([]ent.Value, 0, len(m.removeduses))
		for id := range m.removeduses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomponents {
		edges = append(edges, license.EdgeComponents)
	}
	if m.cleareduses {
		edges = append(edges, license.EdgeUses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeComponents:
		return m.clearedcomponents
	case license.EdgeUses:
		return m.cleareduses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeComponents:
		m.ResetComponents()
		return nil
	case license.EdgeUses:
		m.ResetUses()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// LicenseUseMutation represents an operation that mutates the LicenseUse nodes in the graph.
type LicenseUseMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	license        *int
	clearedlicense bool
	done           bool
	oldValue       func(context.Context) (*LicenseUse, error)
	predicates     []predicate.LicenseUse
}

var _ ent.Mutation = (*LicenseUseMutation)(nil)

// licenseuseOption allows management of the mutation configuration using functional options.
type licenseuseOption func(*LicenseUseMutation)

// newLicenseUseMutation creates new mutation for the LicenseUse entity.
func newLicenseUseMutation(c config, op Op, opts ...licenseuseOption) *LicenseUseMutation {
	m := &LicenseUseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicenseUse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseUseID sets the ID field of the mutation.
func withLicenseUseID(id int) licenseuseOption {
	return func(m *LicenseUseMutation) {
		var (
			err   error
			once  sync.Once
			value *LicenseUse
		)
		m.oldValue = func(ctx context.Context) (*LicenseUse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LicenseUse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicenseUse sets the old LicenseUse of the mutation.
func withLicenseUse(node *LicenseUse) licenseuseOption {
	return func(m *LicenseUseMutation) {
		m.oldValue = func(context.Context) (*LicenseUse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseUseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseUseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseUseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLicenseID sets the "license" edge to the License entity by id.
func (m *LicenseUseMutation) SetLicenseID(id int) {
	m.license = &id
}

// ClearLicense clears the "license" edge to the License entity.
func (m *LicenseUseMutation) ClearLicense() {
	m.clearedlicense = true
}

// LicenseCleared reports if the "license" edge to the License entity was cleared.
func (m *LicenseUseMutation) LicenseCleared() bool {
	return m.clearedlicense
}

// LicenseID returns the "license" edge ID in the mutation.
func (m *LicenseUseMutation) LicenseID() (id int, exists bool) {
	if m.license != nil {
		return *m.license, true
	}
	return
}

// LicenseIDs returns the "license" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *LicenseUseMutation) LicenseIDs() (ids []int) {
	if id := m.license; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "license" edge.
func (m *LicenseUseMutation) ResetLicense() {
	m.license = nil
	m.clearedlicense = false
}

// Where appends a list predicates to the LicenseUseMutation builder.
func (m *LicenseUseMutation) Where(ps ...predicate.LicenseUse) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LicenseUseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LicenseUse).
func (m *LicenseUseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseUseMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseUseMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseUseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown LicenseUse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseUseMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LicenseUse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseUseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseUseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseUseMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown LicenseUse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseUseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseUseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseUseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LicenseUse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseUseMutation) ResetField(name string) error {
	return fmt.Errorf("unknown LicenseUse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseUseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.license != nil {
		edges = append(edges, licenseuse.EdgeLicense)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseUseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case licenseuse.EdgeLicense:
		if id := m.license; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseUseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseUseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseUseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlicense {
		edges = append(edges, licenseuse.EdgeLicense)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseUseMutation) EdgeCleared(name string) bool {
	switch name {
	case licenseuse.EdgeLicense:
		return m.clearedlicense
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseUseMutation) ClearEdge(name string) error {
	switch name {
	case licenseuse.EdgeLicense:
		m.ClearLicense()
		return nil
	}
	return fmt.Errorf("unknown LicenseUse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseUseMutation) ResetEdge(name string) error {
	switch name {
	case licenseuse.EdgeLicense:
		m.ResetLicense()
		return nil
	}
	return fmt.Errorf("unknown LicenseUse edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	clearedFields                map[string]struct{}
	repos                        map[int]struct{}
	removedrepos                 map[int]struct{}
	clearedrepos                 bool
	vulnerability_reviews        map[int]struct{}
	removedvulnerability_reviews map[int]struct{}
	clearedvulnerability_reviews bool
	done                         bool
	oldValue                     func(context.Context) (*Project, error)
	predicates                   []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// AddRepoIDs adds the "repos" edge to the Repo entity by ids.
func (m *ProjectMutation) AddRepoIDs(ids ...int) {
	if m.repos == nil {
		m.repos = make(map[int]struct{})
	}
	for i := range ids {
		m.repos[ids[i]] = struct{}{}
	}
}

// ClearRepos clears the "repos" edge to the Repo entity.
func (m *ProjectMutation) ClearRepos() {
	m.clearedrepos = true
}

// ReposCleared reports if the "repos" edge to the Repo entity was cleared.
func (m *ProjectMutation) ReposCleared() bool {
	return m.clearedrepos
}

// RemoveRepoIDs removes the "repos" edge to the Repo entity by IDs.
func (m *ProjectMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepos == nil {
		m.removedrepos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repos, ids[i])
		m.removedrepos[ids[i]] = struct{}{}
	}
}

// RemovedRepos returns the removed IDs of the "repos" edge to the Repo entity.
func (m *ProjectMutation) RemovedReposIDs() (ids []int) {
	for id := range m.removedrepos {
		ids = append(ids, id)
	}
	return
}

// ReposIDs returns the "repos" edge IDs in the mutation.
func (m *ProjectMutation) ReposIDs() (ids []int) {
	for id := range m.repos {
		ids = append(ids, id)
	}
	return
}

// ResetRepos resets all changes to the "repos" edge.
func (m *ProjectMutation) ResetRepos() {
	m.repos = nil
	m.clearedrepos = false
	m.removedrepos = nil
}

// AddVulnerabilityReviewIDs adds the "vulnerability_reviews" edge to the VulnerabilityReview entity by ids.
func (m *ProjectMutation) AddVulnerabilityReviewIDs(ids ...int) {
	if m.vulnerability_reviews == nil {
		m.vulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_reviews[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityReviews clears the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ProjectMutation) ClearVulnerabilityReviews() {
	m.clearedvulnerability_reviews = true
}

// VulnerabilityReviewsCleared reports if the "vulnerability_reviews" edge to the VulnerabilityReview entity was cleared.
func (m *ProjectMutation) VulnerabilityReviewsCleared() bool {
	return m.clearedvulnerability_reviews
}

// RemoveVulnerabilityReviewIDs removes the "vulnerability_reviews" edge to the VulnerabilityReview entity by IDs.
func (m *ProjectMutation) RemoveVulnerabilityReviewIDs(ids ...int) {
	if m.removedvulnerability_reviews == nil {
		m.removedvulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_reviews, ids[i])
		m.removedvulnerability_reviews[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityReviews returns the removed IDs of the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ProjectMutation) RemovedVulnerabilityReviewsIDs() (ids []int) {
	for id := range m.removedvulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityReviewsIDs returns the "vulnerability_reviews" edge IDs in the mutation.
func (m *ProjectMutation) VulnerabilityReviewsIDs() (ids []int) {
	for id := range m.vulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityReviews resets all changes to the "vulnerability_reviews" edge.
func (m *ProjectMutation) ResetVulnerabilityReviews() {
	m.vulnerability_reviews = nil
	m.clearedvulnerability_reviews = false
	m.removedvulnerability_reviews = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repos != nil {
		edges = append(edges, project.EdgeRepos)
	}
	if m.vulnerability_reviews != nil {
		edges = append(edges, project.EdgeVulnerabilityReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.repos))
		for id := range m.repos {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.vulnerability_reviews))
		for id := range m.vulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrepos != nil {
		edges = append(edges, project.EdgeRepos)
	}
	if m.removedvulnerability_reviews != nil {
		edges = append(edges, project.EdgeVulnerabilityReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.removedrepos))
		for id := range m.removedrepos {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_reviews))
		for id := range m.removedvulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepos {
		edges = append(edges, project.EdgeRepos)
	}
	if m.clearedvulnerability_reviews {
		edges = append(edges, project.EdgeVulnerabilityReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeRepos:
		return m.clearedrepos
	case project.EdgeVulnerabilityReviews:
		return m.clearedvulnerability_reviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeRepos:
		m.ResetRepos()
		return nil
	case project.EdgeVulnerabilityReviews:
		m.ResetVulnerabilityReviews()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ReleaseMutation represents an operation that mutates the Release nodes in the graph.
type ReleaseMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	version                      *string
	status                       *release.Status
	clearedFields                map[string]struct{}
	subreleases                  map[int]struct{}
	removedsubreleases           map[int]struct{}
	clearedsubreleases           bool
	dependencies                 map[int]struct{}
	removeddependencies          map[int]struct{}
	cleareddependencies          bool
	commit                       *int
	clearedcommit                bool
	log                          map[int]struct{}
	removedlog                   map[int]struct{}
	clearedlog                   bool
	artifacts                    map[int]struct{}
	removedartifacts             map[int]struct{}
	clearedartifacts             bool
	components                   map[int]struct{}
	removedcomponents            map[int]struct{}
	clearedcomponents            bool
	vulnerabilities              map[int]struct{}
	removedvulnerabilities       map[int]struct{}
	clearedvulnerabilities       bool
	code_scans                   map[int]struct{}
	removedcode_scans            map[int]struct{}
	clearedcode_scans            bool
	test_runs                    map[int]struct{}
	removedtest_runs             map[int]struct{}
	clearedtest_runs             bool
	vulnerability_reviews        map[int]struct{}
	removedvulnerability_reviews map[int]struct{}
	clearedvulnerability_reviews bool
	done                         bool
	oldValue                     func(context.Context) (*Release, error)
	predicates                   []predicate.Release
}

var _ ent.Mutation = (*ReleaseMutation)(nil)

// releaseOption allows management of the mutation configuration using functional options.
type releaseOption func(*ReleaseMutation)

// newReleaseMutation creates new mutation for the Release entity.
func newReleaseMutation(c config, op Op, opts ...releaseOption) *ReleaseMutation {
	m := &ReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseID sets the ID field of the mutation.
func withReleaseID(id int) releaseOption {
	return func(m *ReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Release
		)
		m.oldValue = func(ctx context.Context) (*Release, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Release.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelease sets the old Release of the mutation.
func withRelease(node *Release) releaseOption {
	return func(m *ReleaseMutation) {
		m.oldValue = func(context.Context) (*Release, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ReleaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReleaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReleaseMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *ReleaseMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ReleaseMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ReleaseMutation) ResetVersion() {
	m.version = nil
}

// SetStatus sets the "status" field.
func (m *ReleaseMutation) SetStatus(r release.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReleaseMutation) Status() (r release.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldStatus(ctx context.Context) (v release.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReleaseMutation) ResetStatus() {
	m.status = nil
}

// AddSubreleaseIDs adds the "subreleases" edge to the Release entity by ids.
func (m *ReleaseMutation) AddSubreleaseIDs(ids ...int) {
	if m.subreleases == nil {
		m.subreleases = make(map[int]struct{})
	}
	for i := range ids {
		m.subreleases[ids[i]] = struct{}{}
	}
}

// ClearSubreleases clears the "subreleases" edge to the Release entity.
func (m *ReleaseMutation) ClearSubreleases() {
	m.clearedsubreleases = true
}

// SubreleasesCleared reports if the "subreleases" edge to the Release entity was cleared.
func (m *ReleaseMutation) SubreleasesCleared() bool {
	return m.clearedsubreleases
}

// RemoveSubreleaseIDs removes the "subreleases" edge to the Release entity by IDs.
func (m *ReleaseMutation) RemoveSubreleaseIDs(ids ...int) {
	if m.removedsubreleases == nil {
		m.removedsubreleases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subreleases, ids[i])
		m.removedsubreleases[ids[i]] = struct{}{}
	}
}

// RemovedSubreleases returns the removed IDs of the "subreleases" edge to the Release entity.
func (m *ReleaseMutation) RemovedSubreleasesIDs() (ids []int) {
	for id := range m.removedsubreleases {
		ids = append(ids, id)
	}
	return
}

// SubreleasesIDs returns the "subreleases" edge IDs in the mutation.
func (m *ReleaseMutation) SubreleasesIDs() (ids []int) {
	for id := range m.subreleases {
		ids = append(ids, id)
	}
	return
}

// ResetSubreleases resets all changes to the "subreleases" edge.
func (m *ReleaseMutation) ResetSubreleases() {
	m.subreleases = nil
	m.clearedsubreleases = false
	m.removedsubreleases = nil
}

// AddDependencyIDs adds the "dependencies" edge to the Release entity by ids.
func (m *ReleaseMutation) AddDependencyIDs(ids ...int) {
	if m.dependencies == nil {
		m.dependencies = make(map[int]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the Release entity.
func (m *ReleaseMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the Release entity was cleared.
func (m *ReleaseMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the Release entity by IDs.
func (m *ReleaseMutation) RemoveDependencyIDs(ids ...int) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the Release entity.
func (m *ReleaseMutation) RemovedDependenciesIDs() (ids []int) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ReleaseMutation) DependenciesIDs() (ids []int) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ReleaseMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// SetCommitID sets the "commit" edge to the GitCommit entity by id.
func (m *ReleaseMutation) SetCommitID(id int) {
	m.commit = &id
}

// ClearCommit clears the "commit" edge to the GitCommit entity.
func (m *ReleaseMutation) ClearCommit() {
	m.clearedcommit = true
}

// CommitCleared reports if the "commit" edge to the GitCommit entity was cleared.
func (m *ReleaseMutation) CommitCleared() bool {
	return m.clearedcommit
}

// CommitID returns the "commit" edge ID in the mutation.
func (m *ReleaseMutation) CommitID() (id int, exists bool) {
	if m.commit != nil {
		return *m.commit, true
	}
	return
}

// CommitIDs returns the "commit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommitID instead. It exists only for internal usage by the builders.
func (m *ReleaseMutation) CommitIDs() (ids []int) {
	if id := m.commit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommit resets all changes to the "commit" edge.
func (m *ReleaseMutation) ResetCommit() {
	m.commit = nil
	m.clearedcommit = false
}

// AddLogIDs adds the "log" edge to the ReleaseEntry entity by ids.
func (m *ReleaseMutation) AddLogIDs(ids ...int) {
	if m.log == nil {
		m.log = make(map[int]struct{})
	}
	for i := range ids {
		m.log[ids[i]] = struct{}{}
	}
}

// ClearLog clears the "log" edge to the ReleaseEntry entity.
func (m *ReleaseMutation) ClearLog() {
	m.clearedlog = true
}

// LogCleared reports if the "log" edge to the ReleaseEntry entity was cleared.
func (m *ReleaseMutation) LogCleared() bool {
	return m.clearedlog
}

// RemoveLogIDs removes the "log" edge to the ReleaseEntry entity by IDs.
func (m *ReleaseMutation) RemoveLogIDs(ids ...int) {
	if m.removedlog == nil {
		m.removedlog = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.log, ids[i])
		m.removedlog[ids[i]] = struct{}{}
	}
}

// RemovedLog returns the removed IDs of the "log" edge to the ReleaseEntry entity.
func (m *ReleaseMutation) RemovedLogIDs() (ids []int) {
	for id := range m.removedlog {
		ids = append(ids, id)
	}
	return
}

// LogIDs returns the "log" edge IDs in the mutation.
func (m *ReleaseMutation) LogIDs() (ids []int) {
	for id := range m.log {
		ids = append(ids, id)
	}
	return
}

// ResetLog resets all changes to the "log" edge.
func (m *ReleaseMutation) ResetLog() {
	m.log = nil
	m.clearedlog = false
	m.removedlog = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *ReleaseMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *ReleaseMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *ReleaseMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *ReleaseMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *ReleaseMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *ReleaseMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *ReleaseMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddComponentIDs adds the "components" edge to the ReleaseComponent entity by ids.
func (m *ReleaseMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ReleaseComponent entity.
func (m *ReleaseMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ReleaseComponent entity was cleared.
func (m *ReleaseMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ReleaseComponent entity by IDs.
func (m *ReleaseMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ReleaseComponent entity.
func (m *ReleaseMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ReleaseMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ReleaseMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the ReleaseVulnerability entity by ids.
func (m *ReleaseMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the ReleaseVulnerability entity was cleared.
func (m *ReleaseMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the ReleaseVulnerability entity by IDs.
func (m *ReleaseMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *ReleaseMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *ReleaseMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddCodeScanIDs adds the "code_scans" edge to the CodeScan entity by ids.
func (m *ReleaseMutation) AddCodeScanIDs(ids ...int) {
	if m.code_scans == nil {
		m.code_scans = make(map[int]struct{})
	}
	for i := range ids {
		m.code_scans[ids[i]] = struct{}{}
	}
}

// ClearCodeScans clears the "code_scans" edge to the CodeScan entity.
func (m *ReleaseMutation) ClearCodeScans() {
	m.clearedcode_scans = true
}

// CodeScansCleared reports if the "code_scans" edge to the CodeScan entity was cleared.
func (m *ReleaseMutation) CodeScansCleared() bool {
	return m.clearedcode_scans
}

// RemoveCodeScanIDs removes the "code_scans" edge to the CodeScan entity by IDs.
func (m *ReleaseMutation) RemoveCodeScanIDs(ids ...int) {
	if m.removedcode_scans == nil {
		m.removedcode_scans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.code_scans, ids[i])
		m.removedcode_scans[ids[i]] = struct{}{}
	}
}

// RemovedCodeScans returns the removed IDs of the "code_scans" edge to the CodeScan entity.
func (m *ReleaseMutation) RemovedCodeScansIDs() (ids []int) {
	for id := range m.removedcode_scans {
		ids = append(ids, id)
	}
	return
}

// CodeScansIDs returns the "code_scans" edge IDs in the mutation.
func (m *ReleaseMutation) CodeScansIDs() (ids []int) {
	for id := range m.code_scans {
		ids = append(ids, id)
	}
	return
}

// ResetCodeScans resets all changes to the "code_scans" edge.
func (m *ReleaseMutation) ResetCodeScans() {
	m.code_scans = nil
	m.clearedcode_scans = false
	m.removedcode_scans = nil
}

// AddTestRunIDs adds the "test_runs" edge to the TestRun entity by ids.
func (m *ReleaseMutation) AddTestRunIDs(ids ...int) {
	if m.test_runs == nil {
		m.test_runs = make(map[int]struct{})
	}
	for i := range ids {
		m.test_runs[ids[i]] = struct{}{}
	}
}

// ClearTestRuns clears the "test_runs" edge to the TestRun entity.
func (m *ReleaseMutation) ClearTestRuns() {
	m.clearedtest_runs = true
}

// TestRunsCleared reports if the "test_runs" edge to the TestRun entity was cleared.
func (m *ReleaseMutation) TestRunsCleared() bool {
	return m.clearedtest_runs
}

// RemoveTestRunIDs removes the "test_runs" edge to the TestRun entity by IDs.
func (m *ReleaseMutation) RemoveTestRunIDs(ids ...int) {
	if m.removedtest_runs == nil {
		m.removedtest_runs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_runs, ids[i])
		m.removedtest_runs[ids[i]] = struct{}{}
	}
}

// RemovedTestRuns returns the removed IDs of the "test_runs" edge to the TestRun entity.
func (m *ReleaseMutation) RemovedTestRunsIDs() (ids []int) {
	for id := range m.removedtest_runs {
		ids = append(ids, id)
	}
	return
}

// TestRunsIDs returns the "test_runs" edge IDs in the mutation.
func (m *ReleaseMutation) TestRunsIDs() (ids []int) {
	for id := range m.test_runs {
		ids = append(ids, id)
	}
	return
}

// ResetTestRuns resets all changes to the "test_runs" edge.
func (m *ReleaseMutation) ResetTestRuns() {
	m.test_runs = nil
	m.clearedtest_runs = false
	m.removedtest_runs = nil
}

// AddVulnerabilityReviewIDs adds the "vulnerability_reviews" edge to the VulnerabilityReview entity by ids.
func (m *ReleaseMutation) AddVulnerabilityReviewIDs(ids ...int) {
	if m.vulnerability_reviews == nil {
		m.vulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_reviews[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityReviews clears the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseMutation) ClearVulnerabilityReviews() {
	m.clearedvulnerability_reviews = true
}

// VulnerabilityReviewsCleared reports if the "vulnerability_reviews" edge to the VulnerabilityReview entity was cleared.
func (m *ReleaseMutation) VulnerabilityReviewsCleared() bool {
	return m.clearedvulnerability_reviews
}

// RemoveVulnerabilityReviewIDs removes the "vulnerability_reviews" edge to the VulnerabilityReview entity by IDs.
func (m *ReleaseMutation) RemoveVulnerabilityReviewIDs(ids ...int) {
	if m.removedvulnerability_reviews == nil {
		m.removedvulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_reviews, ids[i])
		m.removedvulnerability_reviews[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityReviews returns the removed IDs of the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseMutation) RemovedVulnerabilityReviewsIDs() (ids []int) {
	for id := range m.removedvulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityReviewsIDs returns the "vulnerability_reviews" edge IDs in the mutation.
func (m *ReleaseMutation) VulnerabilityReviewsIDs() (ids []int) {
	for id := range m.vulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityReviews resets all changes to the "vulnerability_reviews" edge.
func (m *ReleaseMutation) ResetVulnerabilityReviews() {
	m.vulnerability_reviews = nil
	m.clearedvulnerability_reviews = false
	m.removedvulnerability_reviews = nil
}

// Where appends a list predicates to the ReleaseMutation builder.
func (m *ReleaseMutation) Where(ps ...predicate.Release) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Release).
func (m *ReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, release.FieldName)
	}
	if m.version != nil {
		fields = append(fields, release.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, release.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case release.FieldName:
		return m.Name()
	case release.FieldVersion:
		return m.Version()
	case release.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case release.FieldName:
		return m.OldName(ctx)
	case release.FieldVersion:
		return m.OldVersion(ctx)
	case release.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Release field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case release.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case release.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case release.FieldStatus:
		v, ok := value.(release.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Release numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Release nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseMutation) ResetField(name string) error {
	switch name {
	case release.FieldName:
		m.ResetName()
		return nil
	case release.FieldVersion:
		m.ResetVersion()
		return nil
	case release.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.subreleases != nil {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.dependencies != nil {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.commit != nil {
		edges = append(edges, release.EdgeCommit)
	}
	if m.log != nil {
		edges = append(edges, release.EdgeLog)
	}
	if m.artifacts != nil {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.components != nil {
		edges = append(edges, release.EdgeComponents)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, release.EdgeVulnerabilities)
	}
	if m.code_scans != nil {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.test_runs != nil {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.vulnerability_reviews != nil {
		edges = append(edges, release.EdgeVulnerabilityReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeSubreleases:
		ids := make([]ent.Value, 0, len(m.subreleases))
		for id := range m.subreleases {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCommit:
		if id := m.commit; id != nil {
			return []ent.Value{*id}
		}
	case release.EdgeLog:
		ids := make([]ent.Value, 0, len(m.log))
		for id := range m.log {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCodeScans:
		ids := make([]ent.Value, 0, len(m.code_scans))
		for id := range m.code_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeTestRuns:
		ids := make([]ent.Value, 0, len(m.test_runs))
		for id := range m.test_runs {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.vulnerability_reviews))
		for id := range m.vulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedsubreleases != nil {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.removeddependencies != nil {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.removedlog != nil {
		edges = append(edges, release.EdgeLog)
	}
	if m.removedartifacts != nil {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.removedcomponents != nil {
		edges = append(edges, release.EdgeComponents)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, release.EdgeVulnerabilities)
	}
	if m.removedcode_scans != nil {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.removedtest_runs != nil {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.removedvulnerability_reviews != nil {
		edges = append(edges, release.EdgeVulnerabilityReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeSubreleases:
		ids := make([]ent.Value, 0, len(m.removedsubreleases))
		for id := range m.removedsubreleases {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLog:
		ids := make([]ent.Value, 0, len(m.removedlog))
		for id := range m.removedlog {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCodeScans:
		ids := make([]ent.Value, 0, len(m.removedcode_scans))
		for id := range m.removedcode_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeTestRuns:
		ids := make([]ent.Value, 0, len(m.removedtest_runs))
		for id := range m.removedtest_runs {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_reviews))
		for id := range m.removedvulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedsubreleases {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.cleareddependencies {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.clearedcommit {
		edges = append(edges, release.EdgeCommit)
	}
	if m.clearedlog {
		edges = append(edges, release.EdgeLog)
	}
	if m.clearedartifacts {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.clearedcomponents {
		edges = append(edges, release.EdgeComponents)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, release.EdgeVulnerabilities)
	}
	if m.clearedcode_scans {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.clearedtest_runs {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.clearedvulnerability_reviews {
		edges = append(edges, release.EdgeVulnerabilityReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseMutation) EdgeCleared(name string) bool {
	switch name {
	case release.EdgeSubreleases:
		return m.clearedsubreleases
	case release.EdgeDependencies:
		return m.cleareddependencies
	case release.EdgeCommit:
		return m.clearedcommit
	case release.EdgeLog:
		return m.clearedlog
	case release.EdgeArtifacts:
		return m.clearedartifacts
	case release.EdgeComponents:
		return m.clearedcomponents
	case release.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case release.EdgeCodeScans:
		return m.clearedcode_scans
	case release.EdgeTestRuns:
		return m.clearedtest_runs
	case release.EdgeVulnerabilityReviews:
		return m.clearedvulnerability_reviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseMutation) ClearEdge(name string) error {
	switch name {
	case release.EdgeCommit:
		m.ClearCommit()
		return nil
	}
	return fmt.Errorf("unknown Release unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseMutation) ResetEdge(name string) error {
	switch name {
	case release.EdgeSubreleases:
		m.ResetSubreleases()
		return nil
	case release.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case release.EdgeCommit:
		m.ResetCommit()
		return nil
	case release.EdgeLog:
		m.ResetLog()
		return nil
	case release.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case release.EdgeComponents:
		m.ResetComponents()
		return nil
	case release.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case release.EdgeCodeScans:
		m.ResetCodeScans()
		return nil
	case release.EdgeTestRuns:
		m.ResetTestRuns()
		return nil
	case release.EdgeVulnerabilityReviews:
		m.ResetVulnerabilityReviews()
		return nil
	}
	return fmt.Errorf("unknown Release edge %s", name)
}

// ReleaseComponentMutation represents an operation that mutates the ReleaseComponent nodes in the graph.
type ReleaseComponentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	clearedFields          map[string]struct{}
	release                *int
	clearedrelease         bool
	scans                  map[int]struct{}
	removedscans           map[int]struct{}
	clearedscans           bool
	component              *int
	clearedcomponent       bool
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	done                   bool
	oldValue               func(context.Context) (*ReleaseComponent, error)
	predicates             []predicate.ReleaseComponent
}

var _ ent.Mutation = (*ReleaseComponentMutation)(nil)

// releasecomponentOption allows management of the mutation configuration using functional options.
type releasecomponentOption func(*ReleaseComponentMutation)

// newReleaseComponentMutation creates new mutation for the ReleaseComponent entity.
func newReleaseComponentMutation(c config, op Op, opts ...releasecomponentOption) *ReleaseComponentMutation {
	m := &ReleaseComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseComponentID sets the ID field of the mutation.
func withReleaseComponentID(id int) releasecomponentOption {
	return func(m *ReleaseComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseComponent
		)
		m.oldValue = func(ctx context.Context) (*ReleaseComponent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseComponent sets the old ReleaseComponent of the mutation.
func withReleaseComponent(node *ReleaseComponent) releasecomponentOption {
	return func(m *ReleaseComponentMutation) {
		m.oldValue = func(context.Context) (*ReleaseComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseComponentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseComponentMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseComponentMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseComponentMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseComponentMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseComponentMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseComponentMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddScanIDs adds the "scans" edge to the CodeScan entity by ids.
func (m *ReleaseComponentMutation) AddScanIDs(ids ...int) {
	if m.scans == nil {
		m.scans = make(map[int]struct{})
	}
	for i := range ids {
		m.scans[ids[i]] = struct{}{}
	}
}

// ClearScans clears the "scans" edge to the CodeScan entity.
func (m *ReleaseComponentMutation) ClearScans() {
	m.clearedscans = true
}

// ScansCleared reports if the "scans" edge to the CodeScan entity was cleared.
func (m *ReleaseComponentMutation) ScansCleared() bool {
	return m.clearedscans
}

// RemoveScanIDs removes the "scans" edge to the CodeScan entity by IDs.
func (m *ReleaseComponentMutation) RemoveScanIDs(ids ...int) {
	if m.removedscans == nil {
		m.removedscans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scans, ids[i])
		m.removedscans[ids[i]] = struct{}{}
	}
}

// RemovedScans returns the removed IDs of the "scans" edge to the CodeScan entity.
func (m *ReleaseComponentMutation) RemovedScansIDs() (ids []int) {
	for id := range m.removedscans {
		ids = append(ids, id)
	}
	return
}

// ScansIDs returns the "scans" edge IDs in the mutation.
func (m *ReleaseComponentMutation) ScansIDs() (ids []int) {
	for id := range m.scans {
		ids = append(ids, id)
	}
	return
}

// ResetScans resets all changes to the "scans" edge.
func (m *ReleaseComponentMutation) ResetScans() {
	m.scans = nil
	m.clearedscans = false
	m.removedscans = nil
}

// SetComponentID sets the "component" edge to the Component entity by id.
func (m *ReleaseComponentMutation) SetComponentID(id int) {
	m.component = &id
}

// ClearComponent clears the "component" edge to the Component entity.
func (m *ReleaseComponentMutation) ClearComponent() {
	m.clearedcomponent = true
}

// ComponentCleared reports if the "component" edge to the Component entity was cleared.
func (m *ReleaseComponentMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentID returns the "component" edge ID in the mutation.
func (m *ReleaseComponentMutation) ComponentID() (id int, exists bool) {
	if m.component != nil {
		return *m.component, true
	}
	return
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *ReleaseComponentMutation) ComponentIDs() (ids []int) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *ReleaseComponentMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the ReleaseVulnerability entity by ids.
func (m *ReleaseComponentMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseComponentMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the ReleaseVulnerability entity was cleared.
func (m *ReleaseComponentMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the ReleaseVulnerability entity by IDs.
func (m *ReleaseComponentMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseComponentMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *ReleaseComponentMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *ReleaseComponentMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// Where appends a list predicates to the ReleaseComponentMutation builder.
func (m *ReleaseComponentMutation) Where(ps ...predicate.ReleaseComponent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseComponentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseComponent).
func (m *ReleaseComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseComponentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseComponentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ReleaseComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseComponentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ReleaseComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseComponentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseComponentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseComponentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ReleaseComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.release != nil {
		edges = append(edges, releasecomponent.EdgeRelease)
	}
	if m.scans != nil {
		edges = append(edges, releasecomponent.EdgeScans)
	}
	if m.component != nil {
		edges = append(edges, releasecomponent.EdgeComponent)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, releasecomponent.EdgeVulnerabilities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releasecomponent.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case releasecomponent.EdgeScans:
		ids := make([]ent.Value, 0, len(m.scans))
		for id := range m.scans {
			ids = append(ids, id)
		}
		return ids
	case releasecomponent.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	case releasecomponent.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedscans != nil {
		edges = append(edges, releasecomponent.EdgeScans)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, releasecomponent.EdgeVulnerabilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case releasecomponent.EdgeScans:
		ids := make([]ent.Value, 0, len(m.removedscans))
		for id := range m.removedscans {
			ids = append(ids, id)
		}
		return ids
	case releasecomponent.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedrelease {
		edges = append(edges, releasecomponent.EdgeRelease)
	}
	if m.clearedscans {
		edges = append(edges, releasecomponent.EdgeScans)
	}
	if m.clearedcomponent {
		edges = append(edges, releasecomponent.EdgeComponent)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, releasecomponent.EdgeVulnerabilities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case releasecomponent.EdgeRelease:
		return m.clearedrelease
	case releasecomponent.EdgeScans:
		return m.clearedscans
	case releasecomponent.EdgeComponent:
		return m.clearedcomponent
	case releasecomponent.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseComponentMutation) ClearEdge(name string) error {
	switch name {
	case releasecomponent.EdgeRelease:
		m.ClearRelease()
		return nil
	case releasecomponent.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown ReleaseComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseComponentMutation) ResetEdge(name string) error {
	switch name {
	case releasecomponent.EdgeRelease:
		m.ResetRelease()
		return nil
	case releasecomponent.EdgeScans:
		m.ResetScans()
		return nil
	case releasecomponent.EdgeComponent:
		m.ResetComponent()
		return nil
	case releasecomponent.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	}
	return fmt.Errorf("unknown ReleaseComponent edge %s", name)
}

// ReleaseEntryMutation represents an operation that mutates the ReleaseEntry nodes in the graph.
type ReleaseEntryMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_type            *releaseentry.Type
	time             *time.Time
	clearedFields    map[string]struct{}
	artifact         *int
	clearedartifact  bool
	code_scan        *int
	clearedcode_scan bool
	test_run         *int
	clearedtest_run  bool
	release          *int
	clearedrelease   bool
	done             bool
	oldValue         func(context.Context) (*ReleaseEntry, error)
	predicates       []predicate.ReleaseEntry
}

var _ ent.Mutation = (*ReleaseEntryMutation)(nil)

// releaseentryOption allows management of the mutation configuration using functional options.
type releaseentryOption func(*ReleaseEntryMutation)

// newReleaseEntryMutation creates new mutation for the ReleaseEntry entity.
func newReleaseEntryMutation(c config, op Op, opts ...releaseentryOption) *ReleaseEntryMutation {
	m := &ReleaseEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseEntryID sets the ID field of the mutation.
func withReleaseEntryID(id int) releaseentryOption {
	return func(m *ReleaseEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseEntry
		)
		m.oldValue = func(ctx context.Context) (*ReleaseEntry, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseEntry sets the old ReleaseEntry of the mutation.
func withReleaseEntry(node *ReleaseEntry) releaseentryOption {
	return func(m *ReleaseEntryMutation) {
		m.oldValue = func(context.Context) (*ReleaseEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *ReleaseEntryMutation) SetType(r releaseentry.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReleaseEntryMutation) GetType() (r releaseentry.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReleaseEntry entity.
// If the ReleaseEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseEntryMutation) OldType(ctx context.Context) (v releaseentry.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReleaseEntryMutation) ResetType() {
	m._type = nil
}

// SetTime sets the "time" field.
func (m *ReleaseEntryMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *ReleaseEntryMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the ReleaseEntry entity.
// If the ReleaseEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseEntryMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *ReleaseEntryMutation) ResetTime() {
	m.time = nil
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by id.
func (m *ReleaseEntryMutation) SetArtifactID(id int) {
	m.artifact = &id
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *ReleaseEntryMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *ReleaseEntryMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactID returns the "artifact" edge ID in the mutation.
func (m *ReleaseEntryMutation) ArtifactID() (id int, exists bool) {
	if m.artifact != nil {
		return *m.artifact, true
	}
	return
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *ReleaseEntryMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// SetCodeScanID sets the "code_scan" edge to the CodeScan entity by id.
func (m *ReleaseEntryMutation) SetCodeScanID(id int) {
	m.code_scan = &id
}

// ClearCodeScan clears the "code_scan" edge to the CodeScan entity.
func (m *ReleaseEntryMutation) ClearCodeScan() {
	m.clearedcode_scan = true
}

// CodeScanCleared reports if the "code_scan" edge to the CodeScan entity was cleared.
func (m *ReleaseEntryMutation) CodeScanCleared() bool {
	return m.clearedcode_scan
}

// CodeScanID returns the "code_scan" edge ID in the mutation.
func (m *ReleaseEntryMutation) CodeScanID() (id int, exists bool) {
	if m.code_scan != nil {
		return *m.code_scan, true
	}
	return
}

// CodeScanIDs returns the "code_scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodeScanID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) CodeScanIDs() (ids []int) {
	if id := m.code_scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodeScan resets all changes to the "code_scan" edge.
func (m *ReleaseEntryMutation) ResetCodeScan() {
	m.code_scan = nil
	m.clearedcode_scan = false
}

// SetTestRunID sets the "test_run" edge to the TestRun entity by id.
func (m *ReleaseEntryMutation) SetTestRunID(id int) {
	m.test_run = &id
}

// ClearTestRun clears the "test_run" edge to the TestRun entity.
func (m *ReleaseEntryMutation) ClearTestRun() {
	m.clearedtest_run = true
}

// TestRunCleared reports if the "test_run" edge to the TestRun entity was cleared.
func (m *ReleaseEntryMutation) TestRunCleared() bool {
	return m.clearedtest_run
}

// TestRunID returns the "test_run" edge ID in the mutation.
func (m *ReleaseEntryMutation) TestRunID() (id int, exists bool) {
	if m.test_run != nil {
		return *m.test_run, true
	}
	return
}

// TestRunIDs returns the "test_run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestRunID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) TestRunIDs() (ids []int) {
	if id := m.test_run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestRun resets all changes to the "test_run" edge.
func (m *ReleaseEntryMutation) ResetTestRun() {
	m.test_run = nil
	m.clearedtest_run = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseEntryMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseEntryMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseEntryMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseEntryMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseEntryMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Where appends a list predicates to the ReleaseEntryMutation builder.
func (m *ReleaseEntryMutation) Where(ps ...predicate.ReleaseEntry) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseEntryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseEntry).
func (m *ReleaseEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseEntryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, releaseentry.FieldType)
	}
	if m.time != nil {
		fields = append(fields, releaseentry.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case releaseentry.FieldType:
		return m.GetType()
	case releaseentry.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case releaseentry.FieldType:
		return m.OldType(ctx)
	case releaseentry.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case releaseentry.FieldType:
		v, ok := value.(releaseentry.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case releaseentry.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseEntryMutation) ResetField(name string) error {
	switch name {
	case releaseentry.FieldType:
		m.ResetType()
		return nil
	case releaseentry.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.artifact != nil {
		edges = append(edges, releaseentry.EdgeArtifact)
	}
	if m.code_scan != nil {
		edges = append(edges, releaseentry.EdgeCodeScan)
	}
	if m.test_run != nil {
		edges = append(edges, releaseentry.EdgeTestRun)
	}
	if m.release != nil {
		edges = append(edges, releaseentry.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releaseentry.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeCodeScan:
		if id := m.code_scan; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeTestRun:
		if id := m.test_run; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedartifact {
		edges = append(edges, releaseentry.EdgeArtifact)
	}
	if m.clearedcode_scan {
		edges = append(edges, releaseentry.EdgeCodeScan)
	}
	if m.clearedtest_run {
		edges = append(edges, releaseentry.EdgeTestRun)
	}
	if m.clearedrelease {
		edges = append(edges, releaseentry.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case releaseentry.EdgeArtifact:
		return m.clearedartifact
	case releaseentry.EdgeCodeScan:
		return m.clearedcode_scan
	case releaseentry.EdgeTestRun:
		return m.clearedtest_run
	case releaseentry.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseEntryMutation) ClearEdge(name string) error {
	switch name {
	case releaseentry.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case releaseentry.EdgeCodeScan:
		m.ClearCodeScan()
		return nil
	case releaseentry.EdgeTestRun:
		m.ClearTestRun()
		return nil
	case releaseentry.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseEntryMutation) ResetEdge(name string) error {
	switch name {
	case releaseentry.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case releaseentry.EdgeCodeScan:
		m.ResetCodeScan()
		return nil
	case releaseentry.EdgeTestRun:
		m.ResetTestRun()
		return nil
	case releaseentry.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry edge %s", name)
}

// ReleaseVulnerabilityMutation represents an operation that mutates the ReleaseVulnerability nodes in the graph.
type ReleaseVulnerabilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	clearedFields        map[string]struct{}
	vulnerability        *int
	clearedvulnerability bool
	components           map[int]struct{}
	removedcomponents    map[int]struct{}
	clearedcomponents    bool
	release              *int
	clearedrelease       bool
	reviews              map[int]struct{}
	removedreviews       map[int]struct{}
	clearedreviews       bool
	scans                map[int]struct{}
	removedscans         map[int]struct{}
	clearedscans         bool
	done                 bool
	oldValue             func(context.Context) (*ReleaseVulnerability, error)
	predicates           []predicate.ReleaseVulnerability
}

var _ ent.Mutation = (*ReleaseVulnerabilityMutation)(nil)

// releasevulnerabilityOption allows management of the mutation configuration using functional options.
type releasevulnerabilityOption func(*ReleaseVulnerabilityMutation)

// newReleaseVulnerabilityMutation creates new mutation for the ReleaseVulnerability entity.
func newReleaseVulnerabilityMutation(c config, op Op, opts ...releasevulnerabilityOption) *ReleaseVulnerabilityMutation {
	m := &ReleaseVulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseVulnerabilityID sets the ID field of the mutation.
func withReleaseVulnerabilityID(id int) releasevulnerabilityOption {
	return func(m *ReleaseVulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseVulnerability
		)
		m.oldValue = func(ctx context.Context) (*ReleaseVulnerability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseVulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseVulnerability sets the old ReleaseVulnerability of the mutation.
func withReleaseVulnerability(node *ReleaseVulnerability) releasevulnerabilityOption {
	return func(m *ReleaseVulnerabilityMutation) {
		m.oldValue = func(context.Context) (*ReleaseVulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseVulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseVulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseVulnerabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetVulnerabilityID sets the "vulnerability" edge to the Vulnerability entity by id.
func (m *ReleaseVulnerabilityMutation) SetVulnerabilityID(id int) {
	m.vulnerability = &id
}

// ClearVulnerability clears the "vulnerability" edge to the Vulnerability entity.
func (m *ReleaseVulnerabilityMutation) ClearVulnerability() {
	m.clearedvulnerability = true
}

// VulnerabilityCleared reports if the "vulnerability" edge to the Vulnerability entity was cleared.
func (m *ReleaseVulnerabilityMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityID returns the "vulnerability" edge ID in the mutation.
func (m *ReleaseVulnerabilityMutation) VulnerabilityID() (id int, exists bool) {
	if m.vulnerability != nil {
		return *m.vulnerability, true
	}
	return
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *ReleaseVulnerabilityMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *ReleaseVulnerabilityMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// AddComponentIDs adds the "components" edge to the ReleaseComponent entity by ids.
func (m *ReleaseVulnerabilityMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ReleaseComponent entity.
func (m *ReleaseVulnerabilityMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ReleaseComponent entity was cleared.
func (m *ReleaseVulnerabilityMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ReleaseComponent entity by IDs.
func (m *ReleaseVulnerabilityMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ReleaseComponent entity.
func (m *ReleaseVulnerabilityMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ReleaseVulnerabilityMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ReleaseVulnerabilityMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseVulnerabilityMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseVulnerabilityMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseVulnerabilityMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseVulnerabilityMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseVulnerabilityMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseVulnerabilityMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddReviewIDs adds the "reviews" edge to the VulnerabilityReview entity by ids.
func (m *ReleaseVulnerabilityMutation) AddReviewIDs(ids ...int) {
	if m.reviews == nil {
		m.reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseVulnerabilityMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the VulnerabilityReview entity was cleared.
func (m *ReleaseVulnerabilityMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the VulnerabilityReview entity by IDs.
func (m *ReleaseVulnerabilityMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseVulnerabilityMutation) RemovedReviewsIDs() (ids []int) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *ReleaseVulnerabilityMutation) ReviewsIDs() (ids []int) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *ReleaseVulnerabilityMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddScanIDs adds the "scans" edge to the CodeScan entity by ids.
func (m *ReleaseVulnerabilityMutation) AddScanIDs(ids ...int) {
	if m.scans == nil {
		m.scans = make(map[int]struct{})
	}
	for i := range ids {
		m.scans[ids[i]] = struct{}{}
	}
}

// ClearScans clears the "scans" edge to the CodeScan entity.
func (m *ReleaseVulnerabilityMutation) ClearScans() {
	m.clearedscans = true
}

// ScansCleared reports if the "scans" edge to the CodeScan entity was cleared.
func (m *ReleaseVulnerabilityMutation) ScansCleared() bool {
	return m.clearedscans
}

// RemoveScanIDs removes the "scans" edge to the CodeScan entity by IDs.
func (m *ReleaseVulnerabilityMutation) RemoveScanIDs(ids ...int) {
	if m.removedscans == nil {
		m.removedscans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scans, ids[i])
		m.removedscans[ids[i]] = struct{}{}
	}
}

// RemovedScans returns the removed IDs of the "scans" edge to the CodeScan entity.
func (m *ReleaseVulnerabilityMutation) RemovedScansIDs() (ids []int) {
	for id := range m.removedscans {
		ids = append(ids, id)
	}
	return
}

// ScansIDs returns the "scans" edge IDs in the mutation.
func (m *ReleaseVulnerabilityMutation) ScansIDs() (ids []int) {
	for id := range m.scans {
		ids = append(ids, id)
	}
	return
}

// ResetScans resets all changes to the "scans" edge.
func (m *ReleaseVulnerabilityMutation) ResetScans() {
	m.scans = nil
	m.clearedscans = false
	m.removedscans = nil
}

// Where appends a list predicates to the ReleaseVulnerabilityMutation builder.
func (m *ReleaseVulnerabilityMutation) Where(ps ...predicate.ReleaseVulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseVulnerabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseVulnerability).
func (m *ReleaseVulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseVulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseVulnerabilityMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseVulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ReleaseVulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseVulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseVulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseVulnerabilityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseVulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseVulnerabilityMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ReleaseVulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseVulnerabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseVulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseVulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ReleaseVulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseVulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.vulnerability != nil {
		edges = append(edges, releasevulnerability.EdgeVulnerability)
	}
	if m.components != nil {
		edges = append(edges, releasevulnerability.EdgeComponents)
	}
	if m.release != nil {
		edges = append(edges, releasevulnerability.EdgeRelease)
	}
	if m.reviews != nil {
		edges = append(edges, releasevulnerability.EdgeReviews)
	}
	if m.scans != nil {
		edges = append(edges, releasevulnerability.EdgeScans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseVulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	case releasevulnerability.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case releasevulnerability.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case releasevulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case releasevulnerability.EdgeScans:
		ids := make([]ent.Value, 0, len(m.scans))
		for id := range m.scans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseVulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcomponents != nil {
		edges = append(edges, releasevulnerability.EdgeComponents)
	}
	if m.removedreviews != nil {
		edges = append(edges, releasevulnerability.EdgeReviews)
	}
	if m.removedscans != nil {
		edges = append(edges, releasevulnerability.EdgeScans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseVulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case releasevulnerability.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case releasevulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case releasevulnerability.EdgeScans:
		ids := make([]ent.Value, 0, len(m.removedscans))
		for id := range m.removedscans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseVulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedvulnerability {
		edges = append(edges, releasevulnerability.EdgeVulnerability)
	}
	if m.clearedcomponents {
		edges = append(edges, releasevulnerability.EdgeComponents)
	}
	if m.clearedrelease {
		edges = append(edges, releasevulnerability.EdgeRelease)
	}
	if m.clearedreviews {
		edges = append(edges, releasevulnerability.EdgeReviews)
	}
	if m.clearedscans {
		edges = append(edges, releasevulnerability.EdgeScans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseVulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		return m.clearedvulnerability
	case releasevulnerability.EdgeComponents:
		return m.clearedcomponents
	case releasevulnerability.EdgeRelease:
		return m.clearedrelease
	case releasevulnerability.EdgeReviews:
		return m.clearedreviews
	case releasevulnerability.EdgeScans:
		return m.clearedscans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	case releasevulnerability.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseVulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	case releasevulnerability.EdgeComponents:
		m.ResetComponents()
		return nil
	case releasevulnerability.EdgeRelease:
		m.ResetRelease()
		return nil
	case releasevulnerability.EdgeReviews:
		m.ResetReviews()
		return nil
	case releasevulnerability.EdgeScans:
		m.ResetScans()
		return nil
	}
	return fmt.Errorf("unknown ReleaseVulnerability edge %s", name)
}

// RepoMutation represents an operation that mutates the Repo nodes in the graph.
type RepoMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	clearedFields                map[string]struct{}
	projects                     map[int]struct{}
	removedprojects              map[int]struct{}
	clearedprojects              bool
	commits                      map[int]struct{}
	removedcommits               map[int]struct{}
	clearedcommits               bool
	vulnerability_reviews        map[int]struct{}
	removedvulnerability_reviews map[int]struct{}
	clearedvulnerability_reviews bool
	done                         bool
	oldValue                     func(context.Context) (*Repo, error)
	predicates                   []predicate.Repo
}

var _ ent.Mutation = (*RepoMutation)(nil)

// repoOption allows management of the mutation configuration using functional options.
type repoOption func(*RepoMutation)

// newRepoMutation creates new mutation for the Repo entity.
func newRepoMutation(c config, op Op, opts ...repoOption) *RepoMutation {
	m := &RepoMutation{
		config:        c,
		op:            op,
		typ:           TypeRepo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepoID sets the ID field of the mutation.
func withRepoID(id int) repoOption {
	return func(m *RepoMutation) {
		var (
			err   error
			once  sync.Once
			value *Repo
		)
		m.oldValue = func(ctx context.Context) (*Repo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepo sets the old Repo of the mutation.
func withRepo(node *Repo) repoOption {
	return func(m *RepoMutation) {
		m.oldValue = func(context.Context) (*Repo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *RepoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepoMutation) ResetName() {
	m.name = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *RepoMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *RepoMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *RepoMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *RepoMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *RepoMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *RepoMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *RepoMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddCommitIDs adds the "commits" edge to the GitCommit entity by ids.
func (m *RepoMutation) AddCommitIDs(ids ...int) {
	if m.commits == nil {
		m.commits = make(map[int]struct{})
	}
	for i := range ids {
		m.commits[ids[i]] = struct{}{}
	}
}

// ClearCommits clears the "commits" edge to the GitCommit entity.
func (m *RepoMutation) ClearCommits() {
	m.clearedcommits = true
}

// CommitsCleared reports if the "commits" edge to the GitCommit entity was cleared.
func (m *RepoMutation) CommitsCleared() bool {
	return m.clearedcommits
}

// RemoveCommitIDs removes the "commits" edge to the GitCommit entity by IDs.
func (m *RepoMutation) RemoveCommitIDs(ids ...int) {
	if m.removedcommits == nil {
		m.removedcommits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.commits, ids[i])
		m.removedcommits[ids[i]] = struct{}{}
	}
}

// RemovedCommits returns the removed IDs of the "commits" edge to the GitCommit entity.
func (m *RepoMutation) RemovedCommitsIDs() (ids []int) {
	for id := range m.removedcommits {
		ids = append(ids, id)
	}
	return
}

// CommitsIDs returns the "commits" edge IDs in the mutation.
func (m *RepoMutation) CommitsIDs() (ids []int) {
	for id := range m.commits {
		ids = append(ids, id)
	}
	return
}

// ResetCommits resets all changes to the "commits" edge.
func (m *RepoMutation) ResetCommits() {
	m.commits = nil
	m.clearedcommits = false
	m.removedcommits = nil
}

// AddVulnerabilityReviewIDs adds the "vulnerability_reviews" edge to the VulnerabilityReview entity by ids.
func (m *RepoMutation) AddVulnerabilityReviewIDs(ids ...int) {
	if m.vulnerability_reviews == nil {
		m.vulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_reviews[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityReviews clears the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *RepoMutation) ClearVulnerabilityReviews() {
	m.clearedvulnerability_reviews = true
}

// VulnerabilityReviewsCleared reports if the "vulnerability_reviews" edge to the VulnerabilityReview entity was cleared.
func (m *RepoMutation) VulnerabilityReviewsCleared() bool {
	return m.clearedvulnerability_reviews
}

// RemoveVulnerabilityReviewIDs removes the "vulnerability_reviews" edge to the VulnerabilityReview entity by IDs.
func (m *RepoMutation) RemoveVulnerabilityReviewIDs(ids ...int) {
	if m.removedvulnerability_reviews == nil {
		m.removedvulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_reviews, ids[i])
		m.removedvulnerability_reviews[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityReviews returns the removed IDs of the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *RepoMutation) RemovedVulnerabilityReviewsIDs() (ids []int) {
	for id := range m.removedvulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityReviewsIDs returns the "vulnerability_reviews" edge IDs in the mutation.
func (m *RepoMutation) VulnerabilityReviewsIDs() (ids []int) {
	for id := range m.vulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityReviews resets all changes to the "vulnerability_reviews" edge.
func (m *RepoMutation) ResetVulnerabilityReviews() {
	m.vulnerability_reviews = nil
	m.clearedvulnerability_reviews = false
	m.removedvulnerability_reviews = nil
}

// Where appends a list predicates to the RepoMutation builder.
func (m *RepoMutation) Where(ps ...predicate.Repo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RepoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repo).
func (m *RepoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepoMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, repo.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repo.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repo.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Repo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepoMutation) ResetField(name string) error {
	switch name {
	case repo.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.projects != nil {
		edges = append(edges, repo.EdgeProjects)
	}
	if m.commits != nil {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.vulnerability_reviews != nil {
		edges = append(edges, repo.EdgeVulnerabilityReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.commits))
		for id := range m.commits {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.vulnerability_reviews))
		for id := range m.vulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprojects != nil {
		edges = append(edges, repo.EdgeProjects)
	}
	if m.removedcommits != nil {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.removedvulnerability_reviews != nil {
		edges = append(edges, repo.EdgeVulnerabilityReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.removedcommits))
		for id := range m.removedcommits {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_reviews))
		for id := range m.removedvulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprojects {
		edges = append(edges, repo.EdgeProjects)
	}
	if m.clearedcommits {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.clearedvulnerability_reviews {
		edges = append(edges, repo.EdgeVulnerabilityReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepoMutation) EdgeCleared(name string) bool {
	switch name {
	case repo.EdgeProjects:
		return m.clearedprojects
	case repo.EdgeCommits:
		return m.clearedcommits
	case repo.EdgeVulnerabilityReviews:
		return m.clearedvulnerability_reviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Repo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepoMutation) ResetEdge(name string) error {
	switch name {
	case repo.EdgeProjects:
		m.ResetProjects()
		return nil
	case repo.EdgeCommits:
		m.ResetCommits()
		return nil
	case repo.EdgeVulnerabilityReviews:
		m.ResetVulnerabilityReviews()
		return nil
	}
	return fmt.Errorf("unknown Repo edge %s", name)
}

// TestCaseMutation represents an operation that mutates the TestCase nodes in the graph.
type TestCaseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	result        *bool
	message       *string
	elapsed       *float64
	addelapsed    *float64
	clearedFields map[string]struct{}
	run           *int
	clearedrun    bool
	done          bool
	oldValue      func(context.Context) (*TestCase, error)
	predicates    []predicate.TestCase
}

var _ ent.Mutation = (*TestCaseMutation)(nil)

// testcaseOption allows management of the mutation configuration using functional options.
type testcaseOption func(*TestCaseMutation)

// newTestCaseMutation creates new mutation for the TestCase entity.
func newTestCaseMutation(c config, op Op, opts ...testcaseOption) *TestCaseMutation {
	m := &TestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestCaseID sets the ID field of the mutation.
func withTestCaseID(id int) testcaseOption {
	return func(m *TestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *TestCase
		)
		m.oldValue = func(ctx context.Context) (*TestCase, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestCase sets the old TestCase of the mutation.
func withTestCase(node *TestCase) testcaseOption {
	return func(m *TestCaseMutation) {
		m.oldValue = func(context.Context) (*TestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestCaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *TestCaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestCaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestCaseMutation) ResetName() {
	m.name = nil
}

// SetResult sets the "result" field.
func (m *TestCaseMutation) SetResult(b bool) {
	m.result = &b
}

// Result returns the value of the "result" field in the mutation.
func (m *TestCaseMutation) Result() (r bool, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldResult(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *TestCaseMutation) ResetResult() {
	m.result = nil
}

// SetMessage sets the "message" field.
func (m *TestCaseMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TestCaseMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *TestCaseMutation) ResetMessage() {
	m.message = nil
}

// SetElapsed sets the "elapsed" field.
func (m *TestCaseMutation) SetElapsed(f float64) {
	m.elapsed = &f
	m.addelapsed = nil
}

// Elapsed returns the value of the "elapsed" field in the mutation.
func (m *TestCaseMutation) Elapsed() (r float64, exists bool) {
	v := m.elapsed
	if v == nil {
		return
	}
	return *v, true
}

// OldElapsed returns the old "elapsed" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldElapsed(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldElapsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldElapsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElapsed: %w", err)
	}
	return oldValue.Elapsed, nil
}

// AddElapsed adds f to the "elapsed" field.
func (m *TestCaseMutation) AddElapsed(f float64) {
	if m.addelapsed != nil {
		*m.addelapsed += f
	} else {
		m.addelapsed = &f
	}
}

// AddedElapsed returns the value that was added to the "elapsed" field in this mutation.
func (m *TestCaseMutation) AddedElapsed() (r float64, exists bool) {
	v := m.addelapsed
	if v == nil {
		return
	}
	return *v, true
}

// ResetElapsed resets all changes to the "elapsed" field.
func (m *TestCaseMutation) ResetElapsed() {
	m.elapsed = nil
	m.addelapsed = nil
}

// SetRunID sets the "run" edge to the TestRun entity by id.
func (m *TestCaseMutation) SetRunID(id int) {
	m.run = &id
}

// ClearRun clears the "run" edge to the TestRun entity.
func (m *TestCaseMutation) ClearRun() {
	m.clearedrun = true
}

// RunCleared reports if the "run" edge to the TestRun entity was cleared.
func (m *TestCaseMutation) RunCleared() bool {
	return m.clearedrun
}

// RunID returns the "run" edge ID in the mutation.
func (m *TestCaseMutation) RunID() (id int, exists bool) {
	if m.run != nil {
		return *m.run, true
	}
	return
}

// RunIDs returns the "run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *TestCaseMutation) RunIDs() (ids []int) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun resets all changes to the "run" edge.
func (m *TestCaseMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// Where appends a list predicates to the TestCaseMutation builder.
func (m *TestCaseMutation) Where(ps ...predicate.TestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestCase).
func (m *TestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestCaseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, testcase.FieldName)
	}
	if m.result != nil {
		fields = append(fields, testcase.FieldResult)
	}
	if m.message != nil {
		fields = append(fields, testcase.FieldMessage)
	}
	if m.elapsed != nil {
		fields = append(fields, testcase.FieldElapsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldName:
		return m.Name()
	case testcase.FieldResult:
		return m.Result()
	case testcase.FieldMessage:
		return m.Message()
	case testcase.FieldElapsed:
		return m.Elapsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase.FieldName:
		return m.OldName(ctx)
	case testcase.FieldResult:
		return m.OldResult(ctx)
	case testcase.FieldMessage:
		return m.OldMessage(ctx)
	case testcase.FieldElapsed:
		return m.OldElapsed(ctx)
	}
	return nil, fmt.Errorf("unknown TestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testcase.FieldResult:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case testcase.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case testcase.FieldElapsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElapsed(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addelapsed != nil {
		fields = append(fields, testcase.FieldElapsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldElapsed:
		return m.AddedElapsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldElapsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElapsed(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestCaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestCaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestCaseMutation) ResetField(name string) error {
	switch name {
	case testcase.FieldName:
		m.ResetName()
		return nil
	case testcase.FieldResult:
		m.ResetResult()
		return nil
	case testcase.FieldMessage:
		m.ResetMessage()
		return nil
	case testcase.FieldElapsed:
		m.ResetElapsed()
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.run != nil {
		edges = append(edges, testcase.EdgeRun)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestCaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testcase.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestCaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrun {
		edges = append(edges, testcase.EdgeRun)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestCaseMutation) EdgeCleared(name string) bool {
	switch name {
	case testcase.EdgeRun:
		return m.clearedrun
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestCaseMutation) ClearEdge(name string) error {
	switch name {
	case testcase.EdgeRun:
		m.ClearRun()
		return nil
	}
	return fmt.Errorf("unknown TestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestCaseMutation) ResetEdge(name string) error {
	switch name {
	case testcase.EdgeRun:
		m.ResetRun()
		return nil
	}
	return fmt.Errorf("unknown TestCase edge %s", name)
}

// TestRunMutation represents an operation that mutates the TestRun nodes in the graph.
type TestRunMutation struct {
	config
	op             Op
	typ            string
	id             *int
	tool           *string
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	entry          *int
	clearedentry   bool
	tests          map[int]struct{}
	removedtests   map[int]struct{}
	clearedtests   bool
	done           bool
	oldValue       func(context.Context) (*TestRun, error)
	predicates     []predicate.TestRun
}

var _ ent.Mutation = (*TestRunMutation)(nil)

// testrunOption allows management of the mutation configuration using functional options.
type testrunOption func(*TestRunMutation)

// newTestRunMutation creates new mutation for the TestRun entity.
func newTestRunMutation(c config, op Op, opts ...testrunOption) *TestRunMutation {
	m := &TestRunMutation{
		config:        c,
		op:            op,
		typ:           TypeTestRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestRunID sets the ID field of the mutation.
func withTestRunID(id int) testrunOption {
	return func(m *TestRunMutation) {
		var (
			err   error
			once  sync.Once
			value *TestRun
		)
		m.oldValue = func(ctx context.Context) (*TestRun, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestRun sets the old TestRun of the mutation.
func withTestRun(node *TestRun) testrunOption {
	return func(m *TestRunMutation) {
		m.oldValue = func(context.Context) (*TestRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestRunMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *TestRunMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *TestRunMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the TestRun entity.
// If the TestRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestRunMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *TestRunMutation) ResetTool() {
	m.tool = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *TestRunMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *TestRunMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *TestRunMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *TestRunMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *TestRunMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *TestRunMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *TestRunMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *TestRunMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *TestRunMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *TestRunMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *TestRunMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *TestRunMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// AddTestIDs adds the "tests" edge to the TestCase entity by ids.
func (m *TestRunMutation) AddTestIDs(ids ...int) {
	if m.tests == nil {
		m.tests = make(map[int]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the TestCase entity.
func (m *TestRunMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the TestCase entity was cleared.
func (m *TestRunMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the TestCase entity by IDs.
func (m *TestRunMutation) RemoveTestIDs(ids ...int) {
	if m.removedtests == nil {
		m.removedtests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the TestCase entity.
func (m *TestRunMutation) RemovedTestsIDs() (ids []int) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *TestRunMutation) TestsIDs() (ids []int) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *TestRunMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the TestRunMutation builder.
func (m *TestRunMutation) Where(ps ...predicate.TestRun) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestRunMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestRun).
func (m *TestRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestRunMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tool != nil {
		fields = append(fields, testrun.FieldTool)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testrun.FieldTool:
		return m.Tool()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testrun.FieldTool:
		return m.OldTool(ctx)
	}
	return nil, fmt.Errorf("unknown TestRun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testrun.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	}
	return fmt.Errorf("unknown TestRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestRunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestRunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TestRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestRunMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestRunMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TestRun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestRunMutation) ResetField(name string) error {
	switch name {
	case testrun.FieldTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown TestRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.release != nil {
		edges = append(edges, testrun.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, testrun.EdgeEntry)
	}
	if m.tests != nil {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestRunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testrun.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case testrun.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case testrun.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtests != nil {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestRunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testrun.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelease {
		edges = append(edges, testrun.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, testrun.EdgeEntry)
	}
	if m.clearedtests {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestRunMutation) EdgeCleared(name string) bool {
	switch name {
	case testrun.EdgeRelease:
		return m.clearedrelease
	case testrun.EdgeEntry:
		return m.clearedentry
	case testrun.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestRunMutation) ClearEdge(name string) error {
	switch name {
	case testrun.EdgeRelease:
		m.ClearRelease()
		return nil
	case testrun.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown TestRun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestRunMutation) ResetEdge(name string) error {
	switch name {
	case testrun.EdgeRelease:
		m.ResetRelease()
		return nil
	case testrun.EdgeEntry:
		m.ResetEntry()
		return nil
	case testrun.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown TestRun edge %s", name)
}

// VulnerabilityMutation represents an operation that mutates the Vulnerability nodes in the graph.
type VulnerabilityMutation struct {
	config
	op                Op
	typ               string
	id                *int
	vid               *string
	summary           *string
	description       *string
	severity_score    *float64
	addseverity_score *float64
	severity          *vulnerability.Severity
	published         *time.Time
	modified          *time.Time
	clearedFields     map[string]struct{}
	components        map[int]struct{}
	removedcomponents map[int]struct{}
	clearedcomponents bool
	reviews           map[int]struct{}
	removedreviews    map[int]struct{}
	clearedreviews    bool
	instances         map[int]struct{}
	removedinstances  map[int]struct{}
	clearedinstances  bool
	done              bool
	oldValue          func(context.Context) (*Vulnerability, error)
	predicates        []predicate.Vulnerability
}

var _ ent.Mutation = (*VulnerabilityMutation)(nil)

// vulnerabilityOption allows management of the mutation configuration using functional options.
type vulnerabilityOption func(*VulnerabilityMutation)

// newVulnerabilityMutation creates new mutation for the Vulnerability entity.
func newVulnerabilityMutation(c config, op Op, opts ...vulnerabilityOption) *VulnerabilityMutation {
	m := &VulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityID sets the ID field of the mutation.
func withVulnerabilityID(id int) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Vulnerability
		)
		m.oldValue = func(ctx context.Context) (*Vulnerability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerability sets the old Vulnerability of the mutation.
func withVulnerability(node *Vulnerability) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		m.oldValue = func(context.Context) (*Vulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetVid sets the "vid" field.
func (m *VulnerabilityMutation) SetVid(s string) {
	m.vid = &s
}

// Vid returns the value of the "vid" field in the mutation.
func (m *VulnerabilityMutation) Vid() (r string, exists bool) {
	v := m.vid
	if v == nil {
		return
	}
	return *v, true
}

// OldVid returns the old "vid" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldVid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVid: %w", err)
	}
	return oldValue.Vid, nil
}

// ResetVid resets all changes to the "vid" field.
func (m *VulnerabilityMutation) ResetVid() {
	m.vid = nil
}

// SetSummary sets the "summary" field.
func (m *VulnerabilityMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *VulnerabilityMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *VulnerabilityMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[vulnerability.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *VulnerabilityMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *VulnerabilityMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, vulnerability.FieldSummary)
}

// SetDescription sets the "description" field.
func (m *VulnerabilityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VulnerabilityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VulnerabilityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vulnerability.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VulnerabilityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VulnerabilityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vulnerability.FieldDescription)
}

// SetSeverityScore sets the "severity_score" field.
func (m *VulnerabilityMutation) SetSeverityScore(f float64) {
	m.severity_score = &f
	m.addseverity_score = nil
}

// SeverityScore returns the value of the "severity_score" field in the mutation.
func (m *VulnerabilityMutation) SeverityScore() (r float64, exists bool) {
	v := m.severity_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverityScore returns the old "severity_score" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSeverityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverityScore: %w", err)
	}
	return oldValue.SeverityScore, nil
}

// AddSeverityScore adds f to the "severity_score" field.
func (m *VulnerabilityMutation) AddSeverityScore(f float64) {
	if m.addseverity_score != nil {
		*m.addseverity_score += f
	} else {
		m.addseverity_score = &f
	}
}

// AddedSeverityScore returns the value that was added to the "severity_score" field in this mutation.
func (m *VulnerabilityMutation) AddedSeverityScore() (r float64, exists bool) {
	v := m.addseverity_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeverityScore resets all changes to the "severity_score" field.
func (m *VulnerabilityMutation) ResetSeverityScore() {
	m.severity_score = nil
	m.addseverity_score = nil
}

// SetSeverity sets the "severity" field.
func (m *VulnerabilityMutation) SetSeverity(v vulnerability.Severity) {
	m.severity = &v
}

// Severity returns the value of the "severity" field in the mutation.
func (m *VulnerabilityMutation) Severity() (r vulnerability.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSeverity(ctx context.Context) (v vulnerability.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *VulnerabilityMutation) ResetSeverity() {
	m.severity = nil
}

// SetPublished sets the "published" field.
func (m *VulnerabilityMutation) SetPublished(t time.Time) {
	m.published = &t
}

// Published returns the value of the "published" field in the mutation.
func (m *VulnerabilityMutation) Published() (r time.Time, exists bool) {
	v := m.published
	if v == nil {
		return
	}
	return *v, true
}

// OldPublished returns the old "published" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldPublished(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublished: %w", err)
	}
	return oldValue.Published, nil
}

// ClearPublished clears the value of the "published" field.
func (m *VulnerabilityMutation) ClearPublished() {
	m.published = nil
	m.clearedFields[vulnerability.FieldPublished] = struct{}{}
}

// PublishedCleared returns if the "published" field was cleared in this mutation.
func (m *VulnerabilityMutation) PublishedCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldPublished]
	return ok
}

// ResetPublished resets all changes to the "published" field.
func (m *VulnerabilityMutation) ResetPublished() {
	m.published = nil
	delete(m.clearedFields, vulnerability.FieldPublished)
}

// SetModified sets the "modified" field.
func (m *VulnerabilityMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *VulnerabilityMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *VulnerabilityMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[vulnerability.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *VulnerabilityMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *VulnerabilityMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, vulnerability.FieldModified)
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *VulnerabilityMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *VulnerabilityMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *VulnerabilityMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *VulnerabilityMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *VulnerabilityMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *VulnerabilityMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *VulnerabilityMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddReviewIDs adds the "reviews" edge to the VulnerabilityReview entity by ids.
func (m *VulnerabilityMutation) AddReviewIDs(ids ...int) {
	if m.reviews == nil {
		m.reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the VulnerabilityReview entity.
func (m *VulnerabilityMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the VulnerabilityReview entity was cleared.
func (m *VulnerabilityMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the VulnerabilityReview entity by IDs.
func (m *VulnerabilityMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the VulnerabilityReview entity.
func (m *VulnerabilityMutation) RemovedReviewsIDs() (ids []int) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *VulnerabilityMutation) ReviewsIDs() (ids []int) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *VulnerabilityMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddInstanceIDs adds the "instances" edge to the ReleaseVulnerability entity by ids.
func (m *VulnerabilityMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the ReleaseVulnerability entity was cleared.
func (m *VulnerabilityMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the ReleaseVulnerability entity by IDs.
func (m *VulnerabilityMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *VulnerabilityMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *VulnerabilityMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the VulnerabilityMutation builder.
func (m *VulnerabilityMutation) Where(ps ...predicate.Vulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnerabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vulnerability).
func (m *VulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.vid != nil {
		fields = append(fields, vulnerability.FieldVid)
	}
	if m.summary != nil {
		fields = append(fields, vulnerability.FieldSummary)
	}
	if m.description != nil {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.severity_score != nil {
		fields = append(fields, vulnerability.FieldSeverityScore)
	}
	if m.severity != nil {
		fields = append(fields, vulnerability.FieldSeverity)
	}
	if m.published != nil {
		fields = append(fields, vulnerability.FieldPublished)
	}
	if m.modified != nil {
		fields = append(fields, vulnerability.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldVid:
		return m.Vid()
	case vulnerability.FieldSummary:
		return m.Summary()
	case vulnerability.FieldDescription:
		return m.Description()
	case vulnerability.FieldSeverityScore:
		return m.SeverityScore()
	case vulnerability.FieldSeverity:
		return m.Severity()
	case vulnerability.FieldPublished:
		return m.Published()
	case vulnerability.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerability.FieldVid:
		return m.OldVid(ctx)
	case vulnerability.FieldSummary:
		return m.OldSummary(ctx)
	case vulnerability.FieldDescription:
		return m.OldDescription(ctx)
	case vulnerability.FieldSeverityScore:
		return m.OldSeverityScore(ctx)
	case vulnerability.FieldSeverity:
		return m.OldSeverity(ctx)
	case vulnerability.FieldPublished:
		return m.OldPublished(ctx)
	case vulnerability.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Vulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldVid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVid(v)
		return nil
	case vulnerability.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case vulnerability.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vulnerability.FieldSeverityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverityScore(v)
		return nil
	case vulnerability.FieldSeverity:
		v, ok := value.(vulnerability.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case vulnerability.FieldPublished:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublished(v)
		return nil
	case vulnerability.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityMutation) AddedFields() []string {
	var fields []string
	if m.addseverity_score != nil {
		fields = append(fields, vulnerability.FieldSeverityScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldSeverityScore:
		return m.AddedSeverityScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldSeverityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeverityScore(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vulnerability.FieldSummary) {
		fields = append(fields, vulnerability.FieldSummary)
	}
	if m.FieldCleared(vulnerability.FieldDescription) {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.FieldCleared(vulnerability.FieldPublished) {
		fields = append(fields, vulnerability.FieldPublished)
	}
	if m.FieldCleared(vulnerability.FieldModified) {
		fields = append(fields, vulnerability.FieldModified)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ClearField(name string) error {
	switch name {
	case vulnerability.FieldSummary:
		m.ClearSummary()
		return nil
	case vulnerability.FieldDescription:
		m.ClearDescription()
		return nil
	case vulnerability.FieldPublished:
		m.ClearPublished()
		return nil
	case vulnerability.FieldModified:
		m.ClearModified()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ResetField(name string) error {
	switch name {
	case vulnerability.FieldVid:
		m.ResetVid()
		return nil
	case vulnerability.FieldSummary:
		m.ResetSummary()
		return nil
	case vulnerability.FieldDescription:
		m.ResetDescription()
		return nil
	case vulnerability.FieldSeverityScore:
		m.ResetSeverityScore()
		return nil
	case vulnerability.FieldSeverity:
		m.ResetSeverity()
		return nil
	case vulnerability.FieldPublished:
		m.ResetPublished()
		return nil
	case vulnerability.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.components != nil {
		edges = append(edges, vulnerability.EdgeComponents)
	}
	if m.reviews != nil {
		edges = append(edges, vulnerability.EdgeReviews)
	}
	if m.instances != nil {
		edges = append(edges, vulnerability.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcomponents != nil {
		edges = append(edges, vulnerability.EdgeComponents)
	}
	if m.removedreviews != nil {
		edges = append(edges, vulnerability.EdgeReviews)
	}
	if m.removedinstances != nil {
		edges = append(edges, vulnerability.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcomponents {
		edges = append(edges, vulnerability.EdgeComponents)
	}
	if m.clearedreviews {
		edges = append(edges, vulnerability.EdgeReviews)
	}
	if m.clearedinstances {
		edges = append(edges, vulnerability.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerability.EdgeComponents:
		return m.clearedcomponents
	case vulnerability.EdgeReviews:
		return m.clearedreviews
	case vulnerability.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case vulnerability.EdgeComponents:
		m.ResetComponents()
		return nil
	case vulnerability.EdgeReviews:
		m.ResetReviews()
		return nil
	case vulnerability.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability edge %s", name)
}

// VulnerabilityReviewMutation represents an operation that mutates the VulnerabilityReview nodes in the graph.
type VulnerabilityReviewMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	decision             *vulnerabilityreview.Decision
	clearedFields        map[string]struct{}
	vulnerability        *int
	clearedvulnerability bool
	projects             map[int]struct{}
	removedprojects      map[int]struct{}
	clearedprojects      bool
	repos                map[int]struct{}
	removedrepos         map[int]struct{}
	clearedrepos         bool
	releases             map[int]struct{}
	removedreleases      map[int]struct{}
	clearedreleases      bool
	instances            map[int]struct{}
	removedinstances     map[int]struct{}
	clearedinstances     bool
	done                 bool
	oldValue             func(context.Context) (*VulnerabilityReview, error)
	predicates           []predicate.VulnerabilityReview
}

var _ ent.Mutation = (*VulnerabilityReviewMutation)(nil)

// vulnerabilityreviewOption allows management of the mutation configuration using functional options.
type vulnerabilityreviewOption func(*VulnerabilityReviewMutation)

// newVulnerabilityReviewMutation creates new mutation for the VulnerabilityReview entity.
func newVulnerabilityReviewMutation(c config, op Op, opts ...vulnerabilityreviewOption) *VulnerabilityReviewMutation {
	m := &VulnerabilityReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerabilityReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityReviewID sets the ID field of the mutation.
func withVulnerabilityReviewID(id int) vulnerabilityreviewOption {
	return func(m *VulnerabilityReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnerabilityReview
		)
		m.oldValue = func(ctx context.Context) (*VulnerabilityReview, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnerabilityReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerabilityReview sets the old VulnerabilityReview of the mutation.
func withVulnerabilityReview(node *VulnerabilityReview) vulnerabilityreviewOption {
	return func(m *VulnerabilityReviewMutation) {
		m.oldValue = func(context.Context) (*VulnerabilityReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *VulnerabilityReviewMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VulnerabilityReviewMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VulnerabilityReview entity.
// If the VulnerabilityReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityReviewMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VulnerabilityReviewMutation) ClearName() {
	m.name = nil
	m.clearedFields[vulnerabilityreview.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VulnerabilityReviewMutation) NameCleared() bool {
	_, ok := m.clearedFields[vulnerabilityreview.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VulnerabilityReviewMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, vulnerabilityreview.FieldName)
}

// SetDecision sets the "decision" field.
func (m *VulnerabilityReviewMutation) SetDecision(v vulnerabilityreview.Decision) {
	m.decision = &v
}

// Decision returns the value of the "decision" field in the mutation.
func (m *VulnerabilityReviewMutation) Decision() (r vulnerabilityreview.Decision, exists bool) {
	v := m.decision
	if v == nil {
		return
	}
	return *v, true
}

// OldDecision returns the old "decision" field's value of the VulnerabilityReview entity.
// If the VulnerabilityReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityReviewMutation) OldDecision(ctx context.Context) (v vulnerabilityreview.Decision, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDecision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDecision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecision: %w", err)
	}
	return oldValue.Decision, nil
}

// ResetDecision resets all changes to the "decision" field.
func (m *VulnerabilityReviewMutation) ResetDecision() {
	m.decision = nil
}

// SetVulnerabilityID sets the "vulnerability" edge to the Vulnerability entity by id.
func (m *VulnerabilityReviewMutation) SetVulnerabilityID(id int) {
	m.vulnerability = &id
}

// ClearVulnerability clears the "vulnerability" edge to the Vulnerability entity.
func (m *VulnerabilityReviewMutation) ClearVulnerability() {
	m.clearedvulnerability = true
}

// VulnerabilityCleared reports if the "vulnerability" edge to the Vulnerability entity was cleared.
func (m *VulnerabilityReviewMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityID returns the "vulnerability" edge ID in the mutation.
func (m *VulnerabilityReviewMutation) VulnerabilityID() (id int, exists bool) {
	if m.vulnerability != nil {
		return *m.vulnerability, true
	}
	return
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityReviewMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *VulnerabilityReviewMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *VulnerabilityReviewMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *VulnerabilityReviewMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *VulnerabilityReviewMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *VulnerabilityReviewMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *VulnerabilityReviewMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddRepoIDs adds the "repos" edge to the Repo entity by ids.
func (m *VulnerabilityReviewMutation) AddRepoIDs(ids ...int) {
	if m.repos == nil {
		m.repos = make(map[int]struct{})
	}
	for i := range ids {
		m.repos[ids[i]] = struct{}{}
	}
}

// ClearRepos clears the "repos" edge to the Repo entity.
func (m *VulnerabilityReviewMutation) ClearRepos() {
	m.clearedrepos = true
}

// ReposCleared reports if the "repos" edge to the Repo entity was cleared.
func (m *VulnerabilityReviewMutation) ReposCleared() bool {
	return m.clearedrepos
}

// RemoveRepoIDs removes the "repos" edge to the Repo entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepos == nil {
		m.removedrepos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repos, ids[i])
		m.removedrepos[ids[i]] = struct{}{}
	}
}

// RemovedRepos returns the removed IDs of the "repos" edge to the Repo entity.
func (m *VulnerabilityReviewMutation) RemovedReposIDs() (ids []int) {
	for id := range m.removedrepos {
		ids = append(ids, id)
	}
	return
}

// ReposIDs returns the "repos" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) ReposIDs() (ids []int) {
	for id := range m.repos {
		ids = append(ids, id)
	}
	return
}

// ResetRepos resets all changes to the "repos" edge.
func (m *VulnerabilityReviewMutation) ResetRepos() {
	m.repos = nil
	m.clearedrepos = false
	m.removedrepos = nil
}

// AddReleaseIDs adds the "releases" edge to the Release entity by ids.
func (m *VulnerabilityReviewMutation) AddReleaseIDs(ids ...int) {
	if m.releases == nil {
		m.releases = make(map[int]struct{})
	}
	for i := range ids {
		m.releases[ids[i]] = struct{}{}
	}
}

// ClearReleases clears the "releases" edge to the Release entity.
func (m *VulnerabilityReviewMutation) ClearReleases() {
	m.clearedreleases = true
}

// ReleasesCleared reports if the "releases" edge to the Release entity was cleared.
func (m *VulnerabilityReviewMutation) ReleasesCleared() bool {
	return m.clearedreleases
}

// RemoveReleaseIDs removes the "releases" edge to the Release entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveReleaseIDs(ids ...int) {
	if m.removedreleases == nil {
		m.removedreleases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.releases, ids[i])
		m.removedreleases[ids[i]] = struct{}{}
	}
}

// RemovedReleases returns the removed IDs of the "releases" edge to the Release entity.
func (m *VulnerabilityReviewMutation) RemovedReleasesIDs() (ids []int) {
	for id := range m.removedreleases {
		ids = append(ids, id)
	}
	return
}

// ReleasesIDs returns the "releases" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) ReleasesIDs() (ids []int) {
	for id := range m.releases {
		ids = append(ids, id)
	}
	return
}

// ResetReleases resets all changes to the "releases" edge.
func (m *VulnerabilityReviewMutation) ResetReleases() {
	m.releases = nil
	m.clearedreleases = false
	m.removedreleases = nil
}

// AddInstanceIDs adds the "instances" edge to the ReleaseVulnerability entity by ids.
func (m *VulnerabilityReviewMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityReviewMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the ReleaseVulnerability entity was cleared.
func (m *VulnerabilityReviewMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the ReleaseVulnerability entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityReviewMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *VulnerabilityReviewMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the VulnerabilityReviewMutation builder.
func (m *VulnerabilityReviewMutation) Where(ps ...predicate.VulnerabilityReview) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnerabilityReviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VulnerabilityReview).
func (m *VulnerabilityReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityReviewMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, vulnerabilityreview.FieldName)
	}
	if m.decision != nil {
		fields = append(fields, vulnerabilityreview.FieldDecision)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilityreview.FieldName:
		return m.Name()
	case vulnerabilityreview.FieldDecision:
		return m.Decision()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerabilityreview.FieldName:
		return m.OldName(ctx)
	case vulnerabilityreview.FieldDecision:
		return m.OldDecision(ctx)
	}
	return nil, fmt.Errorf("unknown VulnerabilityReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerabilityreview.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vulnerabilityreview.FieldDecision:
		v, ok := value.(vulnerabilityreview.Decision)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecision(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityReviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityReviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnerabilityReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vulnerabilityreview.FieldName) {
		fields = append(fields, vulnerabilityreview.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityReviewMutation) ClearField(name string) error {
	switch name {
	case vulnerabilityreview.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityReviewMutation) ResetField(name string) error {
	switch name {
	case vulnerabilityreview.FieldName:
		m.ResetName()
		return nil
	case vulnerabilityreview.FieldDecision:
		m.ResetDecision()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.vulnerability != nil {
		edges = append(edges, vulnerabilityreview.EdgeVulnerability)
	}
	if m.projects != nil {
		edges = append(edges, vulnerabilityreview.EdgeProjects)
	}
	if m.repos != nil {
		edges = append(edges, vulnerabilityreview.EdgeRepos)
	}
	if m.releases != nil {
		edges = append(edges, vulnerabilityreview.EdgeReleases)
	}
	if m.instances != nil {
		edges = append(edges, vulnerabilityreview.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	case vulnerabilityreview.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.repos))
		for id := range m.repos {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeReleases:
		ids := make([]ent.Value, 0, len(m.releases))
		for id := range m.releases {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedprojects != nil {
		edges = append(edges, vulnerabilityreview.EdgeProjects)
	}
	if m.removedrepos != nil {
		edges = append(edges, vulnerabilityreview.EdgeRepos)
	}
	if m.removedreleases != nil {
		edges = append(edges, vulnerabilityreview.EdgeReleases)
	}
	if m.removedinstances != nil {
		edges = append(edges, vulnerabilityreview.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityreview.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.removedrepos))
		for id := range m.removedrepos {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeReleases:
		ids := make([]ent.Value, 0, len(m.removedreleases))
		for id := range m.removedreleases {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedvulnerability {
		edges = append(edges, vulnerabilityreview.EdgeVulnerability)
	}
	if m.clearedprojects {
		edges = append(edges, vulnerabilityreview.EdgeProjects)
	}
	if m.clearedrepos {
		edges = append(edges, vulnerabilityreview.EdgeRepos)
	}
	if m.clearedreleases {
		edges = append(edges, vulnerabilityreview.EdgeReleases)
	}
	if m.clearedinstances {
		edges = append(edges, vulnerabilityreview.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		return m.clearedvulnerability
	case vulnerabilityreview.EdgeProjects:
		return m.clearedprojects
	case vulnerabilityreview.EdgeRepos:
		return m.clearedrepos
	case vulnerabilityreview.EdgeReleases:
		return m.clearedreleases
	case vulnerabilityreview.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityReviewMutation) ClearEdge(name string) error {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityReviewMutation) ResetEdge(name string) error {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	case vulnerabilityreview.EdgeProjects:
		m.ResetProjects()
		return nil
	case vulnerabilityreview.EdgeRepos:
		m.ResetRepos()
		return nil
	case vulnerabilityreview.EdgeReleases:
		m.ResetReleases()
		return nil
	case vulnerabilityreview.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview edge %s", name)
}
