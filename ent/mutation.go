// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/valocode/bubbly/ent/adapter"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/event"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/organization"
	"github.com/valocode/bubbly/ent/predicate"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecomponent"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/releaselicense"
	"github.com/valocode/bubbly/ent/releasepolicy"
	"github.com/valocode/bubbly/ent/releasepolicyviolation"
	"github.com/valocode/bubbly/ent/releasevulnerability"
	"github.com/valocode/bubbly/ent/repo"
	schema "github.com/valocode/bubbly/ent/schema/types"
	"github.com/valocode/bubbly/ent/spdxlicense"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/valocode/bubbly/ent/vulnerabilityreview"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdapter                = "Adapter"
	TypeArtifact               = "Artifact"
	TypeCodeIssue              = "CodeIssue"
	TypeCodeScan               = "CodeScan"
	TypeComponent              = "Component"
	TypeEvent                  = "Event"
	TypeGitCommit              = "GitCommit"
	TypeLicense                = "License"
	TypeOrganization           = "Organization"
	TypeProject                = "Project"
	TypeRelease                = "Release"
	TypeReleaseComponent       = "ReleaseComponent"
	TypeReleaseEntry           = "ReleaseEntry"
	TypeReleaseLicense         = "ReleaseLicense"
	TypeReleasePolicy          = "ReleasePolicy"
	TypeReleasePolicyViolation = "ReleasePolicyViolation"
	TypeReleaseVulnerability   = "ReleaseVulnerability"
	TypeRepo                   = "Repo"
	TypeSPDXLicense            = "SPDXLicense"
	TypeTestCase               = "TestCase"
	TypeTestRun                = "TestRun"
	TypeVulnerability          = "Vulnerability"
	TypeVulnerabilityReview    = "VulnerabilityReview"
)

// AdapterMutation represents an operation that mutates the Adapter nodes in the graph.
type AdapterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	tag           *string
	module        *string
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Adapter, error)
	predicates    []predicate.Adapter
}

var _ ent.Mutation = (*AdapterMutation)(nil)

// adapterOption allows management of the mutation configuration using functional options.
type adapterOption func(*AdapterMutation)

// newAdapterMutation creates new mutation for the Adapter entity.
func newAdapterMutation(c config, op Op, opts ...adapterOption) *AdapterMutation {
	m := &AdapterMutation{
		config:        c,
		op:            op,
		typ:           TypeAdapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdapterID sets the ID field of the mutation.
func withAdapterID(id int) adapterOption {
	return func(m *AdapterMutation) {
		var (
			err   error
			once  sync.Once
			value *Adapter
		)
		m.oldValue = func(ctx context.Context) (*Adapter, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Adapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdapter sets the old Adapter of the mutation.
func withAdapter(node *Adapter) adapterOption {
	return func(m *AdapterMutation) {
		m.oldValue = func(context.Context) (*Adapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *AdapterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdapterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdapterMutation) ResetName() {
	m.name = nil
}

// SetTag sets the "tag" field.
func (m *AdapterMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *AdapterMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *AdapterMutation) ResetTag() {
	m.tag = nil
}

// SetModule sets the "module" field.
func (m *AdapterMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *AdapterMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the Adapter entity.
// If the Adapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdapterMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *AdapterMutation) ResetModule() {
	m.module = nil
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *AdapterMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *AdapterMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *AdapterMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AdapterMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AdapterMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AdapterMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AdapterMutation builder.
func (m *AdapterMutation) Where(ps ...predicate.Adapter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdapterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Adapter).
func (m *AdapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdapterMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, adapter.FieldName)
	}
	if m.tag != nil {
		fields = append(fields, adapter.FieldTag)
	}
	if m.module != nil {
		fields = append(fields, adapter.FieldModule)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adapter.FieldName:
		return m.Name()
	case adapter.FieldTag:
		return m.Tag()
	case adapter.FieldModule:
		return m.Module()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adapter.FieldName:
		return m.OldName(ctx)
	case adapter.FieldTag:
		return m.OldTag(ctx)
	case adapter.FieldModule:
		return m.OldModule(ctx)
	}
	return nil, fmt.Errorf("unknown Adapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adapter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case adapter.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case adapter.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	}
	return fmt.Errorf("unknown Adapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdapterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdapterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Adapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdapterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdapterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Adapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdapterMutation) ResetField(name string) error {
	switch name {
	case adapter.FieldName:
		m.ResetName()
		return nil
	case adapter.FieldTag:
		m.ResetTag()
		return nil
	case adapter.FieldModule:
		m.ResetModule()
		return nil
	}
	return fmt.Errorf("unknown Adapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, adapter.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adapter.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, adapter.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdapterMutation) EdgeCleared(name string) bool {
	switch name {
	case adapter.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdapterMutation) ClearEdge(name string) error {
	switch name {
	case adapter.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Adapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdapterMutation) ResetEdge(name string) error {
	switch name {
	case adapter.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Adapter edge %s", name)
}

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	sha256         *string
	_type          *artifact.Type
	time           *time.Time
	metadata       *schema.Metadata
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	entry          *int
	clearedentry   bool
	done           bool
	oldValue       func(context.Context) (*Artifact, error)
	predicates     []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ArtifactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtifactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtifactMutation) ResetName() {
	m.name = nil
}

// SetSha256 sets the "sha256" field.
func (m *ArtifactMutation) SetSha256(s string) {
	m.sha256 = &s
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *ArtifactMutation) Sha256() (r string, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *ArtifactMutation) ResetSha256() {
	m.sha256 = nil
}

// SetType sets the "type" field.
func (m *ArtifactMutation) SetType(a artifact.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *ArtifactMutation) GetType() (r artifact.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldType(ctx context.Context) (v artifact.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ArtifactMutation) ResetType() {
	m._type = nil
}

// SetTime sets the "time" field.
func (m *ArtifactMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *ArtifactMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *ArtifactMutation) ResetTime() {
	m.time = nil
}

// SetMetadata sets the "metadata" field.
func (m *ArtifactMutation) SetMetadata(s schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ArtifactMutation) Metadata() (r schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldMetadata(ctx context.Context) (v schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ArtifactMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[artifact.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ArtifactMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[artifact.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ArtifactMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, artifact.FieldMetadata)
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ArtifactMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ArtifactMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ArtifactMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ArtifactMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ArtifactMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *ArtifactMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *ArtifactMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *ArtifactMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *ArtifactMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *ArtifactMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// Where appends a list predicates to the ArtifactMutation builder.
func (m *ArtifactMutation) Where(ps ...predicate.Artifact) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, artifact.FieldName)
	}
	if m.sha256 != nil {
		fields = append(fields, artifact.FieldSha256)
	}
	if m._type != nil {
		fields = append(fields, artifact.FieldType)
	}
	if m.time != nil {
		fields = append(fields, artifact.FieldTime)
	}
	if m.metadata != nil {
		fields = append(fields, artifact.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldName:
		return m.Name()
	case artifact.FieldSha256:
		return m.Sha256()
	case artifact.FieldType:
		return m.GetType()
	case artifact.FieldTime:
		return m.Time()
	case artifact.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldName:
		return m.OldName(ctx)
	case artifact.FieldSha256:
		return m.OldSha256(ctx)
	case artifact.FieldType:
		return m.OldType(ctx)
	case artifact.FieldTime:
		return m.OldTime(ctx)
	case artifact.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artifact.FieldSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case artifact.FieldType:
		v, ok := value.(artifact.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case artifact.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case artifact.FieldMetadata:
		v, ok := value.(schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artifact.FieldMetadata) {
		fields = append(fields, artifact.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	switch name {
	case artifact.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldName:
		m.ResetName()
		return nil
	case artifact.FieldSha256:
		m.ResetSha256()
		return nil
	case artifact.FieldType:
		m.ResetType()
		return nil
	case artifact.FieldTime:
		m.ResetTime()
		return nil
	case artifact.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.release != nil {
		edges = append(edges, artifact.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, artifact.EdgeEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrelease {
		edges = append(edges, artifact.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, artifact.EdgeEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeRelease:
		return m.clearedrelease
	case artifact.EdgeEntry:
		return m.clearedentry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	case artifact.EdgeRelease:
		m.ClearRelease()
		return nil
	case artifact.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeRelease:
		m.ResetRelease()
		return nil
	case artifact.EdgeEntry:
		m.ResetEntry()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// CodeIssueMutation represents an operation that mutates the CodeIssue nodes in the graph.
type CodeIssueMutation struct {
	config
	op            Op
	typ           string
	id            *int
	rule_id       *string
	message       *string
	severity      *codeissue.Severity
	_type         *codeissue.Type
	metadata      *schema.Metadata
	clearedFields map[string]struct{}
	scan          *int
	clearedscan   bool
	done          bool
	oldValue      func(context.Context) (*CodeIssue, error)
	predicates    []predicate.CodeIssue
}

var _ ent.Mutation = (*CodeIssueMutation)(nil)

// codeissueOption allows management of the mutation configuration using functional options.
type codeissueOption func(*CodeIssueMutation)

// newCodeIssueMutation creates new mutation for the CodeIssue entity.
func newCodeIssueMutation(c config, op Op, opts ...codeissueOption) *CodeIssueMutation {
	m := &CodeIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeIssueID sets the ID field of the mutation.
func withCodeIssueID(id int) codeissueOption {
	return func(m *CodeIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeIssue
		)
		m.oldValue = func(ctx context.Context) (*CodeIssue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeIssue sets the old CodeIssue of the mutation.
func withCodeIssue(node *CodeIssue) codeissueOption {
	return func(m *CodeIssueMutation) {
		m.oldValue = func(context.Context) (*CodeIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeIssueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRuleID sets the "rule_id" field.
func (m *CodeIssueMutation) SetRuleID(s string) {
	m.rule_id = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *CodeIssueMutation) RuleID() (r string, exists bool) {
	v := m.rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *CodeIssueMutation) ResetRuleID() {
	m.rule_id = nil
}

// SetMessage sets the "message" field.
func (m *CodeIssueMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CodeIssueMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CodeIssueMutation) ResetMessage() {
	m.message = nil
}

// SetSeverity sets the "severity" field.
func (m *CodeIssueMutation) SetSeverity(c codeissue.Severity) {
	m.severity = &c
}

// Severity returns the value of the "severity" field in the mutation.
func (m *CodeIssueMutation) Severity() (r codeissue.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldSeverity(ctx context.Context) (v codeissue.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *CodeIssueMutation) ResetSeverity() {
	m.severity = nil
}

// SetType sets the "type" field.
func (m *CodeIssueMutation) SetType(c codeissue.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CodeIssueMutation) GetType() (r codeissue.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldType(ctx context.Context) (v codeissue.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CodeIssueMutation) ResetType() {
	m._type = nil
}

// SetMetadata sets the "metadata" field.
func (m *CodeIssueMutation) SetMetadata(s schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CodeIssueMutation) Metadata() (r schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldMetadata(ctx context.Context) (v schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CodeIssueMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[codeissue.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CodeIssueMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[codeissue.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CodeIssueMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, codeissue.FieldMetadata)
}

// SetScanID sets the "scan" edge to the CodeScan entity by id.
func (m *CodeIssueMutation) SetScanID(id int) {
	m.scan = &id
}

// ClearScan clears the "scan" edge to the CodeScan entity.
func (m *CodeIssueMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the CodeScan entity was cleared.
func (m *CodeIssueMutation) ScanCleared() bool {
	return m.clearedscan
}

// ScanID returns the "scan" edge ID in the mutation.
func (m *CodeIssueMutation) ScanID() (id int, exists bool) {
	if m.scan != nil {
		return *m.scan, true
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScanID instead. It exists only for internal usage by the builders.
func (m *CodeIssueMutation) ScanIDs() (ids []int) {
	if id := m.scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *CodeIssueMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
}

// Where appends a list predicates to the CodeIssueMutation builder.
func (m *CodeIssueMutation) Where(ps ...predicate.CodeIssue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodeIssueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodeIssue).
func (m *CodeIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeIssueMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.rule_id != nil {
		fields = append(fields, codeissue.FieldRuleID)
	}
	if m.message != nil {
		fields = append(fields, codeissue.FieldMessage)
	}
	if m.severity != nil {
		fields = append(fields, codeissue.FieldSeverity)
	}
	if m._type != nil {
		fields = append(fields, codeissue.FieldType)
	}
	if m.metadata != nil {
		fields = append(fields, codeissue.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codeissue.FieldRuleID:
		return m.RuleID()
	case codeissue.FieldMessage:
		return m.Message()
	case codeissue.FieldSeverity:
		return m.Severity()
	case codeissue.FieldType:
		return m.GetType()
	case codeissue.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codeissue.FieldRuleID:
		return m.OldRuleID(ctx)
	case codeissue.FieldMessage:
		return m.OldMessage(ctx)
	case codeissue.FieldSeverity:
		return m.OldSeverity(ctx)
	case codeissue.FieldType:
		return m.OldType(ctx)
	case codeissue.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown CodeIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codeissue.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case codeissue.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case codeissue.FieldSeverity:
		v, ok := value.(codeissue.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case codeissue.FieldType:
		v, ok := value.(codeissue.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case codeissue.FieldMetadata:
		v, ok := value.(schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown CodeIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeIssueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeIssueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodeIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeIssueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(codeissue.FieldMetadata) {
		fields = append(fields, codeissue.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeIssueMutation) ClearField(name string) error {
	switch name {
	case codeissue.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeIssueMutation) ResetField(name string) error {
	switch name {
	case codeissue.FieldRuleID:
		m.ResetRuleID()
		return nil
	case codeissue.FieldMessage:
		m.ResetMessage()
		return nil
	case codeissue.FieldSeverity:
		m.ResetSeverity()
		return nil
	case codeissue.FieldType:
		m.ResetType()
		return nil
	case codeissue.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.scan != nil {
		edges = append(edges, codeissue.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeIssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codeissue.EdgeScan:
		if id := m.scan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeIssueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedscan {
		edges = append(edges, codeissue.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeIssueMutation) EdgeCleared(name string) bool {
	switch name {
	case codeissue.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeIssueMutation) ClearEdge(name string) error {
	switch name {
	case codeissue.EdgeScan:
		m.ClearScan()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeIssueMutation) ResetEdge(name string) error {
	switch name {
	case codeissue.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue edge %s", name)
}

// CodeScanMutation represents an operation that mutates the CodeScan nodes in the graph.
type CodeScanMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	tool                   *string
	time                   *time.Time
	metadata               *schema.Metadata
	clearedFields          map[string]struct{}
	release                *int
	clearedrelease         bool
	entry                  *int
	clearedentry           bool
	issues                 map[int]struct{}
	removedissues          map[int]struct{}
	clearedissues          bool
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	licenses               map[int]struct{}
	removedlicenses        map[int]struct{}
	clearedlicenses        bool
	components             map[int]struct{}
	removedcomponents      map[int]struct{}
	clearedcomponents      bool
	done                   bool
	oldValue               func(context.Context) (*CodeScan, error)
	predicates             []predicate.CodeScan
}

var _ ent.Mutation = (*CodeScanMutation)(nil)

// codescanOption allows management of the mutation configuration using functional options.
type codescanOption func(*CodeScanMutation)

// newCodeScanMutation creates new mutation for the CodeScan entity.
func newCodeScanMutation(c config, op Op, opts ...codescanOption) *CodeScanMutation {
	m := &CodeScanMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeScanID sets the ID field of the mutation.
func withCodeScanID(id int) codescanOption {
	return func(m *CodeScanMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeScan
		)
		m.oldValue = func(ctx context.Context) (*CodeScan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeScan sets the old CodeScan of the mutation.
func withCodeScan(node *CodeScan) codescanOption {
	return func(m *CodeScanMutation) {
		m.oldValue = func(context.Context) (*CodeScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *CodeScanMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *CodeScanMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the CodeScan entity.
// If the CodeScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeScanMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *CodeScanMutation) ResetTool() {
	m.tool = nil
}

// SetTime sets the "time" field.
func (m *CodeScanMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *CodeScanMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the CodeScan entity.
// If the CodeScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeScanMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *CodeScanMutation) ResetTime() {
	m.time = nil
}

// SetMetadata sets the "metadata" field.
func (m *CodeScanMutation) SetMetadata(s schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *CodeScanMutation) Metadata() (r schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the CodeScan entity.
// If the CodeScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeScanMutation) OldMetadata(ctx context.Context) (v schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *CodeScanMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[codescan.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *CodeScanMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[codescan.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *CodeScanMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, codescan.FieldMetadata)
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *CodeScanMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *CodeScanMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *CodeScanMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *CodeScanMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *CodeScanMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *CodeScanMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *CodeScanMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *CodeScanMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *CodeScanMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *CodeScanMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *CodeScanMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *CodeScanMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// AddIssueIDs adds the "issues" edge to the CodeIssue entity by ids.
func (m *CodeScanMutation) AddIssueIDs(ids ...int) {
	if m.issues == nil {
		m.issues = make(map[int]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the CodeIssue entity.
func (m *CodeScanMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the CodeIssue entity was cleared.
func (m *CodeScanMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the CodeIssue entity by IDs.
func (m *CodeScanMutation) RemoveIssueIDs(ids ...int) {
	if m.removedissues == nil {
		m.removedissues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the CodeIssue entity.
func (m *CodeScanMutation) RemovedIssuesIDs() (ids []int) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *CodeScanMutation) IssuesIDs() (ids []int) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *CodeScanMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the ReleaseVulnerability entity by ids.
func (m *CodeScanMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *CodeScanMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the ReleaseVulnerability entity was cleared.
func (m *CodeScanMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the ReleaseVulnerability entity by IDs.
func (m *CodeScanMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *CodeScanMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *CodeScanMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *CodeScanMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddLicenseIDs adds the "licenses" edge to the ReleaseLicense entity by ids.
func (m *CodeScanMutation) AddLicenseIDs(ids ...int) {
	if m.licenses == nil {
		m.licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.licenses[ids[i]] = struct{}{}
	}
}

// ClearLicenses clears the "licenses" edge to the ReleaseLicense entity.
func (m *CodeScanMutation) ClearLicenses() {
	m.clearedlicenses = true
}

// LicensesCleared reports if the "licenses" edge to the ReleaseLicense entity was cleared.
func (m *CodeScanMutation) LicensesCleared() bool {
	return m.clearedlicenses
}

// RemoveLicenseIDs removes the "licenses" edge to the ReleaseLicense entity by IDs.
func (m *CodeScanMutation) RemoveLicenseIDs(ids ...int) {
	if m.removedlicenses == nil {
		m.removedlicenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.licenses, ids[i])
		m.removedlicenses[ids[i]] = struct{}{}
	}
}

// RemovedLicenses returns the removed IDs of the "licenses" edge to the ReleaseLicense entity.
func (m *CodeScanMutation) RemovedLicensesIDs() (ids []int) {
	for id := range m.removedlicenses {
		ids = append(ids, id)
	}
	return
}

// LicensesIDs returns the "licenses" edge IDs in the mutation.
func (m *CodeScanMutation) LicensesIDs() (ids []int) {
	for id := range m.licenses {
		ids = append(ids, id)
	}
	return
}

// ResetLicenses resets all changes to the "licenses" edge.
func (m *CodeScanMutation) ResetLicenses() {
	m.licenses = nil
	m.clearedlicenses = false
	m.removedlicenses = nil
}

// AddComponentIDs adds the "components" edge to the ReleaseComponent entity by ids.
func (m *CodeScanMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ReleaseComponent entity.
func (m *CodeScanMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ReleaseComponent entity was cleared.
func (m *CodeScanMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ReleaseComponent entity by IDs.
func (m *CodeScanMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ReleaseComponent entity.
func (m *CodeScanMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *CodeScanMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *CodeScanMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// Where appends a list predicates to the CodeScanMutation builder.
func (m *CodeScanMutation) Where(ps ...predicate.CodeScan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CodeScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodeScan).
func (m *CodeScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeScanMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tool != nil {
		fields = append(fields, codescan.FieldTool)
	}
	if m.time != nil {
		fields = append(fields, codescan.FieldTime)
	}
	if m.metadata != nil {
		fields = append(fields, codescan.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codescan.FieldTool:
		return m.Tool()
	case codescan.FieldTime:
		return m.Time()
	case codescan.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codescan.FieldTool:
		return m.OldTool(ctx)
	case codescan.FieldTime:
		return m.OldTime(ctx)
	case codescan.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown CodeScan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codescan.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	case codescan.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case codescan.FieldMetadata:
		v, ok := value.(schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown CodeScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodeScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeScanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(codescan.FieldMetadata) {
		fields = append(fields, codescan.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeScanMutation) ClearField(name string) error {
	switch name {
	case codescan.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown CodeScan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeScanMutation) ResetField(name string) error {
	switch name {
	case codescan.FieldTool:
		m.ResetTool()
		return nil
	case codescan.FieldTime:
		m.ResetTime()
		return nil
	case codescan.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown CodeScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.release != nil {
		edges = append(edges, codescan.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, codescan.EdgeEntry)
	}
	if m.issues != nil {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, codescan.EdgeVulnerabilities)
	}
	if m.licenses != nil {
		edges = append(edges, codescan.EdgeLicenses)
	}
	if m.components != nil {
		edges = append(edges, codescan.EdgeComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codescan.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case codescan.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case codescan.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.licenses))
		for id := range m.licenses {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedissues != nil {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, codescan.EdgeVulnerabilities)
	}
	if m.removedlicenses != nil {
		edges = append(edges, codescan.EdgeLicenses)
	}
	if m.removedcomponents != nil {
		edges = append(edges, codescan.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case codescan.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.removedlicenses))
		for id := range m.removedlicenses {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedrelease {
		edges = append(edges, codescan.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, codescan.EdgeEntry)
	}
	if m.clearedissues {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, codescan.EdgeVulnerabilities)
	}
	if m.clearedlicenses {
		edges = append(edges, codescan.EdgeLicenses)
	}
	if m.clearedcomponents {
		edges = append(edges, codescan.EdgeComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeScanMutation) EdgeCleared(name string) bool {
	switch name {
	case codescan.EdgeRelease:
		return m.clearedrelease
	case codescan.EdgeEntry:
		return m.clearedentry
	case codescan.EdgeIssues:
		return m.clearedissues
	case codescan.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case codescan.EdgeLicenses:
		return m.clearedlicenses
	case codescan.EdgeComponents:
		return m.clearedcomponents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeScanMutation) ClearEdge(name string) error {
	switch name {
	case codescan.EdgeRelease:
		m.ClearRelease()
		return nil
	case codescan.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown CodeScan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeScanMutation) ResetEdge(name string) error {
	switch name {
	case codescan.EdgeRelease:
		m.ResetRelease()
		return nil
	case codescan.EdgeEntry:
		m.ResetEntry()
		return nil
	case codescan.EdgeIssues:
		m.ResetIssues()
		return nil
	case codescan.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case codescan.EdgeLicenses:
		m.ResetLicenses()
		return nil
	case codescan.EdgeComponents:
		m.ResetComponents()
		return nil
	}
	return fmt.Errorf("unknown CodeScan edge %s", name)
}

// ComponentMutation represents an operation that mutates the Component nodes in the graph.
type ComponentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	scheme                 *string
	namespace              *string
	name                   *string
	version                *string
	description            *string
	url                    *string
	metadata               *schema.Metadata
	labels                 *schema.Labels
	clearedFields          map[string]struct{}
	owner                  *int
	clearedowner           bool
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	licenses               map[int]struct{}
	removedlicenses        map[int]struct{}
	clearedlicenses        bool
	uses                   map[int]struct{}
	removeduses            map[int]struct{}
	cleareduses            bool
	done                   bool
	oldValue               func(context.Context) (*Component, error)
	predicates             []predicate.Component
}

var _ ent.Mutation = (*ComponentMutation)(nil)

// componentOption allows management of the mutation configuration using functional options.
type componentOption func(*ComponentMutation)

// newComponentMutation creates new mutation for the Component entity.
func newComponentMutation(c config, op Op, opts ...componentOption) *ComponentMutation {
	m := &ComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComponentID sets the ID field of the mutation.
func withComponentID(id int) componentOption {
	return func(m *ComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *Component
		)
		m.oldValue = func(ctx context.Context) (*Component, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Component.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComponent sets the old Component of the mutation.
func withComponent(node *Component) componentOption {
	return func(m *ComponentMutation) {
		m.oldValue = func(context.Context) (*Component, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComponentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetScheme sets the "scheme" field.
func (m *ComponentMutation) SetScheme(s string) {
	m.scheme = &s
}

// Scheme returns the value of the "scheme" field in the mutation.
func (m *ComponentMutation) Scheme() (r string, exists bool) {
	v := m.scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldScheme returns the old "scheme" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldScheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheme: %w", err)
	}
	return oldValue.Scheme, nil
}

// ResetScheme resets all changes to the "scheme" field.
func (m *ComponentMutation) ResetScheme() {
	m.scheme = nil
}

// SetNamespace sets the "namespace" field.
func (m *ComponentMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *ComponentMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *ComponentMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *ComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ComponentMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *ComponentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ComponentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ComponentMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *ComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ComponentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[component.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ComponentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[component.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ComponentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, component.FieldDescription)
}

// SetURL sets the "url" field.
func (m *ComponentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ComponentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ComponentMutation) ClearURL() {
	m.url = nil
	m.clearedFields[component.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ComponentMutation) URLCleared() bool {
	_, ok := m.clearedFields[component.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ComponentMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, component.FieldURL)
}

// SetMetadata sets the "metadata" field.
func (m *ComponentMutation) SetMetadata(s schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ComponentMutation) Metadata() (r schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldMetadata(ctx context.Context) (v schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ComponentMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[component.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ComponentMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[component.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ComponentMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, component.FieldMetadata)
}

// SetLabels sets the "labels" field.
func (m *ComponentMutation) SetLabels(s schema.Labels) {
	m.labels = &s
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ComponentMutation) Labels() (r schema.Labels, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldLabels(ctx context.Context) (v schema.Labels, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ComponentMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[component.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ComponentMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[component.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ComponentMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, component.FieldLabels)
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *ComponentMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *ComponentMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *ComponentMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ComponentMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ComponentMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ComponentMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the Vulnerability entity by ids.
func (m *ComponentMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the Vulnerability entity.
func (m *ComponentMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the Vulnerability entity was cleared.
func (m *ComponentMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the Vulnerability entity by IDs.
func (m *ComponentMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the Vulnerability entity.
func (m *ComponentMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *ComponentMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *ComponentMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddLicenseIDs adds the "licenses" edge to the License entity by ids.
func (m *ComponentMutation) AddLicenseIDs(ids ...int) {
	if m.licenses == nil {
		m.licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.licenses[ids[i]] = struct{}{}
	}
}

// ClearLicenses clears the "licenses" edge to the License entity.
func (m *ComponentMutation) ClearLicenses() {
	m.clearedlicenses = true
}

// LicensesCleared reports if the "licenses" edge to the License entity was cleared.
func (m *ComponentMutation) LicensesCleared() bool {
	return m.clearedlicenses
}

// RemoveLicenseIDs removes the "licenses" edge to the License entity by IDs.
func (m *ComponentMutation) RemoveLicenseIDs(ids ...int) {
	if m.removedlicenses == nil {
		m.removedlicenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.licenses, ids[i])
		m.removedlicenses[ids[i]] = struct{}{}
	}
}

// RemovedLicenses returns the removed IDs of the "licenses" edge to the License entity.
func (m *ComponentMutation) RemovedLicensesIDs() (ids []int) {
	for id := range m.removedlicenses {
		ids = append(ids, id)
	}
	return
}

// LicensesIDs returns the "licenses" edge IDs in the mutation.
func (m *ComponentMutation) LicensesIDs() (ids []int) {
	for id := range m.licenses {
		ids = append(ids, id)
	}
	return
}

// ResetLicenses resets all changes to the "licenses" edge.
func (m *ComponentMutation) ResetLicenses() {
	m.licenses = nil
	m.clearedlicenses = false
	m.removedlicenses = nil
}

// AddUseIDs adds the "uses" edge to the ReleaseComponent entity by ids.
func (m *ComponentMutation) AddUseIDs(ids ...int) {
	if m.uses == nil {
		m.uses = make(map[int]struct{})
	}
	for i := range ids {
		m.uses[ids[i]] = struct{}{}
	}
}

// ClearUses clears the "uses" edge to the ReleaseComponent entity.
func (m *ComponentMutation) ClearUses() {
	m.cleareduses = true
}

// UsesCleared reports if the "uses" edge to the ReleaseComponent entity was cleared.
func (m *ComponentMutation) UsesCleared() bool {
	return m.cleareduses
}

// RemoveUseIDs removes the "uses" edge to the ReleaseComponent entity by IDs.
func (m *ComponentMutation) RemoveUseIDs(ids ...int) {
	if m.removeduses == nil {
		m.removeduses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.uses, ids[i])
		m.removeduses[ids[i]] = struct{}{}
	}
}

// RemovedUses returns the removed IDs of the "uses" edge to the ReleaseComponent entity.
func (m *ComponentMutation) RemovedUsesIDs() (ids []int) {
	for id := range m.removeduses {
		ids = append(ids, id)
	}
	return
}

// UsesIDs returns the "uses" edge IDs in the mutation.
func (m *ComponentMutation) UsesIDs() (ids []int) {
	for id := range m.uses {
		ids = append(ids, id)
	}
	return
}

// ResetUses resets all changes to the "uses" edge.
func (m *ComponentMutation) ResetUses() {
	m.uses = nil
	m.cleareduses = false
	m.removeduses = nil
}

// Where appends a list predicates to the ComponentMutation builder.
func (m *ComponentMutation) Where(ps ...predicate.Component) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ComponentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Component).
func (m *ComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComponentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.scheme != nil {
		fields = append(fields, component.FieldScheme)
	}
	if m.namespace != nil {
		fields = append(fields, component.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, component.FieldName)
	}
	if m.version != nil {
		fields = append(fields, component.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, component.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, component.FieldURL)
	}
	if m.metadata != nil {
		fields = append(fields, component.FieldMetadata)
	}
	if m.labels != nil {
		fields = append(fields, component.FieldLabels)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case component.FieldScheme:
		return m.Scheme()
	case component.FieldNamespace:
		return m.Namespace()
	case component.FieldName:
		return m.Name()
	case component.FieldVersion:
		return m.Version()
	case component.FieldDescription:
		return m.Description()
	case component.FieldURL:
		return m.URL()
	case component.FieldMetadata:
		return m.Metadata()
	case component.FieldLabels:
		return m.Labels()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case component.FieldScheme:
		return m.OldScheme(ctx)
	case component.FieldNamespace:
		return m.OldNamespace(ctx)
	case component.FieldName:
		return m.OldName(ctx)
	case component.FieldVersion:
		return m.OldVersion(ctx)
	case component.FieldDescription:
		return m.OldDescription(ctx)
	case component.FieldURL:
		return m.OldURL(ctx)
	case component.FieldMetadata:
		return m.OldMetadata(ctx)
	case component.FieldLabels:
		return m.OldLabels(ctx)
	}
	return nil, fmt.Errorf("unknown Component field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case component.FieldScheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheme(v)
		return nil
	case component.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case component.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case component.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case component.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case component.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case component.FieldMetadata:
		v, ok := value.(schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case component.FieldLabels:
		v, ok := value.(schema.Labels)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Component numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(component.FieldDescription) {
		fields = append(fields, component.FieldDescription)
	}
	if m.FieldCleared(component.FieldURL) {
		fields = append(fields, component.FieldURL)
	}
	if m.FieldCleared(component.FieldMetadata) {
		fields = append(fields, component.FieldMetadata)
	}
	if m.FieldCleared(component.FieldLabels) {
		fields = append(fields, component.FieldLabels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComponentMutation) ClearField(name string) error {
	switch name {
	case component.FieldDescription:
		m.ClearDescription()
		return nil
	case component.FieldURL:
		m.ClearURL()
		return nil
	case component.FieldMetadata:
		m.ClearMetadata()
		return nil
	case component.FieldLabels:
		m.ClearLabels()
		return nil
	}
	return fmt.Errorf("unknown Component nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComponentMutation) ResetField(name string) error {
	switch name {
	case component.FieldScheme:
		m.ResetScheme()
		return nil
	case component.FieldNamespace:
		m.ResetNamespace()
		return nil
	case component.FieldName:
		m.ResetName()
		return nil
	case component.FieldVersion:
		m.ResetVersion()
		return nil
	case component.FieldDescription:
		m.ResetDescription()
		return nil
	case component.FieldURL:
		m.ResetURL()
		return nil
	case component.FieldMetadata:
		m.ResetMetadata()
		return nil
	case component.FieldLabels:
		m.ResetLabels()
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, component.EdgeOwner)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.licenses != nil {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.uses != nil {
		edges = append(edges, component.EdgeUses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case component.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.licenses))
		for id := range m.licenses {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeUses:
		ids := make([]ent.Value, 0, len(m.uses))
		for id := range m.uses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedvulnerabilities != nil {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.removedlicenses != nil {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.removeduses != nil {
		edges = append(edges, component.EdgeUses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.removedlicenses))
		for id := range m.removedlicenses {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeUses:
		ids := make([]ent.Value, 0, len(m.removeduses))
		for id := range m.removeduses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, component.EdgeOwner)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.clearedlicenses {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.cleareduses {
		edges = append(edges, component.EdgeUses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case component.EdgeOwner:
		return m.clearedowner
	case component.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case component.EdgeLicenses:
		return m.clearedlicenses
	case component.EdgeUses:
		return m.cleareduses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComponentMutation) ClearEdge(name string) error {
	switch name {
	case component.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Component unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComponentMutation) ResetEdge(name string) error {
	switch name {
	case component.EdgeOwner:
		m.ResetOwner()
		return nil
	case component.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case component.EdgeLicenses:
		m.ResetLicenses()
		return nil
	case component.EdgeUses:
		m.ResetUses()
		return nil
	}
	return fmt.Errorf("unknown Component edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	message        *string
	status         *event.Status
	_type          *event.Type
	time           *time.Time
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	repo           *int
	clearedrepo    bool
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*Event, error)
	predicates     []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMessage sets the "message" field.
func (m *EventMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *EventMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *EventMutation) ResetMessage() {
	m.message = nil
}

// SetStatus sets the "status" field.
func (m *EventMutation) SetStatus(e event.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EventMutation) Status() (r event.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStatus(ctx context.Context) (v event.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *EventMutation) SetType(e event.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *EventMutation) GetType() (r event.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldType(ctx context.Context) (v event.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EventMutation) ResetType() {
	m._type = nil
}

// SetTime sets the "time" field.
func (m *EventMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *EventMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *EventMutation) ResetTime() {
	m.time = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *EventMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *EventMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *EventMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *EventMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *EventMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *EventMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetRepoID sets the "repo" edge to the Repo entity by id.
func (m *EventMutation) SetRepoID(id int) {
	m.repo = &id
}

// ClearRepo clears the "repo" edge to the Repo entity.
func (m *EventMutation) ClearRepo() {
	m.clearedrepo = true
}

// RepoCleared reports if the "repo" edge to the Repo entity was cleared.
func (m *EventMutation) RepoCleared() bool {
	return m.clearedrepo
}

// RepoID returns the "repo" edge ID in the mutation.
func (m *EventMutation) RepoID() (id int, exists bool) {
	if m.repo != nil {
		return *m.repo, true
	}
	return
}

// RepoIDs returns the "repo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepoID instead. It exists only for internal usage by the builders.
func (m *EventMutation) RepoIDs() (ids []int) {
	if id := m.repo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepo resets all changes to the "repo" edge.
func (m *EventMutation) ResetRepo() {
	m.repo = nil
	m.clearedrepo = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *EventMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *EventMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *EventMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *EventMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *EventMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *EventMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.message != nil {
		fields = append(fields, event.FieldMessage)
	}
	if m.status != nil {
		fields = append(fields, event.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, event.FieldType)
	}
	if m.time != nil {
		fields = append(fields, event.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldMessage:
		return m.Message()
	case event.FieldStatus:
		return m.Status()
	case event.FieldType:
		return m.GetType()
	case event.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldMessage:
		return m.OldMessage(ctx)
	case event.FieldStatus:
		return m.OldStatus(ctx)
	case event.FieldType:
		return m.OldType(ctx)
	case event.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case event.FieldStatus:
		v, ok := value.(event.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case event.FieldType:
		v, ok := value.(event.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case event.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldMessage:
		m.ResetMessage()
		return nil
	case event.FieldStatus:
		m.ResetStatus()
		return nil
	case event.FieldType:
		m.ResetType()
		return nil
	case event.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.release != nil {
		edges = append(edges, event.EdgeRelease)
	}
	if m.repo != nil {
		edges = append(edges, event.EdgeRepo)
	}
	if m.project != nil {
		edges = append(edges, event.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeRepo:
		if id := m.repo; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelease {
		edges = append(edges, event.EdgeRelease)
	}
	if m.clearedrepo {
		edges = append(edges, event.EdgeRepo)
	}
	if m.clearedproject {
		edges = append(edges, event.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeRelease:
		return m.clearedrelease
	case event.EdgeRepo:
		return m.clearedrepo
	case event.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeRelease:
		m.ClearRelease()
		return nil
	case event.EdgeRepo:
		m.ClearRepo()
		return nil
	case event.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeRelease:
		m.ResetRelease()
		return nil
	case event.EdgeRepo:
		m.ResetRepo()
		return nil
	case event.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// GitCommitMutation represents an operation that mutates the GitCommit nodes in the graph.
type GitCommitMutation struct {
	config
	op             Op
	typ            string
	id             *int
	hash           *string
	branch         *string
	tag            *string
	time           *time.Time
	clearedFields  map[string]struct{}
	repo           *int
	clearedrepo    bool
	release        *int
	clearedrelease bool
	done           bool
	oldValue       func(context.Context) (*GitCommit, error)
	predicates     []predicate.GitCommit
}

var _ ent.Mutation = (*GitCommitMutation)(nil)

// gitcommitOption allows management of the mutation configuration using functional options.
type gitcommitOption func(*GitCommitMutation)

// newGitCommitMutation creates new mutation for the GitCommit entity.
func newGitCommitMutation(c config, op Op, opts ...gitcommitOption) *GitCommitMutation {
	m := &GitCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeGitCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitCommitID sets the ID field of the mutation.
func withGitCommitID(id int) gitcommitOption {
	return func(m *GitCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *GitCommit
		)
		m.oldValue = func(ctx context.Context) (*GitCommit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitCommit sets the old GitCommit of the mutation.
func withGitCommit(node *GitCommit) gitcommitOption {
	return func(m *GitCommitMutation) {
		m.oldValue = func(context.Context) (*GitCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitCommitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHash sets the "hash" field.
func (m *GitCommitMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *GitCommitMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *GitCommitMutation) ResetHash() {
	m.hash = nil
}

// SetBranch sets the "branch" field.
func (m *GitCommitMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *GitCommitMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *GitCommitMutation) ResetBranch() {
	m.branch = nil
}

// SetTag sets the "tag" field.
func (m *GitCommitMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *GitCommitMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *GitCommitMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[gitcommit.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *GitCommitMutation) TagCleared() bool {
	_, ok := m.clearedFields[gitcommit.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *GitCommitMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, gitcommit.FieldTag)
}

// SetTime sets the "time" field.
func (m *GitCommitMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *GitCommitMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *GitCommitMutation) ResetTime() {
	m.time = nil
}

// SetRepoID sets the "repo" edge to the Repo entity by id.
func (m *GitCommitMutation) SetRepoID(id int) {
	m.repo = &id
}

// ClearRepo clears the "repo" edge to the Repo entity.
func (m *GitCommitMutation) ClearRepo() {
	m.clearedrepo = true
}

// RepoCleared reports if the "repo" edge to the Repo entity was cleared.
func (m *GitCommitMutation) RepoCleared() bool {
	return m.clearedrepo
}

// RepoID returns the "repo" edge ID in the mutation.
func (m *GitCommitMutation) RepoID() (id int, exists bool) {
	if m.repo != nil {
		return *m.repo, true
	}
	return
}

// RepoIDs returns the "repo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepoID instead. It exists only for internal usage by the builders.
func (m *GitCommitMutation) RepoIDs() (ids []int) {
	if id := m.repo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepo resets all changes to the "repo" edge.
func (m *GitCommitMutation) ResetRepo() {
	m.repo = nil
	m.clearedrepo = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *GitCommitMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *GitCommitMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *GitCommitMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *GitCommitMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *GitCommitMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *GitCommitMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Where appends a list predicates to the GitCommitMutation builder.
func (m *GitCommitMutation) Where(ps ...predicate.GitCommit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GitCommitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GitCommit).
func (m *GitCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitCommitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.hash != nil {
		fields = append(fields, gitcommit.FieldHash)
	}
	if m.branch != nil {
		fields = append(fields, gitcommit.FieldBranch)
	}
	if m.tag != nil {
		fields = append(fields, gitcommit.FieldTag)
	}
	if m.time != nil {
		fields = append(fields, gitcommit.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gitcommit.FieldHash:
		return m.Hash()
	case gitcommit.FieldBranch:
		return m.Branch()
	case gitcommit.FieldTag:
		return m.Tag()
	case gitcommit.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gitcommit.FieldHash:
		return m.OldHash(ctx)
	case gitcommit.FieldBranch:
		return m.OldBranch(ctx)
	case gitcommit.FieldTag:
		return m.OldTag(ctx)
	case gitcommit.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown GitCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gitcommit.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case gitcommit.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case gitcommit.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case gitcommit.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitCommitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitCommitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GitCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitCommitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gitcommit.FieldTag) {
		fields = append(fields, gitcommit.FieldTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitCommitMutation) ClearField(name string) error {
	switch name {
	case gitcommit.FieldTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown GitCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitCommitMutation) ResetField(name string) error {
	switch name {
	case gitcommit.FieldHash:
		m.ResetHash()
		return nil
	case gitcommit.FieldBranch:
		m.ResetBranch()
		return nil
	case gitcommit.FieldTag:
		m.ResetTag()
		return nil
	case gitcommit.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repo != nil {
		edges = append(edges, gitcommit.EdgeRepo)
	}
	if m.release != nil {
		edges = append(edges, gitcommit.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gitcommit.EdgeRepo:
		if id := m.repo; id != nil {
			return []ent.Value{*id}
		}
	case gitcommit.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepo {
		edges = append(edges, gitcommit.EdgeRepo)
	}
	if m.clearedrelease {
		edges = append(edges, gitcommit.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case gitcommit.EdgeRepo:
		return m.clearedrepo
	case gitcommit.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitCommitMutation) ClearEdge(name string) error {
	switch name {
	case gitcommit.EdgeRepo:
		m.ClearRepo()
		return nil
	case gitcommit.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown GitCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitCommitMutation) ResetEdge(name string) error {
	switch name {
	case gitcommit.EdgeRepo:
		m.ResetRepo()
		return nil
	case gitcommit.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown GitCommit edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                Op
	typ               string
	id                *int
	license_id        *string
	name              *string
	clearedFields     map[string]struct{}
	owner             *int
	clearedowner      bool
	spdx              *int
	clearedspdx       bool
	components        map[int]struct{}
	removedcomponents map[int]struct{}
	clearedcomponents bool
	instances         map[int]struct{}
	removedinstances  map[int]struct{}
	clearedinstances  bool
	done              bool
	oldValue          func(context.Context) (*License, error)
	predicates        []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id int) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLicenseID sets the "license_id" field.
func (m *LicenseMutation) SetLicenseID(s string) {
	m.license_id = &s
}

// LicenseID returns the value of the "license_id" field in the mutation.
func (m *LicenseMutation) LicenseID() (r string, exists bool) {
	v := m.license_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseID returns the old "license_id" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldLicenseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLicenseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLicenseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseID: %w", err)
	}
	return oldValue.LicenseID, nil
}

// ResetLicenseID resets all changes to the "license_id" field.
func (m *LicenseMutation) ResetLicenseID() {
	m.license_id = nil
}

// SetName sets the "name" field.
func (m *LicenseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LicenseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *LicenseMutation) ClearName() {
	m.name = nil
	m.clearedFields[license.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *LicenseMutation) NameCleared() bool {
	_, ok := m.clearedFields[license.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *LicenseMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, license.FieldName)
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *LicenseMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *LicenseMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *LicenseMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *LicenseMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *LicenseMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *LicenseMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetSpdxID sets the "spdx" edge to the SPDXLicense entity by id.
func (m *LicenseMutation) SetSpdxID(id int) {
	m.spdx = &id
}

// ClearSpdx clears the "spdx" edge to the SPDXLicense entity.
func (m *LicenseMutation) ClearSpdx() {
	m.clearedspdx = true
}

// SpdxCleared reports if the "spdx" edge to the SPDXLicense entity was cleared.
func (m *LicenseMutation) SpdxCleared() bool {
	return m.clearedspdx
}

// SpdxID returns the "spdx" edge ID in the mutation.
func (m *LicenseMutation) SpdxID() (id int, exists bool) {
	if m.spdx != nil {
		return *m.spdx, true
	}
	return
}

// SpdxIDs returns the "spdx" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpdxID instead. It exists only for internal usage by the builders.
func (m *LicenseMutation) SpdxIDs() (ids []int) {
	if id := m.spdx; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpdx resets all changes to the "spdx" edge.
func (m *LicenseMutation) ResetSpdx() {
	m.spdx = nil
	m.clearedspdx = false
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *LicenseMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *LicenseMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *LicenseMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *LicenseMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *LicenseMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *LicenseMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *LicenseMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddInstanceIDs adds the "instances" edge to the ReleaseLicense entity by ids.
func (m *LicenseMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the ReleaseLicense entity.
func (m *LicenseMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the ReleaseLicense entity was cleared.
func (m *LicenseMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the ReleaseLicense entity by IDs.
func (m *LicenseMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the ReleaseLicense entity.
func (m *LicenseMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *LicenseMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *LicenseMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.license_id != nil {
		fields = append(fields, license.FieldLicenseID)
	}
	if m.name != nil {
		fields = append(fields, license.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldLicenseID:
		return m.LicenseID()
	case license.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldLicenseID:
		return m.OldLicenseID(ctx)
	case license.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldLicenseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseID(v)
		return nil
	case license.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldName) {
		fields = append(fields, license.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldLicenseID:
		m.ResetLicenseID()
		return nil
	case license.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, license.EdgeOwner)
	}
	if m.spdx != nil {
		edges = append(edges, license.EdgeSpdx)
	}
	if m.components != nil {
		edges = append(edges, license.EdgeComponents)
	}
	if m.instances != nil {
		edges = append(edges, license.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case license.EdgeSpdx:
		if id := m.spdx; id != nil {
			return []ent.Value{*id}
		}
	case license.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomponents != nil {
		edges = append(edges, license.EdgeComponents)
	}
	if m.removedinstances != nil {
		edges = append(edges, license.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, license.EdgeOwner)
	}
	if m.clearedspdx {
		edges = append(edges, license.EdgeSpdx)
	}
	if m.clearedcomponents {
		edges = append(edges, license.EdgeComponents)
	}
	if m.clearedinstances {
		edges = append(edges, license.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeOwner:
		return m.clearedowner
	case license.EdgeSpdx:
		return m.clearedspdx
	case license.EdgeComponents:
		return m.clearedcomponents
	case license.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	case license.EdgeOwner:
		m.ClearOwner()
		return nil
	case license.EdgeSpdx:
		m.ClearSpdx()
		return nil
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeOwner:
		m.ResetOwner()
		return nil
	case license.EdgeSpdx:
		m.ResetSpdx()
		return nil
	case license.EdgeComponents:
		m.ResetComponents()
		return nil
	case license.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	clearedFields   map[string]struct{}
	projects        map[int]struct{}
	removedprojects map[int]struct{}
	clearedprojects bool
	repos           map[int]struct{}
	removedrepos    map[int]struct{}
	clearedrepos    bool
	done            bool
	oldValue        func(context.Context) (*Organization, error)
	predicates      []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *OrganizationMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *OrganizationMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *OrganizationMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *OrganizationMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *OrganizationMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *OrganizationMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *OrganizationMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddRepoIDs adds the "repos" edge to the Repo entity by ids.
func (m *OrganizationMutation) AddRepoIDs(ids ...int) {
	if m.repos == nil {
		m.repos = make(map[int]struct{})
	}
	for i := range ids {
		m.repos[ids[i]] = struct{}{}
	}
}

// ClearRepos clears the "repos" edge to the Repo entity.
func (m *OrganizationMutation) ClearRepos() {
	m.clearedrepos = true
}

// ReposCleared reports if the "repos" edge to the Repo entity was cleared.
func (m *OrganizationMutation) ReposCleared() bool {
	return m.clearedrepos
}

// RemoveRepoIDs removes the "repos" edge to the Repo entity by IDs.
func (m *OrganizationMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepos == nil {
		m.removedrepos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repos, ids[i])
		m.removedrepos[ids[i]] = struct{}{}
	}
}

// RemovedRepos returns the removed IDs of the "repos" edge to the Repo entity.
func (m *OrganizationMutation) RemovedReposIDs() (ids []int) {
	for id := range m.removedrepos {
		ids = append(ids, id)
	}
	return
}

// ReposIDs returns the "repos" edge IDs in the mutation.
func (m *OrganizationMutation) ReposIDs() (ids []int) {
	for id := range m.repos {
		ids = append(ids, id)
	}
	return
}

// ResetRepos resets all changes to the "repos" edge.
func (m *OrganizationMutation) ResetRepos() {
	m.repos = nil
	m.clearedrepos = false
	m.removedrepos = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.projects != nil {
		edges = append(edges, organization.EdgeProjects)
	}
	if m.repos != nil {
		edges = append(edges, organization.EdgeRepos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.repos))
		for id := range m.repos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojects != nil {
		edges = append(edges, organization.EdgeProjects)
	}
	if m.removedrepos != nil {
		edges = append(edges, organization.EdgeRepos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.removedrepos))
		for id := range m.removedrepos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprojects {
		edges = append(edges, organization.EdgeProjects)
	}
	if m.clearedrepos {
		edges = append(edges, organization.EdgeRepos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeProjects:
		return m.clearedprojects
	case organization.EdgeRepos:
		return m.clearedrepos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeProjects:
		m.ResetProjects()
		return nil
	case organization.EdgeRepos:
		m.ResetRepos()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	clearedFields                map[string]struct{}
	owner                        *int
	clearedowner                 bool
	repos                        map[int]struct{}
	removedrepos                 map[int]struct{}
	clearedrepos                 bool
	vulnerability_reviews        map[int]struct{}
	removedvulnerability_reviews map[int]struct{}
	clearedvulnerability_reviews bool
	policies                     map[int]struct{}
	removedpolicies              map[int]struct{}
	clearedpolicies              bool
	done                         bool
	oldValue                     func(context.Context) (*Project, error)
	predicates                   []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *ProjectMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *ProjectMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *ProjectMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ProjectMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ProjectMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddRepoIDs adds the "repos" edge to the Repo entity by ids.
func (m *ProjectMutation) AddRepoIDs(ids ...int) {
	if m.repos == nil {
		m.repos = make(map[int]struct{})
	}
	for i := range ids {
		m.repos[ids[i]] = struct{}{}
	}
}

// ClearRepos clears the "repos" edge to the Repo entity.
func (m *ProjectMutation) ClearRepos() {
	m.clearedrepos = true
}

// ReposCleared reports if the "repos" edge to the Repo entity was cleared.
func (m *ProjectMutation) ReposCleared() bool {
	return m.clearedrepos
}

// RemoveRepoIDs removes the "repos" edge to the Repo entity by IDs.
func (m *ProjectMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepos == nil {
		m.removedrepos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repos, ids[i])
		m.removedrepos[ids[i]] = struct{}{}
	}
}

// RemovedRepos returns the removed IDs of the "repos" edge to the Repo entity.
func (m *ProjectMutation) RemovedReposIDs() (ids []int) {
	for id := range m.removedrepos {
		ids = append(ids, id)
	}
	return
}

// ReposIDs returns the "repos" edge IDs in the mutation.
func (m *ProjectMutation) ReposIDs() (ids []int) {
	for id := range m.repos {
		ids = append(ids, id)
	}
	return
}

// ResetRepos resets all changes to the "repos" edge.
func (m *ProjectMutation) ResetRepos() {
	m.repos = nil
	m.clearedrepos = false
	m.removedrepos = nil
}

// AddVulnerabilityReviewIDs adds the "vulnerability_reviews" edge to the VulnerabilityReview entity by ids.
func (m *ProjectMutation) AddVulnerabilityReviewIDs(ids ...int) {
	if m.vulnerability_reviews == nil {
		m.vulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_reviews[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityReviews clears the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ProjectMutation) ClearVulnerabilityReviews() {
	m.clearedvulnerability_reviews = true
}

// VulnerabilityReviewsCleared reports if the "vulnerability_reviews" edge to the VulnerabilityReview entity was cleared.
func (m *ProjectMutation) VulnerabilityReviewsCleared() bool {
	return m.clearedvulnerability_reviews
}

// RemoveVulnerabilityReviewIDs removes the "vulnerability_reviews" edge to the VulnerabilityReview entity by IDs.
func (m *ProjectMutation) RemoveVulnerabilityReviewIDs(ids ...int) {
	if m.removedvulnerability_reviews == nil {
		m.removedvulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_reviews, ids[i])
		m.removedvulnerability_reviews[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityReviews returns the removed IDs of the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ProjectMutation) RemovedVulnerabilityReviewsIDs() (ids []int) {
	for id := range m.removedvulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityReviewsIDs returns the "vulnerability_reviews" edge IDs in the mutation.
func (m *ProjectMutation) VulnerabilityReviewsIDs() (ids []int) {
	for id := range m.vulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityReviews resets all changes to the "vulnerability_reviews" edge.
func (m *ProjectMutation) ResetVulnerabilityReviews() {
	m.vulnerability_reviews = nil
	m.clearedvulnerability_reviews = false
	m.removedvulnerability_reviews = nil
}

// AddPolicyIDs adds the "policies" edge to the ReleasePolicy entity by ids.
func (m *ProjectMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the ReleasePolicy entity.
func (m *ProjectMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the ReleasePolicy entity was cleared.
func (m *ProjectMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the ReleasePolicy entity by IDs.
func (m *ProjectMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the ReleasePolicy entity.
func (m *ProjectMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *ProjectMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *ProjectMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, project.EdgeOwner)
	}
	if m.repos != nil {
		edges = append(edges, project.EdgeRepos)
	}
	if m.vulnerability_reviews != nil {
		edges = append(edges, project.EdgeVulnerabilityReviews)
	}
	if m.policies != nil {
		edges = append(edges, project.EdgePolicies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.repos))
		for id := range m.repos {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.vulnerability_reviews))
		for id := range m.vulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrepos != nil {
		edges = append(edges, project.EdgeRepos)
	}
	if m.removedvulnerability_reviews != nil {
		edges = append(edges, project.EdgeVulnerabilityReviews)
	}
	if m.removedpolicies != nil {
		edges = append(edges, project.EdgePolicies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.removedrepos))
		for id := range m.removedrepos {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_reviews))
		for id := range m.removedvulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	case project.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, project.EdgeOwner)
	}
	if m.clearedrepos {
		edges = append(edges, project.EdgeRepos)
	}
	if m.clearedvulnerability_reviews {
		edges = append(edges, project.EdgeVulnerabilityReviews)
	}
	if m.clearedpolicies {
		edges = append(edges, project.EdgePolicies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeOwner:
		return m.clearedowner
	case project.EdgeRepos:
		return m.clearedrepos
	case project.EdgeVulnerabilityReviews:
		return m.clearedvulnerability_reviews
	case project.EdgePolicies:
		return m.clearedpolicies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeOwner:
		m.ResetOwner()
		return nil
	case project.EdgeRepos:
		m.ResetRepos()
		return nil
	case project.EdgeVulnerabilityReviews:
		m.ResetVulnerabilityReviews()
		return nil
	case project.EdgePolicies:
		m.ResetPolicies()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ReleaseMutation represents an operation that mutates the Release nodes in the graph.
type ReleaseMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	version                      *string
	labels                       *schema.Labels
	clearedFields                map[string]struct{}
	subreleases                  map[int]struct{}
	removedsubreleases           map[int]struct{}
	clearedsubreleases           bool
	dependencies                 map[int]struct{}
	removeddependencies          map[int]struct{}
	cleareddependencies          bool
	commit                       *int
	clearedcommit                bool
	head_of                      *int
	clearedhead_of               bool
	log                          map[int]struct{}
	removedlog                   map[int]struct{}
	clearedlog                   bool
	violations                   map[int]struct{}
	removedviolations            map[int]struct{}
	clearedviolations            bool
	artifacts                    map[int]struct{}
	removedartifacts             map[int]struct{}
	clearedartifacts             bool
	components                   map[int]struct{}
	removedcomponents            map[int]struct{}
	clearedcomponents            bool
	vulnerabilities              map[int]struct{}
	removedvulnerabilities       map[int]struct{}
	clearedvulnerabilities       bool
	licenses                     map[int]struct{}
	removedlicenses              map[int]struct{}
	clearedlicenses              bool
	code_scans                   map[int]struct{}
	removedcode_scans            map[int]struct{}
	clearedcode_scans            bool
	test_runs                    map[int]struct{}
	removedtest_runs             map[int]struct{}
	clearedtest_runs             bool
	vulnerability_reviews        map[int]struct{}
	removedvulnerability_reviews map[int]struct{}
	clearedvulnerability_reviews bool
	done                         bool
	oldValue                     func(context.Context) (*Release, error)
	predicates                   []predicate.Release
}

var _ ent.Mutation = (*ReleaseMutation)(nil)

// releaseOption allows management of the mutation configuration using functional options.
type releaseOption func(*ReleaseMutation)

// newReleaseMutation creates new mutation for the Release entity.
func newReleaseMutation(c config, op Op, opts ...releaseOption) *ReleaseMutation {
	m := &ReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseID sets the ID field of the mutation.
func withReleaseID(id int) releaseOption {
	return func(m *ReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Release
		)
		m.oldValue = func(ctx context.Context) (*Release, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Release.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelease sets the old Release of the mutation.
func withRelease(node *Release) releaseOption {
	return func(m *ReleaseMutation) {
		m.oldValue = func(context.Context) (*Release, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ReleaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReleaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReleaseMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *ReleaseMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ReleaseMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ReleaseMutation) ResetVersion() {
	m.version = nil
}

// SetLabels sets the "labels" field.
func (m *ReleaseMutation) SetLabels(s schema.Labels) {
	m.labels = &s
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ReleaseMutation) Labels() (r schema.Labels, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldLabels(ctx context.Context) (v schema.Labels, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *ReleaseMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[release.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ReleaseMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[release.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ReleaseMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, release.FieldLabels)
}

// AddSubreleaseIDs adds the "subreleases" edge to the Release entity by ids.
func (m *ReleaseMutation) AddSubreleaseIDs(ids ...int) {
	if m.subreleases == nil {
		m.subreleases = make(map[int]struct{})
	}
	for i := range ids {
		m.subreleases[ids[i]] = struct{}{}
	}
}

// ClearSubreleases clears the "subreleases" edge to the Release entity.
func (m *ReleaseMutation) ClearSubreleases() {
	m.clearedsubreleases = true
}

// SubreleasesCleared reports if the "subreleases" edge to the Release entity was cleared.
func (m *ReleaseMutation) SubreleasesCleared() bool {
	return m.clearedsubreleases
}

// RemoveSubreleaseIDs removes the "subreleases" edge to the Release entity by IDs.
func (m *ReleaseMutation) RemoveSubreleaseIDs(ids ...int) {
	if m.removedsubreleases == nil {
		m.removedsubreleases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subreleases, ids[i])
		m.removedsubreleases[ids[i]] = struct{}{}
	}
}

// RemovedSubreleases returns the removed IDs of the "subreleases" edge to the Release entity.
func (m *ReleaseMutation) RemovedSubreleasesIDs() (ids []int) {
	for id := range m.removedsubreleases {
		ids = append(ids, id)
	}
	return
}

// SubreleasesIDs returns the "subreleases" edge IDs in the mutation.
func (m *ReleaseMutation) SubreleasesIDs() (ids []int) {
	for id := range m.subreleases {
		ids = append(ids, id)
	}
	return
}

// ResetSubreleases resets all changes to the "subreleases" edge.
func (m *ReleaseMutation) ResetSubreleases() {
	m.subreleases = nil
	m.clearedsubreleases = false
	m.removedsubreleases = nil
}

// AddDependencyIDs adds the "dependencies" edge to the Release entity by ids.
func (m *ReleaseMutation) AddDependencyIDs(ids ...int) {
	if m.dependencies == nil {
		m.dependencies = make(map[int]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the Release entity.
func (m *ReleaseMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the Release entity was cleared.
func (m *ReleaseMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the Release entity by IDs.
func (m *ReleaseMutation) RemoveDependencyIDs(ids ...int) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the Release entity.
func (m *ReleaseMutation) RemovedDependenciesIDs() (ids []int) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ReleaseMutation) DependenciesIDs() (ids []int) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ReleaseMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// SetCommitID sets the "commit" edge to the GitCommit entity by id.
func (m *ReleaseMutation) SetCommitID(id int) {
	m.commit = &id
}

// ClearCommit clears the "commit" edge to the GitCommit entity.
func (m *ReleaseMutation) ClearCommit() {
	m.clearedcommit = true
}

// CommitCleared reports if the "commit" edge to the GitCommit entity was cleared.
func (m *ReleaseMutation) CommitCleared() bool {
	return m.clearedcommit
}

// CommitID returns the "commit" edge ID in the mutation.
func (m *ReleaseMutation) CommitID() (id int, exists bool) {
	if m.commit != nil {
		return *m.commit, true
	}
	return
}

// CommitIDs returns the "commit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommitID instead. It exists only for internal usage by the builders.
func (m *ReleaseMutation) CommitIDs() (ids []int) {
	if id := m.commit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommit resets all changes to the "commit" edge.
func (m *ReleaseMutation) ResetCommit() {
	m.commit = nil
	m.clearedcommit = false
}

// SetHeadOfID sets the "head_of" edge to the Repo entity by id.
func (m *ReleaseMutation) SetHeadOfID(id int) {
	m.head_of = &id
}

// ClearHeadOf clears the "head_of" edge to the Repo entity.
func (m *ReleaseMutation) ClearHeadOf() {
	m.clearedhead_of = true
}

// HeadOfCleared reports if the "head_of" edge to the Repo entity was cleared.
func (m *ReleaseMutation) HeadOfCleared() bool {
	return m.clearedhead_of
}

// HeadOfID returns the "head_of" edge ID in the mutation.
func (m *ReleaseMutation) HeadOfID() (id int, exists bool) {
	if m.head_of != nil {
		return *m.head_of, true
	}
	return
}

// HeadOfIDs returns the "head_of" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeadOfID instead. It exists only for internal usage by the builders.
func (m *ReleaseMutation) HeadOfIDs() (ids []int) {
	if id := m.head_of; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHeadOf resets all changes to the "head_of" edge.
func (m *ReleaseMutation) ResetHeadOf() {
	m.head_of = nil
	m.clearedhead_of = false
}

// AddLogIDs adds the "log" edge to the ReleaseEntry entity by ids.
func (m *ReleaseMutation) AddLogIDs(ids ...int) {
	if m.log == nil {
		m.log = make(map[int]struct{})
	}
	for i := range ids {
		m.log[ids[i]] = struct{}{}
	}
}

// ClearLog clears the "log" edge to the ReleaseEntry entity.
func (m *ReleaseMutation) ClearLog() {
	m.clearedlog = true
}

// LogCleared reports if the "log" edge to the ReleaseEntry entity was cleared.
func (m *ReleaseMutation) LogCleared() bool {
	return m.clearedlog
}

// RemoveLogIDs removes the "log" edge to the ReleaseEntry entity by IDs.
func (m *ReleaseMutation) RemoveLogIDs(ids ...int) {
	if m.removedlog == nil {
		m.removedlog = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.log, ids[i])
		m.removedlog[ids[i]] = struct{}{}
	}
}

// RemovedLog returns the removed IDs of the "log" edge to the ReleaseEntry entity.
func (m *ReleaseMutation) RemovedLogIDs() (ids []int) {
	for id := range m.removedlog {
		ids = append(ids, id)
	}
	return
}

// LogIDs returns the "log" edge IDs in the mutation.
func (m *ReleaseMutation) LogIDs() (ids []int) {
	for id := range m.log {
		ids = append(ids, id)
	}
	return
}

// ResetLog resets all changes to the "log" edge.
func (m *ReleaseMutation) ResetLog() {
	m.log = nil
	m.clearedlog = false
	m.removedlog = nil
}

// AddViolationIDs adds the "violations" edge to the ReleasePolicyViolation entity by ids.
func (m *ReleaseMutation) AddViolationIDs(ids ...int) {
	if m.violations == nil {
		m.violations = make(map[int]struct{})
	}
	for i := range ids {
		m.violations[ids[i]] = struct{}{}
	}
}

// ClearViolations clears the "violations" edge to the ReleasePolicyViolation entity.
func (m *ReleaseMutation) ClearViolations() {
	m.clearedviolations = true
}

// ViolationsCleared reports if the "violations" edge to the ReleasePolicyViolation entity was cleared.
func (m *ReleaseMutation) ViolationsCleared() bool {
	return m.clearedviolations
}

// RemoveViolationIDs removes the "violations" edge to the ReleasePolicyViolation entity by IDs.
func (m *ReleaseMutation) RemoveViolationIDs(ids ...int) {
	if m.removedviolations == nil {
		m.removedviolations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.violations, ids[i])
		m.removedviolations[ids[i]] = struct{}{}
	}
}

// RemovedViolations returns the removed IDs of the "violations" edge to the ReleasePolicyViolation entity.
func (m *ReleaseMutation) RemovedViolationsIDs() (ids []int) {
	for id := range m.removedviolations {
		ids = append(ids, id)
	}
	return
}

// ViolationsIDs returns the "violations" edge IDs in the mutation.
func (m *ReleaseMutation) ViolationsIDs() (ids []int) {
	for id := range m.violations {
		ids = append(ids, id)
	}
	return
}

// ResetViolations resets all changes to the "violations" edge.
func (m *ReleaseMutation) ResetViolations() {
	m.violations = nil
	m.clearedviolations = false
	m.removedviolations = nil
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *ReleaseMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *ReleaseMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *ReleaseMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *ReleaseMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *ReleaseMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *ReleaseMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *ReleaseMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddComponentIDs adds the "components" edge to the ReleaseComponent entity by ids.
func (m *ReleaseMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the ReleaseComponent entity.
func (m *ReleaseMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the ReleaseComponent entity was cleared.
func (m *ReleaseMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the ReleaseComponent entity by IDs.
func (m *ReleaseMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the ReleaseComponent entity.
func (m *ReleaseMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ReleaseMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ReleaseMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the ReleaseVulnerability entity by ids.
func (m *ReleaseMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the ReleaseVulnerability entity was cleared.
func (m *ReleaseMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the ReleaseVulnerability entity by IDs.
func (m *ReleaseMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *ReleaseMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *ReleaseMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddLicenseIDs adds the "licenses" edge to the ReleaseLicense entity by ids.
func (m *ReleaseMutation) AddLicenseIDs(ids ...int) {
	if m.licenses == nil {
		m.licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.licenses[ids[i]] = struct{}{}
	}
}

// ClearLicenses clears the "licenses" edge to the ReleaseLicense entity.
func (m *ReleaseMutation) ClearLicenses() {
	m.clearedlicenses = true
}

// LicensesCleared reports if the "licenses" edge to the ReleaseLicense entity was cleared.
func (m *ReleaseMutation) LicensesCleared() bool {
	return m.clearedlicenses
}

// RemoveLicenseIDs removes the "licenses" edge to the ReleaseLicense entity by IDs.
func (m *ReleaseMutation) RemoveLicenseIDs(ids ...int) {
	if m.removedlicenses == nil {
		m.removedlicenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.licenses, ids[i])
		m.removedlicenses[ids[i]] = struct{}{}
	}
}

// RemovedLicenses returns the removed IDs of the "licenses" edge to the ReleaseLicense entity.
func (m *ReleaseMutation) RemovedLicensesIDs() (ids []int) {
	for id := range m.removedlicenses {
		ids = append(ids, id)
	}
	return
}

// LicensesIDs returns the "licenses" edge IDs in the mutation.
func (m *ReleaseMutation) LicensesIDs() (ids []int) {
	for id := range m.licenses {
		ids = append(ids, id)
	}
	return
}

// ResetLicenses resets all changes to the "licenses" edge.
func (m *ReleaseMutation) ResetLicenses() {
	m.licenses = nil
	m.clearedlicenses = false
	m.removedlicenses = nil
}

// AddCodeScanIDs adds the "code_scans" edge to the CodeScan entity by ids.
func (m *ReleaseMutation) AddCodeScanIDs(ids ...int) {
	if m.code_scans == nil {
		m.code_scans = make(map[int]struct{})
	}
	for i := range ids {
		m.code_scans[ids[i]] = struct{}{}
	}
}

// ClearCodeScans clears the "code_scans" edge to the CodeScan entity.
func (m *ReleaseMutation) ClearCodeScans() {
	m.clearedcode_scans = true
}

// CodeScansCleared reports if the "code_scans" edge to the CodeScan entity was cleared.
func (m *ReleaseMutation) CodeScansCleared() bool {
	return m.clearedcode_scans
}

// RemoveCodeScanIDs removes the "code_scans" edge to the CodeScan entity by IDs.
func (m *ReleaseMutation) RemoveCodeScanIDs(ids ...int) {
	if m.removedcode_scans == nil {
		m.removedcode_scans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.code_scans, ids[i])
		m.removedcode_scans[ids[i]] = struct{}{}
	}
}

// RemovedCodeScans returns the removed IDs of the "code_scans" edge to the CodeScan entity.
func (m *ReleaseMutation) RemovedCodeScansIDs() (ids []int) {
	for id := range m.removedcode_scans {
		ids = append(ids, id)
	}
	return
}

// CodeScansIDs returns the "code_scans" edge IDs in the mutation.
func (m *ReleaseMutation) CodeScansIDs() (ids []int) {
	for id := range m.code_scans {
		ids = append(ids, id)
	}
	return
}

// ResetCodeScans resets all changes to the "code_scans" edge.
func (m *ReleaseMutation) ResetCodeScans() {
	m.code_scans = nil
	m.clearedcode_scans = false
	m.removedcode_scans = nil
}

// AddTestRunIDs adds the "test_runs" edge to the TestRun entity by ids.
func (m *ReleaseMutation) AddTestRunIDs(ids ...int) {
	if m.test_runs == nil {
		m.test_runs = make(map[int]struct{})
	}
	for i := range ids {
		m.test_runs[ids[i]] = struct{}{}
	}
}

// ClearTestRuns clears the "test_runs" edge to the TestRun entity.
func (m *ReleaseMutation) ClearTestRuns() {
	m.clearedtest_runs = true
}

// TestRunsCleared reports if the "test_runs" edge to the TestRun entity was cleared.
func (m *ReleaseMutation) TestRunsCleared() bool {
	return m.clearedtest_runs
}

// RemoveTestRunIDs removes the "test_runs" edge to the TestRun entity by IDs.
func (m *ReleaseMutation) RemoveTestRunIDs(ids ...int) {
	if m.removedtest_runs == nil {
		m.removedtest_runs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_runs, ids[i])
		m.removedtest_runs[ids[i]] = struct{}{}
	}
}

// RemovedTestRuns returns the removed IDs of the "test_runs" edge to the TestRun entity.
func (m *ReleaseMutation) RemovedTestRunsIDs() (ids []int) {
	for id := range m.removedtest_runs {
		ids = append(ids, id)
	}
	return
}

// TestRunsIDs returns the "test_runs" edge IDs in the mutation.
func (m *ReleaseMutation) TestRunsIDs() (ids []int) {
	for id := range m.test_runs {
		ids = append(ids, id)
	}
	return
}

// ResetTestRuns resets all changes to the "test_runs" edge.
func (m *ReleaseMutation) ResetTestRuns() {
	m.test_runs = nil
	m.clearedtest_runs = false
	m.removedtest_runs = nil
}

// AddVulnerabilityReviewIDs adds the "vulnerability_reviews" edge to the VulnerabilityReview entity by ids.
func (m *ReleaseMutation) AddVulnerabilityReviewIDs(ids ...int) {
	if m.vulnerability_reviews == nil {
		m.vulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_reviews[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityReviews clears the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseMutation) ClearVulnerabilityReviews() {
	m.clearedvulnerability_reviews = true
}

// VulnerabilityReviewsCleared reports if the "vulnerability_reviews" edge to the VulnerabilityReview entity was cleared.
func (m *ReleaseMutation) VulnerabilityReviewsCleared() bool {
	return m.clearedvulnerability_reviews
}

// RemoveVulnerabilityReviewIDs removes the "vulnerability_reviews" edge to the VulnerabilityReview entity by IDs.
func (m *ReleaseMutation) RemoveVulnerabilityReviewIDs(ids ...int) {
	if m.removedvulnerability_reviews == nil {
		m.removedvulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_reviews, ids[i])
		m.removedvulnerability_reviews[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityReviews returns the removed IDs of the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseMutation) RemovedVulnerabilityReviewsIDs() (ids []int) {
	for id := range m.removedvulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityReviewsIDs returns the "vulnerability_reviews" edge IDs in the mutation.
func (m *ReleaseMutation) VulnerabilityReviewsIDs() (ids []int) {
	for id := range m.vulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityReviews resets all changes to the "vulnerability_reviews" edge.
func (m *ReleaseMutation) ResetVulnerabilityReviews() {
	m.vulnerability_reviews = nil
	m.clearedvulnerability_reviews = false
	m.removedvulnerability_reviews = nil
}

// Where appends a list predicates to the ReleaseMutation builder.
func (m *ReleaseMutation) Where(ps ...predicate.Release) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Release).
func (m *ReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, release.FieldName)
	}
	if m.version != nil {
		fields = append(fields, release.FieldVersion)
	}
	if m.labels != nil {
		fields = append(fields, release.FieldLabels)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case release.FieldName:
		return m.Name()
	case release.FieldVersion:
		return m.Version()
	case release.FieldLabels:
		return m.Labels()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case release.FieldName:
		return m.OldName(ctx)
	case release.FieldVersion:
		return m.OldVersion(ctx)
	case release.FieldLabels:
		return m.OldLabels(ctx)
	}
	return nil, fmt.Errorf("unknown Release field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case release.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case release.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case release.FieldLabels:
		v, ok := value.(schema.Labels)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Release numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(release.FieldLabels) {
		fields = append(fields, release.FieldLabels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseMutation) ClearField(name string) error {
	switch name {
	case release.FieldLabels:
		m.ClearLabels()
		return nil
	}
	return fmt.Errorf("unknown Release nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseMutation) ResetField(name string) error {
	switch name {
	case release.FieldName:
		m.ResetName()
		return nil
	case release.FieldVersion:
		m.ResetVersion()
		return nil
	case release.FieldLabels:
		m.ResetLabels()
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.subreleases != nil {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.dependencies != nil {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.commit != nil {
		edges = append(edges, release.EdgeCommit)
	}
	if m.head_of != nil {
		edges = append(edges, release.EdgeHeadOf)
	}
	if m.log != nil {
		edges = append(edges, release.EdgeLog)
	}
	if m.violations != nil {
		edges = append(edges, release.EdgeViolations)
	}
	if m.artifacts != nil {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.components != nil {
		edges = append(edges, release.EdgeComponents)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, release.EdgeVulnerabilities)
	}
	if m.licenses != nil {
		edges = append(edges, release.EdgeLicenses)
	}
	if m.code_scans != nil {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.test_runs != nil {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.vulnerability_reviews != nil {
		edges = append(edges, release.EdgeVulnerabilityReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeSubreleases:
		ids := make([]ent.Value, 0, len(m.subreleases))
		for id := range m.subreleases {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCommit:
		if id := m.commit; id != nil {
			return []ent.Value{*id}
		}
	case release.EdgeHeadOf:
		if id := m.head_of; id != nil {
			return []ent.Value{*id}
		}
	case release.EdgeLog:
		ids := make([]ent.Value, 0, len(m.log))
		for id := range m.log {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeViolations:
		ids := make([]ent.Value, 0, len(m.violations))
		for id := range m.violations {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.licenses))
		for id := range m.licenses {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCodeScans:
		ids := make([]ent.Value, 0, len(m.code_scans))
		for id := range m.code_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeTestRuns:
		ids := make([]ent.Value, 0, len(m.test_runs))
		for id := range m.test_runs {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.vulnerability_reviews))
		for id := range m.vulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedsubreleases != nil {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.removeddependencies != nil {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.removedlog != nil {
		edges = append(edges, release.EdgeLog)
	}
	if m.removedviolations != nil {
		edges = append(edges, release.EdgeViolations)
	}
	if m.removedartifacts != nil {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.removedcomponents != nil {
		edges = append(edges, release.EdgeComponents)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, release.EdgeVulnerabilities)
	}
	if m.removedlicenses != nil {
		edges = append(edges, release.EdgeLicenses)
	}
	if m.removedcode_scans != nil {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.removedtest_runs != nil {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.removedvulnerability_reviews != nil {
		edges = append(edges, release.EdgeVulnerabilityReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeSubreleases:
		ids := make([]ent.Value, 0, len(m.removedsubreleases))
		for id := range m.removedsubreleases {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLog:
		ids := make([]ent.Value, 0, len(m.removedlog))
		for id := range m.removedlog {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeViolations:
		ids := make([]ent.Value, 0, len(m.removedviolations))
		for id := range m.removedviolations {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.removedlicenses))
		for id := range m.removedlicenses {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCodeScans:
		ids := make([]ent.Value, 0, len(m.removedcode_scans))
		for id := range m.removedcode_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeTestRuns:
		ids := make([]ent.Value, 0, len(m.removedtest_runs))
		for id := range m.removedtest_runs {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_reviews))
		for id := range m.removedvulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedsubreleases {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.cleareddependencies {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.clearedcommit {
		edges = append(edges, release.EdgeCommit)
	}
	if m.clearedhead_of {
		edges = append(edges, release.EdgeHeadOf)
	}
	if m.clearedlog {
		edges = append(edges, release.EdgeLog)
	}
	if m.clearedviolations {
		edges = append(edges, release.EdgeViolations)
	}
	if m.clearedartifacts {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.clearedcomponents {
		edges = append(edges, release.EdgeComponents)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, release.EdgeVulnerabilities)
	}
	if m.clearedlicenses {
		edges = append(edges, release.EdgeLicenses)
	}
	if m.clearedcode_scans {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.clearedtest_runs {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.clearedvulnerability_reviews {
		edges = append(edges, release.EdgeVulnerabilityReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseMutation) EdgeCleared(name string) bool {
	switch name {
	case release.EdgeSubreleases:
		return m.clearedsubreleases
	case release.EdgeDependencies:
		return m.cleareddependencies
	case release.EdgeCommit:
		return m.clearedcommit
	case release.EdgeHeadOf:
		return m.clearedhead_of
	case release.EdgeLog:
		return m.clearedlog
	case release.EdgeViolations:
		return m.clearedviolations
	case release.EdgeArtifacts:
		return m.clearedartifacts
	case release.EdgeComponents:
		return m.clearedcomponents
	case release.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case release.EdgeLicenses:
		return m.clearedlicenses
	case release.EdgeCodeScans:
		return m.clearedcode_scans
	case release.EdgeTestRuns:
		return m.clearedtest_runs
	case release.EdgeVulnerabilityReviews:
		return m.clearedvulnerability_reviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseMutation) ClearEdge(name string) error {
	switch name {
	case release.EdgeCommit:
		m.ClearCommit()
		return nil
	case release.EdgeHeadOf:
		m.ClearHeadOf()
		return nil
	}
	return fmt.Errorf("unknown Release unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseMutation) ResetEdge(name string) error {
	switch name {
	case release.EdgeSubreleases:
		m.ResetSubreleases()
		return nil
	case release.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case release.EdgeCommit:
		m.ResetCommit()
		return nil
	case release.EdgeHeadOf:
		m.ResetHeadOf()
		return nil
	case release.EdgeLog:
		m.ResetLog()
		return nil
	case release.EdgeViolations:
		m.ResetViolations()
		return nil
	case release.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case release.EdgeComponents:
		m.ResetComponents()
		return nil
	case release.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case release.EdgeLicenses:
		m.ResetLicenses()
		return nil
	case release.EdgeCodeScans:
		m.ResetCodeScans()
		return nil
	case release.EdgeTestRuns:
		m.ResetTestRuns()
		return nil
	case release.EdgeVulnerabilityReviews:
		m.ResetVulnerabilityReviews()
		return nil
	}
	return fmt.Errorf("unknown Release edge %s", name)
}

// ReleaseComponentMutation represents an operation that mutates the ReleaseComponent nodes in the graph.
type ReleaseComponentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_type                  *releasecomponent.Type
	clearedFields          map[string]struct{}
	release                *int
	clearedrelease         bool
	scans                  map[int]struct{}
	removedscans           map[int]struct{}
	clearedscans           bool
	component              *int
	clearedcomponent       bool
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	licenses               map[int]struct{}
	removedlicenses        map[int]struct{}
	clearedlicenses        bool
	done                   bool
	oldValue               func(context.Context) (*ReleaseComponent, error)
	predicates             []predicate.ReleaseComponent
}

var _ ent.Mutation = (*ReleaseComponentMutation)(nil)

// releasecomponentOption allows management of the mutation configuration using functional options.
type releasecomponentOption func(*ReleaseComponentMutation)

// newReleaseComponentMutation creates new mutation for the ReleaseComponent entity.
func newReleaseComponentMutation(c config, op Op, opts ...releasecomponentOption) *ReleaseComponentMutation {
	m := &ReleaseComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseComponentID sets the ID field of the mutation.
func withReleaseComponentID(id int) releasecomponentOption {
	return func(m *ReleaseComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseComponent
		)
		m.oldValue = func(ctx context.Context) (*ReleaseComponent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseComponent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseComponent sets the old ReleaseComponent of the mutation.
func withReleaseComponent(node *ReleaseComponent) releasecomponentOption {
	return func(m *ReleaseComponentMutation) {
		m.oldValue = func(context.Context) (*ReleaseComponent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseComponentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *ReleaseComponentMutation) SetType(r releasecomponent.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReleaseComponentMutation) GetType() (r releasecomponent.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReleaseComponent entity.
// If the ReleaseComponent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseComponentMutation) OldType(ctx context.Context) (v releasecomponent.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReleaseComponentMutation) ResetType() {
	m._type = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseComponentMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseComponentMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseComponentMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseComponentMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseComponentMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseComponentMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddScanIDs adds the "scans" edge to the CodeScan entity by ids.
func (m *ReleaseComponentMutation) AddScanIDs(ids ...int) {
	if m.scans == nil {
		m.scans = make(map[int]struct{})
	}
	for i := range ids {
		m.scans[ids[i]] = struct{}{}
	}
}

// ClearScans clears the "scans" edge to the CodeScan entity.
func (m *ReleaseComponentMutation) ClearScans() {
	m.clearedscans = true
}

// ScansCleared reports if the "scans" edge to the CodeScan entity was cleared.
func (m *ReleaseComponentMutation) ScansCleared() bool {
	return m.clearedscans
}

// RemoveScanIDs removes the "scans" edge to the CodeScan entity by IDs.
func (m *ReleaseComponentMutation) RemoveScanIDs(ids ...int) {
	if m.removedscans == nil {
		m.removedscans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scans, ids[i])
		m.removedscans[ids[i]] = struct{}{}
	}
}

// RemovedScans returns the removed IDs of the "scans" edge to the CodeScan entity.
func (m *ReleaseComponentMutation) RemovedScansIDs() (ids []int) {
	for id := range m.removedscans {
		ids = append(ids, id)
	}
	return
}

// ScansIDs returns the "scans" edge IDs in the mutation.
func (m *ReleaseComponentMutation) ScansIDs() (ids []int) {
	for id := range m.scans {
		ids = append(ids, id)
	}
	return
}

// ResetScans resets all changes to the "scans" edge.
func (m *ReleaseComponentMutation) ResetScans() {
	m.scans = nil
	m.clearedscans = false
	m.removedscans = nil
}

// SetComponentID sets the "component" edge to the Component entity by id.
func (m *ReleaseComponentMutation) SetComponentID(id int) {
	m.component = &id
}

// ClearComponent clears the "component" edge to the Component entity.
func (m *ReleaseComponentMutation) ClearComponent() {
	m.clearedcomponent = true
}

// ComponentCleared reports if the "component" edge to the Component entity was cleared.
func (m *ReleaseComponentMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentID returns the "component" edge ID in the mutation.
func (m *ReleaseComponentMutation) ComponentID() (id int, exists bool) {
	if m.component != nil {
		return *m.component, true
	}
	return
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *ReleaseComponentMutation) ComponentIDs() (ids []int) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *ReleaseComponentMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the ReleaseVulnerability entity by ids.
func (m *ReleaseComponentMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseComponentMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the ReleaseVulnerability entity was cleared.
func (m *ReleaseComponentMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the ReleaseVulnerability entity by IDs.
func (m *ReleaseComponentMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the ReleaseVulnerability entity.
func (m *ReleaseComponentMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *ReleaseComponentMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *ReleaseComponentMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddLicenseIDs adds the "licenses" edge to the ReleaseLicense entity by ids.
func (m *ReleaseComponentMutation) AddLicenseIDs(ids ...int) {
	if m.licenses == nil {
		m.licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.licenses[ids[i]] = struct{}{}
	}
}

// ClearLicenses clears the "licenses" edge to the ReleaseLicense entity.
func (m *ReleaseComponentMutation) ClearLicenses() {
	m.clearedlicenses = true
}

// LicensesCleared reports if the "licenses" edge to the ReleaseLicense entity was cleared.
func (m *ReleaseComponentMutation) LicensesCleared() bool {
	return m.clearedlicenses
}

// RemoveLicenseIDs removes the "licenses" edge to the ReleaseLicense entity by IDs.
func (m *ReleaseComponentMutation) RemoveLicenseIDs(ids ...int) {
	if m.removedlicenses == nil {
		m.removedlicenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.licenses, ids[i])
		m.removedlicenses[ids[i]] = struct{}{}
	}
}

// RemovedLicenses returns the removed IDs of the "licenses" edge to the ReleaseLicense entity.
func (m *ReleaseComponentMutation) RemovedLicensesIDs() (ids []int) {
	for id := range m.removedlicenses {
		ids = append(ids, id)
	}
	return
}

// LicensesIDs returns the "licenses" edge IDs in the mutation.
func (m *ReleaseComponentMutation) LicensesIDs() (ids []int) {
	for id := range m.licenses {
		ids = append(ids, id)
	}
	return
}

// ResetLicenses resets all changes to the "licenses" edge.
func (m *ReleaseComponentMutation) ResetLicenses() {
	m.licenses = nil
	m.clearedlicenses = false
	m.removedlicenses = nil
}

// Where appends a list predicates to the ReleaseComponentMutation builder.
func (m *ReleaseComponentMutation) Where(ps ...predicate.ReleaseComponent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseComponentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseComponent).
func (m *ReleaseComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseComponentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, releasecomponent.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case releasecomponent.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case releasecomponent.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ReleaseComponent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case releasecomponent.FieldType:
		v, ok := value.(releasecomponent.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ReleaseComponent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseComponent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseComponentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseComponentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseComponent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseComponentMutation) ResetField(name string) error {
	switch name {
	case releasecomponent.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ReleaseComponent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.release != nil {
		edges = append(edges, releasecomponent.EdgeRelease)
	}
	if m.scans != nil {
		edges = append(edges, releasecomponent.EdgeScans)
	}
	if m.component != nil {
		edges = append(edges, releasecomponent.EdgeComponent)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, releasecomponent.EdgeVulnerabilities)
	}
	if m.licenses != nil {
		edges = append(edges, releasecomponent.EdgeLicenses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releasecomponent.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case releasecomponent.EdgeScans:
		ids := make([]ent.Value, 0, len(m.scans))
		for id := range m.scans {
			ids = append(ids, id)
		}
		return ids
	case releasecomponent.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	case releasecomponent.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case releasecomponent.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.licenses))
		for id := range m.licenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedscans != nil {
		edges = append(edges, releasecomponent.EdgeScans)
	}
	if m.removedvulnerabilities != nil {
		edges = append(edges, releasecomponent.EdgeVulnerabilities)
	}
	if m.removedlicenses != nil {
		edges = append(edges, releasecomponent.EdgeLicenses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case releasecomponent.EdgeScans:
		ids := make([]ent.Value, 0, len(m.removedscans))
		for id := range m.removedscans {
			ids = append(ids, id)
		}
		return ids
	case releasecomponent.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case releasecomponent.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.removedlicenses))
		for id := range m.removedlicenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrelease {
		edges = append(edges, releasecomponent.EdgeRelease)
	}
	if m.clearedscans {
		edges = append(edges, releasecomponent.EdgeScans)
	}
	if m.clearedcomponent {
		edges = append(edges, releasecomponent.EdgeComponent)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, releasecomponent.EdgeVulnerabilities)
	}
	if m.clearedlicenses {
		edges = append(edges, releasecomponent.EdgeLicenses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case releasecomponent.EdgeRelease:
		return m.clearedrelease
	case releasecomponent.EdgeScans:
		return m.clearedscans
	case releasecomponent.EdgeComponent:
		return m.clearedcomponent
	case releasecomponent.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case releasecomponent.EdgeLicenses:
		return m.clearedlicenses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseComponentMutation) ClearEdge(name string) error {
	switch name {
	case releasecomponent.EdgeRelease:
		m.ClearRelease()
		return nil
	case releasecomponent.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown ReleaseComponent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseComponentMutation) ResetEdge(name string) error {
	switch name {
	case releasecomponent.EdgeRelease:
		m.ResetRelease()
		return nil
	case releasecomponent.EdgeScans:
		m.ResetScans()
		return nil
	case releasecomponent.EdgeComponent:
		m.ResetComponent()
		return nil
	case releasecomponent.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case releasecomponent.EdgeLicenses:
		m.ResetLicenses()
		return nil
	}
	return fmt.Errorf("unknown ReleaseComponent edge %s", name)
}

// ReleaseEntryMutation represents an operation that mutates the ReleaseEntry nodes in the graph.
type ReleaseEntryMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_type            *releaseentry.Type
	time             *time.Time
	clearedFields    map[string]struct{}
	artifact         *int
	clearedartifact  bool
	code_scan        *int
	clearedcode_scan bool
	test_run         *int
	clearedtest_run  bool
	release          *int
	clearedrelease   bool
	done             bool
	oldValue         func(context.Context) (*ReleaseEntry, error)
	predicates       []predicate.ReleaseEntry
}

var _ ent.Mutation = (*ReleaseEntryMutation)(nil)

// releaseentryOption allows management of the mutation configuration using functional options.
type releaseentryOption func(*ReleaseEntryMutation)

// newReleaseEntryMutation creates new mutation for the ReleaseEntry entity.
func newReleaseEntryMutation(c config, op Op, opts ...releaseentryOption) *ReleaseEntryMutation {
	m := &ReleaseEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseEntryID sets the ID field of the mutation.
func withReleaseEntryID(id int) releaseentryOption {
	return func(m *ReleaseEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseEntry
		)
		m.oldValue = func(ctx context.Context) (*ReleaseEntry, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseEntry sets the old ReleaseEntry of the mutation.
func withReleaseEntry(node *ReleaseEntry) releaseentryOption {
	return func(m *ReleaseEntryMutation) {
		m.oldValue = func(context.Context) (*ReleaseEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *ReleaseEntryMutation) SetType(r releaseentry.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReleaseEntryMutation) GetType() (r releaseentry.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReleaseEntry entity.
// If the ReleaseEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseEntryMutation) OldType(ctx context.Context) (v releaseentry.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReleaseEntryMutation) ResetType() {
	m._type = nil
}

// SetTime sets the "time" field.
func (m *ReleaseEntryMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *ReleaseEntryMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the ReleaseEntry entity.
// If the ReleaseEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseEntryMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *ReleaseEntryMutation) ResetTime() {
	m.time = nil
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by id.
func (m *ReleaseEntryMutation) SetArtifactID(id int) {
	m.artifact = &id
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *ReleaseEntryMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *ReleaseEntryMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactID returns the "artifact" edge ID in the mutation.
func (m *ReleaseEntryMutation) ArtifactID() (id int, exists bool) {
	if m.artifact != nil {
		return *m.artifact, true
	}
	return
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *ReleaseEntryMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// SetCodeScanID sets the "code_scan" edge to the CodeScan entity by id.
func (m *ReleaseEntryMutation) SetCodeScanID(id int) {
	m.code_scan = &id
}

// ClearCodeScan clears the "code_scan" edge to the CodeScan entity.
func (m *ReleaseEntryMutation) ClearCodeScan() {
	m.clearedcode_scan = true
}

// CodeScanCleared reports if the "code_scan" edge to the CodeScan entity was cleared.
func (m *ReleaseEntryMutation) CodeScanCleared() bool {
	return m.clearedcode_scan
}

// CodeScanID returns the "code_scan" edge ID in the mutation.
func (m *ReleaseEntryMutation) CodeScanID() (id int, exists bool) {
	if m.code_scan != nil {
		return *m.code_scan, true
	}
	return
}

// CodeScanIDs returns the "code_scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodeScanID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) CodeScanIDs() (ids []int) {
	if id := m.code_scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodeScan resets all changes to the "code_scan" edge.
func (m *ReleaseEntryMutation) ResetCodeScan() {
	m.code_scan = nil
	m.clearedcode_scan = false
}

// SetTestRunID sets the "test_run" edge to the TestRun entity by id.
func (m *ReleaseEntryMutation) SetTestRunID(id int) {
	m.test_run = &id
}

// ClearTestRun clears the "test_run" edge to the TestRun entity.
func (m *ReleaseEntryMutation) ClearTestRun() {
	m.clearedtest_run = true
}

// TestRunCleared reports if the "test_run" edge to the TestRun entity was cleared.
func (m *ReleaseEntryMutation) TestRunCleared() bool {
	return m.clearedtest_run
}

// TestRunID returns the "test_run" edge ID in the mutation.
func (m *ReleaseEntryMutation) TestRunID() (id int, exists bool) {
	if m.test_run != nil {
		return *m.test_run, true
	}
	return
}

// TestRunIDs returns the "test_run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestRunID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) TestRunIDs() (ids []int) {
	if id := m.test_run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestRun resets all changes to the "test_run" edge.
func (m *ReleaseEntryMutation) ResetTestRun() {
	m.test_run = nil
	m.clearedtest_run = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseEntryMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseEntryMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseEntryMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseEntryMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseEntryMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Where appends a list predicates to the ReleaseEntryMutation builder.
func (m *ReleaseEntryMutation) Where(ps ...predicate.ReleaseEntry) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseEntryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseEntry).
func (m *ReleaseEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseEntryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, releaseentry.FieldType)
	}
	if m.time != nil {
		fields = append(fields, releaseentry.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case releaseentry.FieldType:
		return m.GetType()
	case releaseentry.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case releaseentry.FieldType:
		return m.OldType(ctx)
	case releaseentry.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case releaseentry.FieldType:
		v, ok := value.(releaseentry.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case releaseentry.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseEntryMutation) ResetField(name string) error {
	switch name {
	case releaseentry.FieldType:
		m.ResetType()
		return nil
	case releaseentry.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.artifact != nil {
		edges = append(edges, releaseentry.EdgeArtifact)
	}
	if m.code_scan != nil {
		edges = append(edges, releaseentry.EdgeCodeScan)
	}
	if m.test_run != nil {
		edges = append(edges, releaseentry.EdgeTestRun)
	}
	if m.release != nil {
		edges = append(edges, releaseentry.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releaseentry.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeCodeScan:
		if id := m.code_scan; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeTestRun:
		if id := m.test_run; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedartifact {
		edges = append(edges, releaseentry.EdgeArtifact)
	}
	if m.clearedcode_scan {
		edges = append(edges, releaseentry.EdgeCodeScan)
	}
	if m.clearedtest_run {
		edges = append(edges, releaseentry.EdgeTestRun)
	}
	if m.clearedrelease {
		edges = append(edges, releaseentry.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case releaseentry.EdgeArtifact:
		return m.clearedartifact
	case releaseentry.EdgeCodeScan:
		return m.clearedcode_scan
	case releaseentry.EdgeTestRun:
		return m.clearedtest_run
	case releaseentry.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseEntryMutation) ClearEdge(name string) error {
	switch name {
	case releaseentry.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case releaseentry.EdgeCodeScan:
		m.ClearCodeScan()
		return nil
	case releaseentry.EdgeTestRun:
		m.ClearTestRun()
		return nil
	case releaseentry.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseEntryMutation) ResetEdge(name string) error {
	switch name {
	case releaseentry.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case releaseentry.EdgeCodeScan:
		m.ResetCodeScan()
		return nil
	case releaseentry.EdgeTestRun:
		m.ResetTestRun()
		return nil
	case releaseentry.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry edge %s", name)
}

// ReleaseLicenseMutation represents an operation that mutates the ReleaseLicense nodes in the graph.
type ReleaseLicenseMutation struct {
	config
	op               Op
	typ              string
	id               *int
	clearedFields    map[string]struct{}
	license          *int
	clearedlicense   bool
	component        *int
	clearedcomponent bool
	release          *int
	clearedrelease   bool
	scans            map[int]struct{}
	removedscans     map[int]struct{}
	clearedscans     bool
	done             bool
	oldValue         func(context.Context) (*ReleaseLicense, error)
	predicates       []predicate.ReleaseLicense
}

var _ ent.Mutation = (*ReleaseLicenseMutation)(nil)

// releaselicenseOption allows management of the mutation configuration using functional options.
type releaselicenseOption func(*ReleaseLicenseMutation)

// newReleaseLicenseMutation creates new mutation for the ReleaseLicense entity.
func newReleaseLicenseMutation(c config, op Op, opts ...releaselicenseOption) *ReleaseLicenseMutation {
	m := &ReleaseLicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseLicenseID sets the ID field of the mutation.
func withReleaseLicenseID(id int) releaselicenseOption {
	return func(m *ReleaseLicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseLicense
		)
		m.oldValue = func(ctx context.Context) (*ReleaseLicense, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseLicense.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseLicense sets the old ReleaseLicense of the mutation.
func withReleaseLicense(node *ReleaseLicense) releaselicenseOption {
	return func(m *ReleaseLicenseMutation) {
		m.oldValue = func(context.Context) (*ReleaseLicense, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseLicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseLicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseLicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLicenseID sets the "license" edge to the License entity by id.
func (m *ReleaseLicenseMutation) SetLicenseID(id int) {
	m.license = &id
}

// ClearLicense clears the "license" edge to the License entity.
func (m *ReleaseLicenseMutation) ClearLicense() {
	m.clearedlicense = true
}

// LicenseCleared reports if the "license" edge to the License entity was cleared.
func (m *ReleaseLicenseMutation) LicenseCleared() bool {
	return m.clearedlicense
}

// LicenseID returns the "license" edge ID in the mutation.
func (m *ReleaseLicenseMutation) LicenseID() (id int, exists bool) {
	if m.license != nil {
		return *m.license, true
	}
	return
}

// LicenseIDs returns the "license" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *ReleaseLicenseMutation) LicenseIDs() (ids []int) {
	if id := m.license; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "license" edge.
func (m *ReleaseLicenseMutation) ResetLicense() {
	m.license = nil
	m.clearedlicense = false
}

// SetComponentID sets the "component" edge to the ReleaseComponent entity by id.
func (m *ReleaseLicenseMutation) SetComponentID(id int) {
	m.component = &id
}

// ClearComponent clears the "component" edge to the ReleaseComponent entity.
func (m *ReleaseLicenseMutation) ClearComponent() {
	m.clearedcomponent = true
}

// ComponentCleared reports if the "component" edge to the ReleaseComponent entity was cleared.
func (m *ReleaseLicenseMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentID returns the "component" edge ID in the mutation.
func (m *ReleaseLicenseMutation) ComponentID() (id int, exists bool) {
	if m.component != nil {
		return *m.component, true
	}
	return
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *ReleaseLicenseMutation) ComponentIDs() (ids []int) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *ReleaseLicenseMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseLicenseMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseLicenseMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseLicenseMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseLicenseMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseLicenseMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseLicenseMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddScanIDs adds the "scans" edge to the CodeScan entity by ids.
func (m *ReleaseLicenseMutation) AddScanIDs(ids ...int) {
	if m.scans == nil {
		m.scans = make(map[int]struct{})
	}
	for i := range ids {
		m.scans[ids[i]] = struct{}{}
	}
}

// ClearScans clears the "scans" edge to the CodeScan entity.
func (m *ReleaseLicenseMutation) ClearScans() {
	m.clearedscans = true
}

// ScansCleared reports if the "scans" edge to the CodeScan entity was cleared.
func (m *ReleaseLicenseMutation) ScansCleared() bool {
	return m.clearedscans
}

// RemoveScanIDs removes the "scans" edge to the CodeScan entity by IDs.
func (m *ReleaseLicenseMutation) RemoveScanIDs(ids ...int) {
	if m.removedscans == nil {
		m.removedscans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scans, ids[i])
		m.removedscans[ids[i]] = struct{}{}
	}
}

// RemovedScans returns the removed IDs of the "scans" edge to the CodeScan entity.
func (m *ReleaseLicenseMutation) RemovedScansIDs() (ids []int) {
	for id := range m.removedscans {
		ids = append(ids, id)
	}
	return
}

// ScansIDs returns the "scans" edge IDs in the mutation.
func (m *ReleaseLicenseMutation) ScansIDs() (ids []int) {
	for id := range m.scans {
		ids = append(ids, id)
	}
	return
}

// ResetScans resets all changes to the "scans" edge.
func (m *ReleaseLicenseMutation) ResetScans() {
	m.scans = nil
	m.clearedscans = false
	m.removedscans = nil
}

// Where appends a list predicates to the ReleaseLicenseMutation builder.
func (m *ReleaseLicenseMutation) Where(ps ...predicate.ReleaseLicense) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseLicenseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseLicense).
func (m *ReleaseLicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseLicenseMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseLicenseMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseLicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ReleaseLicense field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseLicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseLicense field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseLicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseLicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseLicenseMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ReleaseLicense numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseLicenseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseLicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseLicenseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseLicense nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseLicenseMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ReleaseLicense field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseLicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.license != nil {
		edges = append(edges, releaselicense.EdgeLicense)
	}
	if m.component != nil {
		edges = append(edges, releaselicense.EdgeComponent)
	}
	if m.release != nil {
		edges = append(edges, releaselicense.EdgeRelease)
	}
	if m.scans != nil {
		edges = append(edges, releaselicense.EdgeScans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseLicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releaselicense.EdgeLicense:
		if id := m.license; id != nil {
			return []ent.Value{*id}
		}
	case releaselicense.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	case releaselicense.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case releaselicense.EdgeScans:
		ids := make([]ent.Value, 0, len(m.scans))
		for id := range m.scans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseLicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedscans != nil {
		edges = append(edges, releaselicense.EdgeScans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseLicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case releaselicense.EdgeScans:
		ids := make([]ent.Value, 0, len(m.removedscans))
		for id := range m.removedscans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseLicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedlicense {
		edges = append(edges, releaselicense.EdgeLicense)
	}
	if m.clearedcomponent {
		edges = append(edges, releaselicense.EdgeComponent)
	}
	if m.clearedrelease {
		edges = append(edges, releaselicense.EdgeRelease)
	}
	if m.clearedscans {
		edges = append(edges, releaselicense.EdgeScans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseLicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case releaselicense.EdgeLicense:
		return m.clearedlicense
	case releaselicense.EdgeComponent:
		return m.clearedcomponent
	case releaselicense.EdgeRelease:
		return m.clearedrelease
	case releaselicense.EdgeScans:
		return m.clearedscans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseLicenseMutation) ClearEdge(name string) error {
	switch name {
	case releaselicense.EdgeLicense:
		m.ClearLicense()
		return nil
	case releaselicense.EdgeComponent:
		m.ClearComponent()
		return nil
	case releaselicense.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseLicense unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseLicenseMutation) ResetEdge(name string) error {
	switch name {
	case releaselicense.EdgeLicense:
		m.ResetLicense()
		return nil
	case releaselicense.EdgeComponent:
		m.ResetComponent()
		return nil
	case releaselicense.EdgeRelease:
		m.ResetRelease()
		return nil
	case releaselicense.EdgeScans:
		m.ResetScans()
		return nil
	}
	return fmt.Errorf("unknown ReleaseLicense edge %s", name)
}

// ReleasePolicyMutation represents an operation that mutates the ReleasePolicy nodes in the graph.
type ReleasePolicyMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	module            *string
	clearedFields     map[string]struct{}
	owner             *int
	clearedowner      bool
	projects          map[int]struct{}
	removedprojects   map[int]struct{}
	clearedprojects   bool
	repos             map[int]struct{}
	removedrepos      map[int]struct{}
	clearedrepos      bool
	violations        map[int]struct{}
	removedviolations map[int]struct{}
	clearedviolations bool
	done              bool
	oldValue          func(context.Context) (*ReleasePolicy, error)
	predicates        []predicate.ReleasePolicy
}

var _ ent.Mutation = (*ReleasePolicyMutation)(nil)

// releasepolicyOption allows management of the mutation configuration using functional options.
type releasepolicyOption func(*ReleasePolicyMutation)

// newReleasePolicyMutation creates new mutation for the ReleasePolicy entity.
func newReleasePolicyMutation(c config, op Op, opts ...releasepolicyOption) *ReleasePolicyMutation {
	m := &ReleasePolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeReleasePolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleasePolicyID sets the ID field of the mutation.
func withReleasePolicyID(id int) releasepolicyOption {
	return func(m *ReleasePolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleasePolicy
		)
		m.oldValue = func(ctx context.Context) (*ReleasePolicy, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleasePolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleasePolicy sets the old ReleasePolicy of the mutation.
func withReleasePolicy(node *ReleasePolicy) releasepolicyOption {
	return func(m *ReleasePolicyMutation) {
		m.oldValue = func(context.Context) (*ReleasePolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleasePolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleasePolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleasePolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ReleasePolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReleasePolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ReleasePolicy entity.
// If the ReleasePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleasePolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReleasePolicyMutation) ResetName() {
	m.name = nil
}

// SetModule sets the "module" field.
func (m *ReleasePolicyMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *ReleasePolicyMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the ReleasePolicy entity.
// If the ReleasePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleasePolicyMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *ReleasePolicyMutation) ResetModule() {
	m.module = nil
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *ReleasePolicyMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *ReleasePolicyMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *ReleasePolicyMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ReleasePolicyMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ReleasePolicyMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ReleasePolicyMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *ReleasePolicyMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *ReleasePolicyMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *ReleasePolicyMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *ReleasePolicyMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *ReleasePolicyMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ReleasePolicyMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ReleasePolicyMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddRepoIDs adds the "repos" edge to the Repo entity by ids.
func (m *ReleasePolicyMutation) AddRepoIDs(ids ...int) {
	if m.repos == nil {
		m.repos = make(map[int]struct{})
	}
	for i := range ids {
		m.repos[ids[i]] = struct{}{}
	}
}

// ClearRepos clears the "repos" edge to the Repo entity.
func (m *ReleasePolicyMutation) ClearRepos() {
	m.clearedrepos = true
}

// ReposCleared reports if the "repos" edge to the Repo entity was cleared.
func (m *ReleasePolicyMutation) ReposCleared() bool {
	return m.clearedrepos
}

// RemoveRepoIDs removes the "repos" edge to the Repo entity by IDs.
func (m *ReleasePolicyMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepos == nil {
		m.removedrepos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repos, ids[i])
		m.removedrepos[ids[i]] = struct{}{}
	}
}

// RemovedRepos returns the removed IDs of the "repos" edge to the Repo entity.
func (m *ReleasePolicyMutation) RemovedReposIDs() (ids []int) {
	for id := range m.removedrepos {
		ids = append(ids, id)
	}
	return
}

// ReposIDs returns the "repos" edge IDs in the mutation.
func (m *ReleasePolicyMutation) ReposIDs() (ids []int) {
	for id := range m.repos {
		ids = append(ids, id)
	}
	return
}

// ResetRepos resets all changes to the "repos" edge.
func (m *ReleasePolicyMutation) ResetRepos() {
	m.repos = nil
	m.clearedrepos = false
	m.removedrepos = nil
}

// AddViolationIDs adds the "violations" edge to the ReleasePolicyViolation entity by ids.
func (m *ReleasePolicyMutation) AddViolationIDs(ids ...int) {
	if m.violations == nil {
		m.violations = make(map[int]struct{})
	}
	for i := range ids {
		m.violations[ids[i]] = struct{}{}
	}
}

// ClearViolations clears the "violations" edge to the ReleasePolicyViolation entity.
func (m *ReleasePolicyMutation) ClearViolations() {
	m.clearedviolations = true
}

// ViolationsCleared reports if the "violations" edge to the ReleasePolicyViolation entity was cleared.
func (m *ReleasePolicyMutation) ViolationsCleared() bool {
	return m.clearedviolations
}

// RemoveViolationIDs removes the "violations" edge to the ReleasePolicyViolation entity by IDs.
func (m *ReleasePolicyMutation) RemoveViolationIDs(ids ...int) {
	if m.removedviolations == nil {
		m.removedviolations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.violations, ids[i])
		m.removedviolations[ids[i]] = struct{}{}
	}
}

// RemovedViolations returns the removed IDs of the "violations" edge to the ReleasePolicyViolation entity.
func (m *ReleasePolicyMutation) RemovedViolationsIDs() (ids []int) {
	for id := range m.removedviolations {
		ids = append(ids, id)
	}
	return
}

// ViolationsIDs returns the "violations" edge IDs in the mutation.
func (m *ReleasePolicyMutation) ViolationsIDs() (ids []int) {
	for id := range m.violations {
		ids = append(ids, id)
	}
	return
}

// ResetViolations resets all changes to the "violations" edge.
func (m *ReleasePolicyMutation) ResetViolations() {
	m.violations = nil
	m.clearedviolations = false
	m.removedviolations = nil
}

// Where appends a list predicates to the ReleasePolicyMutation builder.
func (m *ReleasePolicyMutation) Where(ps ...predicate.ReleasePolicy) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleasePolicyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleasePolicy).
func (m *ReleasePolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleasePolicyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, releasepolicy.FieldName)
	}
	if m.module != nil {
		fields = append(fields, releasepolicy.FieldModule)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleasePolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case releasepolicy.FieldName:
		return m.Name()
	case releasepolicy.FieldModule:
		return m.Module()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleasePolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case releasepolicy.FieldName:
		return m.OldName(ctx)
	case releasepolicy.FieldModule:
		return m.OldModule(ctx)
	}
	return nil, fmt.Errorf("unknown ReleasePolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleasePolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case releasepolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case releasepolicy.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleasePolicyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleasePolicyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleasePolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleasePolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleasePolicyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleasePolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleasePolicyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleasePolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleasePolicyMutation) ResetField(name string) error {
	switch name {
	case releasepolicy.FieldName:
		m.ResetName()
		return nil
	case releasepolicy.FieldModule:
		m.ResetModule()
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleasePolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, releasepolicy.EdgeOwner)
	}
	if m.projects != nil {
		edges = append(edges, releasepolicy.EdgeProjects)
	}
	if m.repos != nil {
		edges = append(edges, releasepolicy.EdgeRepos)
	}
	if m.violations != nil {
		edges = append(edges, releasepolicy.EdgeViolations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleasePolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releasepolicy.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case releasepolicy.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case releasepolicy.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.repos))
		for id := range m.repos {
			ids = append(ids, id)
		}
		return ids
	case releasepolicy.EdgeViolations:
		ids := make([]ent.Value, 0, len(m.violations))
		for id := range m.violations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleasePolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedprojects != nil {
		edges = append(edges, releasepolicy.EdgeProjects)
	}
	if m.removedrepos != nil {
		edges = append(edges, releasepolicy.EdgeRepos)
	}
	if m.removedviolations != nil {
		edges = append(edges, releasepolicy.EdgeViolations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleasePolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case releasepolicy.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case releasepolicy.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.removedrepos))
		for id := range m.removedrepos {
			ids = append(ids, id)
		}
		return ids
	case releasepolicy.EdgeViolations:
		ids := make([]ent.Value, 0, len(m.removedviolations))
		for id := range m.removedviolations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleasePolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, releasepolicy.EdgeOwner)
	}
	if m.clearedprojects {
		edges = append(edges, releasepolicy.EdgeProjects)
	}
	if m.clearedrepos {
		edges = append(edges, releasepolicy.EdgeRepos)
	}
	if m.clearedviolations {
		edges = append(edges, releasepolicy.EdgeViolations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleasePolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case releasepolicy.EdgeOwner:
		return m.clearedowner
	case releasepolicy.EdgeProjects:
		return m.clearedprojects
	case releasepolicy.EdgeRepos:
		return m.clearedrepos
	case releasepolicy.EdgeViolations:
		return m.clearedviolations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleasePolicyMutation) ClearEdge(name string) error {
	switch name {
	case releasepolicy.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleasePolicyMutation) ResetEdge(name string) error {
	switch name {
	case releasepolicy.EdgeOwner:
		m.ResetOwner()
		return nil
	case releasepolicy.EdgeProjects:
		m.ResetProjects()
		return nil
	case releasepolicy.EdgeRepos:
		m.ResetRepos()
		return nil
	case releasepolicy.EdgeViolations:
		m.ResetViolations()
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicy edge %s", name)
}

// ReleasePolicyViolationMutation represents an operation that mutates the ReleasePolicyViolation nodes in the graph.
type ReleasePolicyViolationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	message        *string
	_type          *releasepolicyviolation.Type
	severity       *releasepolicyviolation.Severity
	clearedFields  map[string]struct{}
	policy         *int
	clearedpolicy  bool
	release        *int
	clearedrelease bool
	done           bool
	oldValue       func(context.Context) (*ReleasePolicyViolation, error)
	predicates     []predicate.ReleasePolicyViolation
}

var _ ent.Mutation = (*ReleasePolicyViolationMutation)(nil)

// releasepolicyviolationOption allows management of the mutation configuration using functional options.
type releasepolicyviolationOption func(*ReleasePolicyViolationMutation)

// newReleasePolicyViolationMutation creates new mutation for the ReleasePolicyViolation entity.
func newReleasePolicyViolationMutation(c config, op Op, opts ...releasepolicyviolationOption) *ReleasePolicyViolationMutation {
	m := &ReleasePolicyViolationMutation{
		config:        c,
		op:            op,
		typ:           TypeReleasePolicyViolation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleasePolicyViolationID sets the ID field of the mutation.
func withReleasePolicyViolationID(id int) releasepolicyviolationOption {
	return func(m *ReleasePolicyViolationMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleasePolicyViolation
		)
		m.oldValue = func(ctx context.Context) (*ReleasePolicyViolation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleasePolicyViolation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleasePolicyViolation sets the old ReleasePolicyViolation of the mutation.
func withReleasePolicyViolation(node *ReleasePolicyViolation) releasepolicyviolationOption {
	return func(m *ReleasePolicyViolationMutation) {
		m.oldValue = func(context.Context) (*ReleasePolicyViolation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleasePolicyViolationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleasePolicyViolationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleasePolicyViolationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMessage sets the "message" field.
func (m *ReleasePolicyViolationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ReleasePolicyViolationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the ReleasePolicyViolation entity.
// If the ReleasePolicyViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleasePolicyViolationMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ReleasePolicyViolationMutation) ResetMessage() {
	m.message = nil
}

// SetType sets the "type" field.
func (m *ReleasePolicyViolationMutation) SetType(r releasepolicyviolation.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReleasePolicyViolationMutation) GetType() (r releasepolicyviolation.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReleasePolicyViolation entity.
// If the ReleasePolicyViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleasePolicyViolationMutation) OldType(ctx context.Context) (v releasepolicyviolation.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReleasePolicyViolationMutation) ResetType() {
	m._type = nil
}

// SetSeverity sets the "severity" field.
func (m *ReleasePolicyViolationMutation) SetSeverity(r releasepolicyviolation.Severity) {
	m.severity = &r
}

// Severity returns the value of the "severity" field in the mutation.
func (m *ReleasePolicyViolationMutation) Severity() (r releasepolicyviolation.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the ReleasePolicyViolation entity.
// If the ReleasePolicyViolation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleasePolicyViolationMutation) OldSeverity(ctx context.Context) (v releasepolicyviolation.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *ReleasePolicyViolationMutation) ResetSeverity() {
	m.severity = nil
}

// SetPolicyID sets the "policy" edge to the ReleasePolicy entity by id.
func (m *ReleasePolicyViolationMutation) SetPolicyID(id int) {
	m.policy = &id
}

// ClearPolicy clears the "policy" edge to the ReleasePolicy entity.
func (m *ReleasePolicyViolationMutation) ClearPolicy() {
	m.clearedpolicy = true
}

// PolicyCleared reports if the "policy" edge to the ReleasePolicy entity was cleared.
func (m *ReleasePolicyViolationMutation) PolicyCleared() bool {
	return m.clearedpolicy
}

// PolicyID returns the "policy" edge ID in the mutation.
func (m *ReleasePolicyViolationMutation) PolicyID() (id int, exists bool) {
	if m.policy != nil {
		return *m.policy, true
	}
	return
}

// PolicyIDs returns the "policy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PolicyID instead. It exists only for internal usage by the builders.
func (m *ReleasePolicyViolationMutation) PolicyIDs() (ids []int) {
	if id := m.policy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPolicy resets all changes to the "policy" edge.
func (m *ReleasePolicyViolationMutation) ResetPolicy() {
	m.policy = nil
	m.clearedpolicy = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleasePolicyViolationMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleasePolicyViolationMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleasePolicyViolationMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleasePolicyViolationMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleasePolicyViolationMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleasePolicyViolationMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Where appends a list predicates to the ReleasePolicyViolationMutation builder.
func (m *ReleasePolicyViolationMutation) Where(ps ...predicate.ReleasePolicyViolation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleasePolicyViolationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleasePolicyViolation).
func (m *ReleasePolicyViolationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleasePolicyViolationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.message != nil {
		fields = append(fields, releasepolicyviolation.FieldMessage)
	}
	if m._type != nil {
		fields = append(fields, releasepolicyviolation.FieldType)
	}
	if m.severity != nil {
		fields = append(fields, releasepolicyviolation.FieldSeverity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleasePolicyViolationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case releasepolicyviolation.FieldMessage:
		return m.Message()
	case releasepolicyviolation.FieldType:
		return m.GetType()
	case releasepolicyviolation.FieldSeverity:
		return m.Severity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleasePolicyViolationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case releasepolicyviolation.FieldMessage:
		return m.OldMessage(ctx)
	case releasepolicyviolation.FieldType:
		return m.OldType(ctx)
	case releasepolicyviolation.FieldSeverity:
		return m.OldSeverity(ctx)
	}
	return nil, fmt.Errorf("unknown ReleasePolicyViolation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleasePolicyViolationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case releasepolicyviolation.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case releasepolicyviolation.FieldType:
		v, ok := value.(releasepolicyviolation.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case releasepolicyviolation.FieldSeverity:
		v, ok := value.(releasepolicyviolation.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicyViolation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleasePolicyViolationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleasePolicyViolationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleasePolicyViolationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleasePolicyViolation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleasePolicyViolationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleasePolicyViolationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleasePolicyViolationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleasePolicyViolation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleasePolicyViolationMutation) ResetField(name string) error {
	switch name {
	case releasepolicyviolation.FieldMessage:
		m.ResetMessage()
		return nil
	case releasepolicyviolation.FieldType:
		m.ResetType()
		return nil
	case releasepolicyviolation.FieldSeverity:
		m.ResetSeverity()
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicyViolation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleasePolicyViolationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.policy != nil {
		edges = append(edges, releasepolicyviolation.EdgePolicy)
	}
	if m.release != nil {
		edges = append(edges, releasepolicyviolation.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleasePolicyViolationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releasepolicyviolation.EdgePolicy:
		if id := m.policy; id != nil {
			return []ent.Value{*id}
		}
	case releasepolicyviolation.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleasePolicyViolationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleasePolicyViolationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleasePolicyViolationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpolicy {
		edges = append(edges, releasepolicyviolation.EdgePolicy)
	}
	if m.clearedrelease {
		edges = append(edges, releasepolicyviolation.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleasePolicyViolationMutation) EdgeCleared(name string) bool {
	switch name {
	case releasepolicyviolation.EdgePolicy:
		return m.clearedpolicy
	case releasepolicyviolation.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleasePolicyViolationMutation) ClearEdge(name string) error {
	switch name {
	case releasepolicyviolation.EdgePolicy:
		m.ClearPolicy()
		return nil
	case releasepolicyviolation.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicyViolation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleasePolicyViolationMutation) ResetEdge(name string) error {
	switch name {
	case releasepolicyviolation.EdgePolicy:
		m.ResetPolicy()
		return nil
	case releasepolicyviolation.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleasePolicyViolation edge %s", name)
}

// ReleaseVulnerabilityMutation represents an operation that mutates the ReleaseVulnerability nodes in the graph.
type ReleaseVulnerabilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	clearedFields        map[string]struct{}
	vulnerability        *int
	clearedvulnerability bool
	component            *int
	clearedcomponent     bool
	release              *int
	clearedrelease       bool
	reviews              map[int]struct{}
	removedreviews       map[int]struct{}
	clearedreviews       bool
	scan                 *int
	clearedscan          bool
	done                 bool
	oldValue             func(context.Context) (*ReleaseVulnerability, error)
	predicates           []predicate.ReleaseVulnerability
}

var _ ent.Mutation = (*ReleaseVulnerabilityMutation)(nil)

// releasevulnerabilityOption allows management of the mutation configuration using functional options.
type releasevulnerabilityOption func(*ReleaseVulnerabilityMutation)

// newReleaseVulnerabilityMutation creates new mutation for the ReleaseVulnerability entity.
func newReleaseVulnerabilityMutation(c config, op Op, opts ...releasevulnerabilityOption) *ReleaseVulnerabilityMutation {
	m := &ReleaseVulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseVulnerabilityID sets the ID field of the mutation.
func withReleaseVulnerabilityID(id int) releasevulnerabilityOption {
	return func(m *ReleaseVulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseVulnerability
		)
		m.oldValue = func(ctx context.Context) (*ReleaseVulnerability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseVulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseVulnerability sets the old ReleaseVulnerability of the mutation.
func withReleaseVulnerability(node *ReleaseVulnerability) releasevulnerabilityOption {
	return func(m *ReleaseVulnerabilityMutation) {
		m.oldValue = func(context.Context) (*ReleaseVulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseVulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseVulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseVulnerabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetVulnerabilityID sets the "vulnerability" edge to the Vulnerability entity by id.
func (m *ReleaseVulnerabilityMutation) SetVulnerabilityID(id int) {
	m.vulnerability = &id
}

// ClearVulnerability clears the "vulnerability" edge to the Vulnerability entity.
func (m *ReleaseVulnerabilityMutation) ClearVulnerability() {
	m.clearedvulnerability = true
}

// VulnerabilityCleared reports if the "vulnerability" edge to the Vulnerability entity was cleared.
func (m *ReleaseVulnerabilityMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityID returns the "vulnerability" edge ID in the mutation.
func (m *ReleaseVulnerabilityMutation) VulnerabilityID() (id int, exists bool) {
	if m.vulnerability != nil {
		return *m.vulnerability, true
	}
	return
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *ReleaseVulnerabilityMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *ReleaseVulnerabilityMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// SetComponentID sets the "component" edge to the ReleaseComponent entity by id.
func (m *ReleaseVulnerabilityMutation) SetComponentID(id int) {
	m.component = &id
}

// ClearComponent clears the "component" edge to the ReleaseComponent entity.
func (m *ReleaseVulnerabilityMutation) ClearComponent() {
	m.clearedcomponent = true
}

// ComponentCleared reports if the "component" edge to the ReleaseComponent entity was cleared.
func (m *ReleaseVulnerabilityMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentID returns the "component" edge ID in the mutation.
func (m *ReleaseVulnerabilityMutation) ComponentID() (id int, exists bool) {
	if m.component != nil {
		return *m.component, true
	}
	return
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *ReleaseVulnerabilityMutation) ComponentIDs() (ids []int) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *ReleaseVulnerabilityMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseVulnerabilityMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseVulnerabilityMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseVulnerabilityMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseVulnerabilityMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseVulnerabilityMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseVulnerabilityMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddReviewIDs adds the "reviews" edge to the VulnerabilityReview entity by ids.
func (m *ReleaseVulnerabilityMutation) AddReviewIDs(ids ...int) {
	if m.reviews == nil {
		m.reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseVulnerabilityMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the VulnerabilityReview entity was cleared.
func (m *ReleaseVulnerabilityMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the VulnerabilityReview entity by IDs.
func (m *ReleaseVulnerabilityMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the VulnerabilityReview entity.
func (m *ReleaseVulnerabilityMutation) RemovedReviewsIDs() (ids []int) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *ReleaseVulnerabilityMutation) ReviewsIDs() (ids []int) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *ReleaseVulnerabilityMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// SetScanID sets the "scan" edge to the CodeScan entity by id.
func (m *ReleaseVulnerabilityMutation) SetScanID(id int) {
	m.scan = &id
}

// ClearScan clears the "scan" edge to the CodeScan entity.
func (m *ReleaseVulnerabilityMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the CodeScan entity was cleared.
func (m *ReleaseVulnerabilityMutation) ScanCleared() bool {
	return m.clearedscan
}

// ScanID returns the "scan" edge ID in the mutation.
func (m *ReleaseVulnerabilityMutation) ScanID() (id int, exists bool) {
	if m.scan != nil {
		return *m.scan, true
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScanID instead. It exists only for internal usage by the builders.
func (m *ReleaseVulnerabilityMutation) ScanIDs() (ids []int) {
	if id := m.scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *ReleaseVulnerabilityMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
}

// Where appends a list predicates to the ReleaseVulnerabilityMutation builder.
func (m *ReleaseVulnerabilityMutation) Where(ps ...predicate.ReleaseVulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseVulnerabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseVulnerability).
func (m *ReleaseVulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseVulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseVulnerabilityMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseVulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ReleaseVulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseVulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseVulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseVulnerabilityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseVulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseVulnerabilityMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ReleaseVulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseVulnerabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseVulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseVulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ReleaseVulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseVulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.vulnerability != nil {
		edges = append(edges, releasevulnerability.EdgeVulnerability)
	}
	if m.component != nil {
		edges = append(edges, releasevulnerability.EdgeComponent)
	}
	if m.release != nil {
		edges = append(edges, releasevulnerability.EdgeRelease)
	}
	if m.reviews != nil {
		edges = append(edges, releasevulnerability.EdgeReviews)
	}
	if m.scan != nil {
		edges = append(edges, releasevulnerability.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseVulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	case releasevulnerability.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	case releasevulnerability.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case releasevulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case releasevulnerability.EdgeScan:
		if id := m.scan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseVulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedreviews != nil {
		edges = append(edges, releasevulnerability.EdgeReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseVulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case releasevulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseVulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedvulnerability {
		edges = append(edges, releasevulnerability.EdgeVulnerability)
	}
	if m.clearedcomponent {
		edges = append(edges, releasevulnerability.EdgeComponent)
	}
	if m.clearedrelease {
		edges = append(edges, releasevulnerability.EdgeRelease)
	}
	if m.clearedreviews {
		edges = append(edges, releasevulnerability.EdgeReviews)
	}
	if m.clearedscan {
		edges = append(edges, releasevulnerability.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseVulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		return m.clearedvulnerability
	case releasevulnerability.EdgeComponent:
		return m.clearedcomponent
	case releasevulnerability.EdgeRelease:
		return m.clearedrelease
	case releasevulnerability.EdgeReviews:
		return m.clearedreviews
	case releasevulnerability.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	case releasevulnerability.EdgeComponent:
		m.ClearComponent()
		return nil
	case releasevulnerability.EdgeRelease:
		m.ClearRelease()
		return nil
	case releasevulnerability.EdgeScan:
		m.ClearScan()
		return nil
	}
	return fmt.Errorf("unknown ReleaseVulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseVulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case releasevulnerability.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	case releasevulnerability.EdgeComponent:
		m.ResetComponent()
		return nil
	case releasevulnerability.EdgeRelease:
		m.ResetRelease()
		return nil
	case releasevulnerability.EdgeReviews:
		m.ResetReviews()
		return nil
	case releasevulnerability.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown ReleaseVulnerability edge %s", name)
}

// RepoMutation represents an operation that mutates the Repo nodes in the graph.
type RepoMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	default_branch               *string
	clearedFields                map[string]struct{}
	owner                        *int
	clearedowner                 bool
	project                      *int
	clearedproject               bool
	head                         *int
	clearedhead                  bool
	commits                      map[int]struct{}
	removedcommits               map[int]struct{}
	clearedcommits               bool
	vulnerability_reviews        map[int]struct{}
	removedvulnerability_reviews map[int]struct{}
	clearedvulnerability_reviews bool
	policies                     map[int]struct{}
	removedpolicies              map[int]struct{}
	clearedpolicies              bool
	done                         bool
	oldValue                     func(context.Context) (*Repo, error)
	predicates                   []predicate.Repo
}

var _ ent.Mutation = (*RepoMutation)(nil)

// repoOption allows management of the mutation configuration using functional options.
type repoOption func(*RepoMutation)

// newRepoMutation creates new mutation for the Repo entity.
func newRepoMutation(c config, op Op, opts ...repoOption) *RepoMutation {
	m := &RepoMutation{
		config:        c,
		op:            op,
		typ:           TypeRepo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepoID sets the ID field of the mutation.
func withRepoID(id int) repoOption {
	return func(m *RepoMutation) {
		var (
			err   error
			once  sync.Once
			value *Repo
		)
		m.oldValue = func(ctx context.Context) (*Repo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepo sets the old Repo of the mutation.
func withRepo(node *Repo) repoOption {
	return func(m *RepoMutation) {
		m.oldValue = func(context.Context) (*Repo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *RepoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepoMutation) ResetName() {
	m.name = nil
}

// SetDefaultBranch sets the "default_branch" field.
func (m *RepoMutation) SetDefaultBranch(s string) {
	m.default_branch = &s
}

// DefaultBranch returns the value of the "default_branch" field in the mutation.
func (m *RepoMutation) DefaultBranch() (r string, exists bool) {
	v := m.default_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultBranch returns the old "default_branch" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldDefaultBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultBranch: %w", err)
	}
	return oldValue.DefaultBranch, nil
}

// ResetDefaultBranch resets all changes to the "default_branch" field.
func (m *RepoMutation) ResetDefaultBranch() {
	m.default_branch = nil
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *RepoMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *RepoMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *RepoMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *RepoMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *RepoMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *RepoMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *RepoMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RepoMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RepoMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *RepoMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RepoMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RepoMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetHeadID sets the "head" edge to the Release entity by id.
func (m *RepoMutation) SetHeadID(id int) {
	m.head = &id
}

// ClearHead clears the "head" edge to the Release entity.
func (m *RepoMutation) ClearHead() {
	m.clearedhead = true
}

// HeadCleared reports if the "head" edge to the Release entity was cleared.
func (m *RepoMutation) HeadCleared() bool {
	return m.clearedhead
}

// HeadID returns the "head" edge ID in the mutation.
func (m *RepoMutation) HeadID() (id int, exists bool) {
	if m.head != nil {
		return *m.head, true
	}
	return
}

// HeadIDs returns the "head" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeadID instead. It exists only for internal usage by the builders.
func (m *RepoMutation) HeadIDs() (ids []int) {
	if id := m.head; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHead resets all changes to the "head" edge.
func (m *RepoMutation) ResetHead() {
	m.head = nil
	m.clearedhead = false
}

// AddCommitIDs adds the "commits" edge to the GitCommit entity by ids.
func (m *RepoMutation) AddCommitIDs(ids ...int) {
	if m.commits == nil {
		m.commits = make(map[int]struct{})
	}
	for i := range ids {
		m.commits[ids[i]] = struct{}{}
	}
}

// ClearCommits clears the "commits" edge to the GitCommit entity.
func (m *RepoMutation) ClearCommits() {
	m.clearedcommits = true
}

// CommitsCleared reports if the "commits" edge to the GitCommit entity was cleared.
func (m *RepoMutation) CommitsCleared() bool {
	return m.clearedcommits
}

// RemoveCommitIDs removes the "commits" edge to the GitCommit entity by IDs.
func (m *RepoMutation) RemoveCommitIDs(ids ...int) {
	if m.removedcommits == nil {
		m.removedcommits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.commits, ids[i])
		m.removedcommits[ids[i]] = struct{}{}
	}
}

// RemovedCommits returns the removed IDs of the "commits" edge to the GitCommit entity.
func (m *RepoMutation) RemovedCommitsIDs() (ids []int) {
	for id := range m.removedcommits {
		ids = append(ids, id)
	}
	return
}

// CommitsIDs returns the "commits" edge IDs in the mutation.
func (m *RepoMutation) CommitsIDs() (ids []int) {
	for id := range m.commits {
		ids = append(ids, id)
	}
	return
}

// ResetCommits resets all changes to the "commits" edge.
func (m *RepoMutation) ResetCommits() {
	m.commits = nil
	m.clearedcommits = false
	m.removedcommits = nil
}

// AddVulnerabilityReviewIDs adds the "vulnerability_reviews" edge to the VulnerabilityReview entity by ids.
func (m *RepoMutation) AddVulnerabilityReviewIDs(ids ...int) {
	if m.vulnerability_reviews == nil {
		m.vulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerability_reviews[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilityReviews clears the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *RepoMutation) ClearVulnerabilityReviews() {
	m.clearedvulnerability_reviews = true
}

// VulnerabilityReviewsCleared reports if the "vulnerability_reviews" edge to the VulnerabilityReview entity was cleared.
func (m *RepoMutation) VulnerabilityReviewsCleared() bool {
	return m.clearedvulnerability_reviews
}

// RemoveVulnerabilityReviewIDs removes the "vulnerability_reviews" edge to the VulnerabilityReview entity by IDs.
func (m *RepoMutation) RemoveVulnerabilityReviewIDs(ids ...int) {
	if m.removedvulnerability_reviews == nil {
		m.removedvulnerability_reviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerability_reviews, ids[i])
		m.removedvulnerability_reviews[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilityReviews returns the removed IDs of the "vulnerability_reviews" edge to the VulnerabilityReview entity.
func (m *RepoMutation) RemovedVulnerabilityReviewsIDs() (ids []int) {
	for id := range m.removedvulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// VulnerabilityReviewsIDs returns the "vulnerability_reviews" edge IDs in the mutation.
func (m *RepoMutation) VulnerabilityReviewsIDs() (ids []int) {
	for id := range m.vulnerability_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilityReviews resets all changes to the "vulnerability_reviews" edge.
func (m *RepoMutation) ResetVulnerabilityReviews() {
	m.vulnerability_reviews = nil
	m.clearedvulnerability_reviews = false
	m.removedvulnerability_reviews = nil
}

// AddPolicyIDs adds the "policies" edge to the ReleasePolicy entity by ids.
func (m *RepoMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the ReleasePolicy entity.
func (m *RepoMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the ReleasePolicy entity was cleared.
func (m *RepoMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the ReleasePolicy entity by IDs.
func (m *RepoMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the ReleasePolicy entity.
func (m *RepoMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *RepoMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *RepoMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// Where appends a list predicates to the RepoMutation builder.
func (m *RepoMutation) Where(ps ...predicate.Repo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RepoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repo).
func (m *RepoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, repo.FieldName)
	}
	if m.default_branch != nil {
		fields = append(fields, repo.FieldDefaultBranch)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repo.FieldName:
		return m.Name()
	case repo.FieldDefaultBranch:
		return m.DefaultBranch()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repo.FieldName:
		return m.OldName(ctx)
	case repo.FieldDefaultBranch:
		return m.OldDefaultBranch(ctx)
	}
	return nil, fmt.Errorf("unknown Repo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case repo.FieldDefaultBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultBranch(v)
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepoMutation) ResetField(name string) error {
	switch name {
	case repo.FieldName:
		m.ResetName()
		return nil
	case repo.FieldDefaultBranch:
		m.ResetDefaultBranch()
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepoMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.owner != nil {
		edges = append(edges, repo.EdgeOwner)
	}
	if m.project != nil {
		edges = append(edges, repo.EdgeProject)
	}
	if m.head != nil {
		edges = append(edges, repo.EdgeHead)
	}
	if m.commits != nil {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.vulnerability_reviews != nil {
		edges = append(edges, repo.EdgeVulnerabilityReviews)
	}
	if m.policies != nil {
		edges = append(edges, repo.EdgePolicies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case repo.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case repo.EdgeHead:
		if id := m.head; id != nil {
			return []ent.Value{*id}
		}
	case repo.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.commits))
		for id := range m.commits {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.vulnerability_reviews))
		for id := range m.vulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcommits != nil {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.removedvulnerability_reviews != nil {
		edges = append(edges, repo.EdgeVulnerabilityReviews)
	}
	if m.removedpolicies != nil {
		edges = append(edges, repo.EdgePolicies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.removedcommits))
		for id := range m.removedcommits {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeVulnerabilityReviews:
		ids := make([]ent.Value, 0, len(m.removedvulnerability_reviews))
		for id := range m.removedvulnerability_reviews {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedowner {
		edges = append(edges, repo.EdgeOwner)
	}
	if m.clearedproject {
		edges = append(edges, repo.EdgeProject)
	}
	if m.clearedhead {
		edges = append(edges, repo.EdgeHead)
	}
	if m.clearedcommits {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.clearedvulnerability_reviews {
		edges = append(edges, repo.EdgeVulnerabilityReviews)
	}
	if m.clearedpolicies {
		edges = append(edges, repo.EdgePolicies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepoMutation) EdgeCleared(name string) bool {
	switch name {
	case repo.EdgeOwner:
		return m.clearedowner
	case repo.EdgeProject:
		return m.clearedproject
	case repo.EdgeHead:
		return m.clearedhead
	case repo.EdgeCommits:
		return m.clearedcommits
	case repo.EdgeVulnerabilityReviews:
		return m.clearedvulnerability_reviews
	case repo.EdgePolicies:
		return m.clearedpolicies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepoMutation) ClearEdge(name string) error {
	switch name {
	case repo.EdgeOwner:
		m.ClearOwner()
		return nil
	case repo.EdgeProject:
		m.ClearProject()
		return nil
	case repo.EdgeHead:
		m.ClearHead()
		return nil
	}
	return fmt.Errorf("unknown Repo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepoMutation) ResetEdge(name string) error {
	switch name {
	case repo.EdgeOwner:
		m.ResetOwner()
		return nil
	case repo.EdgeProject:
		m.ResetProject()
		return nil
	case repo.EdgeHead:
		m.ResetHead()
		return nil
	case repo.EdgeCommits:
		m.ResetCommits()
		return nil
	case repo.EdgeVulnerabilityReviews:
		m.ResetVulnerabilityReviews()
		return nil
	case repo.EdgePolicies:
		m.ResetPolicies()
		return nil
	}
	return fmt.Errorf("unknown Repo edge %s", name)
}

// SPDXLicenseMutation represents an operation that mutates the SPDXLicense nodes in the graph.
type SPDXLicenseMutation struct {
	config
	op              Op
	typ             string
	id              *int
	license_id      *string
	name            *string
	reference       *string
	details_url     *string
	is_osi_approved *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*SPDXLicense, error)
	predicates      []predicate.SPDXLicense
}

var _ ent.Mutation = (*SPDXLicenseMutation)(nil)

// spdxlicenseOption allows management of the mutation configuration using functional options.
type spdxlicenseOption func(*SPDXLicenseMutation)

// newSPDXLicenseMutation creates new mutation for the SPDXLicense entity.
func newSPDXLicenseMutation(c config, op Op, opts ...spdxlicenseOption) *SPDXLicenseMutation {
	m := &SPDXLicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeSPDXLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSPDXLicenseID sets the ID field of the mutation.
func withSPDXLicenseID(id int) spdxlicenseOption {
	return func(m *SPDXLicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *SPDXLicense
		)
		m.oldValue = func(ctx context.Context) (*SPDXLicense, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SPDXLicense.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSPDXLicense sets the old SPDXLicense of the mutation.
func withSPDXLicense(node *SPDXLicense) spdxlicenseOption {
	return func(m *SPDXLicenseMutation) {
		m.oldValue = func(context.Context) (*SPDXLicense, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SPDXLicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SPDXLicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SPDXLicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLicenseID sets the "license_id" field.
func (m *SPDXLicenseMutation) SetLicenseID(s string) {
	m.license_id = &s
}

// LicenseID returns the value of the "license_id" field in the mutation.
func (m *SPDXLicenseMutation) LicenseID() (r string, exists bool) {
	v := m.license_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseID returns the old "license_id" field's value of the SPDXLicense entity.
// If the SPDXLicense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SPDXLicenseMutation) OldLicenseID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLicenseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLicenseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseID: %w", err)
	}
	return oldValue.LicenseID, nil
}

// ResetLicenseID resets all changes to the "license_id" field.
func (m *SPDXLicenseMutation) ResetLicenseID() {
	m.license_id = nil
}

// SetName sets the "name" field.
func (m *SPDXLicenseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SPDXLicenseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SPDXLicense entity.
// If the SPDXLicense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SPDXLicenseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SPDXLicenseMutation) ResetName() {
	m.name = nil
}

// SetReference sets the "reference" field.
func (m *SPDXLicenseMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *SPDXLicenseMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the SPDXLicense entity.
// If the SPDXLicense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SPDXLicenseMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *SPDXLicenseMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[spdxlicense.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *SPDXLicenseMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[spdxlicense.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *SPDXLicenseMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, spdxlicense.FieldReference)
}

// SetDetailsURL sets the "details_url" field.
func (m *SPDXLicenseMutation) SetDetailsURL(s string) {
	m.details_url = &s
}

// DetailsURL returns the value of the "details_url" field in the mutation.
func (m *SPDXLicenseMutation) DetailsURL() (r string, exists bool) {
	v := m.details_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailsURL returns the old "details_url" field's value of the SPDXLicense entity.
// If the SPDXLicense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SPDXLicenseMutation) OldDetailsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailsURL: %w", err)
	}
	return oldValue.DetailsURL, nil
}

// ClearDetailsURL clears the value of the "details_url" field.
func (m *SPDXLicenseMutation) ClearDetailsURL() {
	m.details_url = nil
	m.clearedFields[spdxlicense.FieldDetailsURL] = struct{}{}
}

// DetailsURLCleared returns if the "details_url" field was cleared in this mutation.
func (m *SPDXLicenseMutation) DetailsURLCleared() bool {
	_, ok := m.clearedFields[spdxlicense.FieldDetailsURL]
	return ok
}

// ResetDetailsURL resets all changes to the "details_url" field.
func (m *SPDXLicenseMutation) ResetDetailsURL() {
	m.details_url = nil
	delete(m.clearedFields, spdxlicense.FieldDetailsURL)
}

// SetIsOsiApproved sets the "is_osi_approved" field.
func (m *SPDXLicenseMutation) SetIsOsiApproved(b bool) {
	m.is_osi_approved = &b
}

// IsOsiApproved returns the value of the "is_osi_approved" field in the mutation.
func (m *SPDXLicenseMutation) IsOsiApproved() (r bool, exists bool) {
	v := m.is_osi_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOsiApproved returns the old "is_osi_approved" field's value of the SPDXLicense entity.
// If the SPDXLicense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SPDXLicenseMutation) OldIsOsiApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsOsiApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsOsiApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOsiApproved: %w", err)
	}
	return oldValue.IsOsiApproved, nil
}

// ResetIsOsiApproved resets all changes to the "is_osi_approved" field.
func (m *SPDXLicenseMutation) ResetIsOsiApproved() {
	m.is_osi_approved = nil
}

// Where appends a list predicates to the SPDXLicenseMutation builder.
func (m *SPDXLicenseMutation) Where(ps ...predicate.SPDXLicense) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SPDXLicenseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SPDXLicense).
func (m *SPDXLicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SPDXLicenseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.license_id != nil {
		fields = append(fields, spdxlicense.FieldLicenseID)
	}
	if m.name != nil {
		fields = append(fields, spdxlicense.FieldName)
	}
	if m.reference != nil {
		fields = append(fields, spdxlicense.FieldReference)
	}
	if m.details_url != nil {
		fields = append(fields, spdxlicense.FieldDetailsURL)
	}
	if m.is_osi_approved != nil {
		fields = append(fields, spdxlicense.FieldIsOsiApproved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SPDXLicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spdxlicense.FieldLicenseID:
		return m.LicenseID()
	case spdxlicense.FieldName:
		return m.Name()
	case spdxlicense.FieldReference:
		return m.Reference()
	case spdxlicense.FieldDetailsURL:
		return m.DetailsURL()
	case spdxlicense.FieldIsOsiApproved:
		return m.IsOsiApproved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SPDXLicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spdxlicense.FieldLicenseID:
		return m.OldLicenseID(ctx)
	case spdxlicense.FieldName:
		return m.OldName(ctx)
	case spdxlicense.FieldReference:
		return m.OldReference(ctx)
	case spdxlicense.FieldDetailsURL:
		return m.OldDetailsURL(ctx)
	case spdxlicense.FieldIsOsiApproved:
		return m.OldIsOsiApproved(ctx)
	}
	return nil, fmt.Errorf("unknown SPDXLicense field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SPDXLicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spdxlicense.FieldLicenseID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseID(v)
		return nil
	case spdxlicense.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case spdxlicense.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case spdxlicense.FieldDetailsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailsURL(v)
		return nil
	case spdxlicense.FieldIsOsiApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOsiApproved(v)
		return nil
	}
	return fmt.Errorf("unknown SPDXLicense field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SPDXLicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SPDXLicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SPDXLicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SPDXLicense numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SPDXLicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spdxlicense.FieldReference) {
		fields = append(fields, spdxlicense.FieldReference)
	}
	if m.FieldCleared(spdxlicense.FieldDetailsURL) {
		fields = append(fields, spdxlicense.FieldDetailsURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SPDXLicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SPDXLicenseMutation) ClearField(name string) error {
	switch name {
	case spdxlicense.FieldReference:
		m.ClearReference()
		return nil
	case spdxlicense.FieldDetailsURL:
		m.ClearDetailsURL()
		return nil
	}
	return fmt.Errorf("unknown SPDXLicense nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SPDXLicenseMutation) ResetField(name string) error {
	switch name {
	case spdxlicense.FieldLicenseID:
		m.ResetLicenseID()
		return nil
	case spdxlicense.FieldName:
		m.ResetName()
		return nil
	case spdxlicense.FieldReference:
		m.ResetReference()
		return nil
	case spdxlicense.FieldDetailsURL:
		m.ResetDetailsURL()
		return nil
	case spdxlicense.FieldIsOsiApproved:
		m.ResetIsOsiApproved()
		return nil
	}
	return fmt.Errorf("unknown SPDXLicense field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SPDXLicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SPDXLicenseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SPDXLicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SPDXLicenseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SPDXLicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SPDXLicenseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SPDXLicenseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SPDXLicense unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SPDXLicenseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SPDXLicense edge %s", name)
}

// TestCaseMutation represents an operation that mutates the TestCase nodes in the graph.
type TestCaseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	result        *bool
	message       *string
	elapsed       *float64
	addelapsed    *float64
	metadata      *schema.Metadata
	clearedFields map[string]struct{}
	run           *int
	clearedrun    bool
	done          bool
	oldValue      func(context.Context) (*TestCase, error)
	predicates    []predicate.TestCase
}

var _ ent.Mutation = (*TestCaseMutation)(nil)

// testcaseOption allows management of the mutation configuration using functional options.
type testcaseOption func(*TestCaseMutation)

// newTestCaseMutation creates new mutation for the TestCase entity.
func newTestCaseMutation(c config, op Op, opts ...testcaseOption) *TestCaseMutation {
	m := &TestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestCaseID sets the ID field of the mutation.
func withTestCaseID(id int) testcaseOption {
	return func(m *TestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *TestCase
		)
		m.oldValue = func(ctx context.Context) (*TestCase, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestCase sets the old TestCase of the mutation.
func withTestCase(node *TestCase) testcaseOption {
	return func(m *TestCaseMutation) {
		m.oldValue = func(context.Context) (*TestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestCaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *TestCaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestCaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestCaseMutation) ResetName() {
	m.name = nil
}

// SetResult sets the "result" field.
func (m *TestCaseMutation) SetResult(b bool) {
	m.result = &b
}

// Result returns the value of the "result" field in the mutation.
func (m *TestCaseMutation) Result() (r bool, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldResult(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *TestCaseMutation) ResetResult() {
	m.result = nil
}

// SetMessage sets the "message" field.
func (m *TestCaseMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TestCaseMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *TestCaseMutation) ResetMessage() {
	m.message = nil
}

// SetElapsed sets the "elapsed" field.
func (m *TestCaseMutation) SetElapsed(f float64) {
	m.elapsed = &f
	m.addelapsed = nil
}

// Elapsed returns the value of the "elapsed" field in the mutation.
func (m *TestCaseMutation) Elapsed() (r float64, exists bool) {
	v := m.elapsed
	if v == nil {
		return
	}
	return *v, true
}

// OldElapsed returns the old "elapsed" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldElapsed(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldElapsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldElapsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElapsed: %w", err)
	}
	return oldValue.Elapsed, nil
}

// AddElapsed adds f to the "elapsed" field.
func (m *TestCaseMutation) AddElapsed(f float64) {
	if m.addelapsed != nil {
		*m.addelapsed += f
	} else {
		m.addelapsed = &f
	}
}

// AddedElapsed returns the value that was added to the "elapsed" field in this mutation.
func (m *TestCaseMutation) AddedElapsed() (r float64, exists bool) {
	v := m.addelapsed
	if v == nil {
		return
	}
	return *v, true
}

// ResetElapsed resets all changes to the "elapsed" field.
func (m *TestCaseMutation) ResetElapsed() {
	m.elapsed = nil
	m.addelapsed = nil
}

// SetMetadata sets the "metadata" field.
func (m *TestCaseMutation) SetMetadata(s schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TestCaseMutation) Metadata() (r schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldMetadata(ctx context.Context) (v schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TestCaseMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[testcase.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TestCaseMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[testcase.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TestCaseMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, testcase.FieldMetadata)
}

// SetRunID sets the "run" edge to the TestRun entity by id.
func (m *TestCaseMutation) SetRunID(id int) {
	m.run = &id
}

// ClearRun clears the "run" edge to the TestRun entity.
func (m *TestCaseMutation) ClearRun() {
	m.clearedrun = true
}

// RunCleared reports if the "run" edge to the TestRun entity was cleared.
func (m *TestCaseMutation) RunCleared() bool {
	return m.clearedrun
}

// RunID returns the "run" edge ID in the mutation.
func (m *TestCaseMutation) RunID() (id int, exists bool) {
	if m.run != nil {
		return *m.run, true
	}
	return
}

// RunIDs returns the "run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *TestCaseMutation) RunIDs() (ids []int) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun resets all changes to the "run" edge.
func (m *TestCaseMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// Where appends a list predicates to the TestCaseMutation builder.
func (m *TestCaseMutation) Where(ps ...predicate.TestCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestCase).
func (m *TestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestCaseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, testcase.FieldName)
	}
	if m.result != nil {
		fields = append(fields, testcase.FieldResult)
	}
	if m.message != nil {
		fields = append(fields, testcase.FieldMessage)
	}
	if m.elapsed != nil {
		fields = append(fields, testcase.FieldElapsed)
	}
	if m.metadata != nil {
		fields = append(fields, testcase.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldName:
		return m.Name()
	case testcase.FieldResult:
		return m.Result()
	case testcase.FieldMessage:
		return m.Message()
	case testcase.FieldElapsed:
		return m.Elapsed()
	case testcase.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase.FieldName:
		return m.OldName(ctx)
	case testcase.FieldResult:
		return m.OldResult(ctx)
	case testcase.FieldMessage:
		return m.OldMessage(ctx)
	case testcase.FieldElapsed:
		return m.OldElapsed(ctx)
	case testcase.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown TestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testcase.FieldResult:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case testcase.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case testcase.FieldElapsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElapsed(v)
		return nil
	case testcase.FieldMetadata:
		v, ok := value.(schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addelapsed != nil {
		fields = append(fields, testcase.FieldElapsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldElapsed:
		return m.AddedElapsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldElapsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElapsed(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestCaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testcase.FieldMetadata) {
		fields = append(fields, testcase.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestCaseMutation) ClearField(name string) error {
	switch name {
	case testcase.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown TestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestCaseMutation) ResetField(name string) error {
	switch name {
	case testcase.FieldName:
		m.ResetName()
		return nil
	case testcase.FieldResult:
		m.ResetResult()
		return nil
	case testcase.FieldMessage:
		m.ResetMessage()
		return nil
	case testcase.FieldElapsed:
		m.ResetElapsed()
		return nil
	case testcase.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.run != nil {
		edges = append(edges, testcase.EdgeRun)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestCaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testcase.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestCaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrun {
		edges = append(edges, testcase.EdgeRun)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestCaseMutation) EdgeCleared(name string) bool {
	switch name {
	case testcase.EdgeRun:
		return m.clearedrun
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestCaseMutation) ClearEdge(name string) error {
	switch name {
	case testcase.EdgeRun:
		m.ClearRun()
		return nil
	}
	return fmt.Errorf("unknown TestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestCaseMutation) ResetEdge(name string) error {
	switch name {
	case testcase.EdgeRun:
		m.ResetRun()
		return nil
	}
	return fmt.Errorf("unknown TestCase edge %s", name)
}

// TestRunMutation represents an operation that mutates the TestRun nodes in the graph.
type TestRunMutation struct {
	config
	op             Op
	typ            string
	id             *int
	tool           *string
	time           *time.Time
	metadata       *schema.Metadata
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	entry          *int
	clearedentry   bool
	tests          map[int]struct{}
	removedtests   map[int]struct{}
	clearedtests   bool
	done           bool
	oldValue       func(context.Context) (*TestRun, error)
	predicates     []predicate.TestRun
}

var _ ent.Mutation = (*TestRunMutation)(nil)

// testrunOption allows management of the mutation configuration using functional options.
type testrunOption func(*TestRunMutation)

// newTestRunMutation creates new mutation for the TestRun entity.
func newTestRunMutation(c config, op Op, opts ...testrunOption) *TestRunMutation {
	m := &TestRunMutation{
		config:        c,
		op:            op,
		typ:           TypeTestRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestRunID sets the ID field of the mutation.
func withTestRunID(id int) testrunOption {
	return func(m *TestRunMutation) {
		var (
			err   error
			once  sync.Once
			value *TestRun
		)
		m.oldValue = func(ctx context.Context) (*TestRun, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestRun sets the old TestRun of the mutation.
func withTestRun(node *TestRun) testrunOption {
	return func(m *TestRunMutation) {
		m.oldValue = func(context.Context) (*TestRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestRunMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *TestRunMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *TestRunMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the TestRun entity.
// If the TestRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestRunMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *TestRunMutation) ResetTool() {
	m.tool = nil
}

// SetTime sets the "time" field.
func (m *TestRunMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *TestRunMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the TestRun entity.
// If the TestRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestRunMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *TestRunMutation) ResetTime() {
	m.time = nil
}

// SetMetadata sets the "metadata" field.
func (m *TestRunMutation) SetMetadata(s schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TestRunMutation) Metadata() (r schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the TestRun entity.
// If the TestRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestRunMutation) OldMetadata(ctx context.Context) (v schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TestRunMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[testrun.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TestRunMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[testrun.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TestRunMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, testrun.FieldMetadata)
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *TestRunMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *TestRunMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *TestRunMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *TestRunMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *TestRunMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *TestRunMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *TestRunMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *TestRunMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *TestRunMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *TestRunMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *TestRunMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *TestRunMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// AddTestIDs adds the "tests" edge to the TestCase entity by ids.
func (m *TestRunMutation) AddTestIDs(ids ...int) {
	if m.tests == nil {
		m.tests = make(map[int]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the TestCase entity.
func (m *TestRunMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the TestCase entity was cleared.
func (m *TestRunMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the TestCase entity by IDs.
func (m *TestRunMutation) RemoveTestIDs(ids ...int) {
	if m.removedtests == nil {
		m.removedtests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the TestCase entity.
func (m *TestRunMutation) RemovedTestsIDs() (ids []int) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *TestRunMutation) TestsIDs() (ids []int) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *TestRunMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Where appends a list predicates to the TestRunMutation builder.
func (m *TestRunMutation) Where(ps ...predicate.TestRun) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TestRunMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestRun).
func (m *TestRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestRunMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tool != nil {
		fields = append(fields, testrun.FieldTool)
	}
	if m.time != nil {
		fields = append(fields, testrun.FieldTime)
	}
	if m.metadata != nil {
		fields = append(fields, testrun.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testrun.FieldTool:
		return m.Tool()
	case testrun.FieldTime:
		return m.Time()
	case testrun.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testrun.FieldTool:
		return m.OldTool(ctx)
	case testrun.FieldTime:
		return m.OldTime(ctx)
	case testrun.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown TestRun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testrun.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	case testrun.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case testrun.FieldMetadata:
		v, ok := value.(schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown TestRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestRunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestRunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TestRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestRunMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testrun.FieldMetadata) {
		fields = append(fields, testrun.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestRunMutation) ClearField(name string) error {
	switch name {
	case testrun.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown TestRun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestRunMutation) ResetField(name string) error {
	switch name {
	case testrun.FieldTool:
		m.ResetTool()
		return nil
	case testrun.FieldTime:
		m.ResetTime()
		return nil
	case testrun.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown TestRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.release != nil {
		edges = append(edges, testrun.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, testrun.EdgeEntry)
	}
	if m.tests != nil {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestRunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testrun.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case testrun.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case testrun.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtests != nil {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestRunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testrun.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelease {
		edges = append(edges, testrun.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, testrun.EdgeEntry)
	}
	if m.clearedtests {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestRunMutation) EdgeCleared(name string) bool {
	switch name {
	case testrun.EdgeRelease:
		return m.clearedrelease
	case testrun.EdgeEntry:
		return m.clearedentry
	case testrun.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestRunMutation) ClearEdge(name string) error {
	switch name {
	case testrun.EdgeRelease:
		m.ClearRelease()
		return nil
	case testrun.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown TestRun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestRunMutation) ResetEdge(name string) error {
	switch name {
	case testrun.EdgeRelease:
		m.ResetRelease()
		return nil
	case testrun.EdgeEntry:
		m.ResetEntry()
		return nil
	case testrun.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown TestRun edge %s", name)
}

// VulnerabilityMutation represents an operation that mutates the Vulnerability nodes in the graph.
type VulnerabilityMutation struct {
	config
	op                Op
	typ               string
	id                *int
	vid               *string
	summary           *string
	description       *string
	severity_score    *float64
	addseverity_score *float64
	severity          *vulnerability.Severity
	published         *time.Time
	modified          *time.Time
	metadata          *schema.Metadata
	clearedFields     map[string]struct{}
	owner             *int
	clearedowner      bool
	components        map[int]struct{}
	removedcomponents map[int]struct{}
	clearedcomponents bool
	reviews           map[int]struct{}
	removedreviews    map[int]struct{}
	clearedreviews    bool
	instances         map[int]struct{}
	removedinstances  map[int]struct{}
	clearedinstances  bool
	done              bool
	oldValue          func(context.Context) (*Vulnerability, error)
	predicates        []predicate.Vulnerability
}

var _ ent.Mutation = (*VulnerabilityMutation)(nil)

// vulnerabilityOption allows management of the mutation configuration using functional options.
type vulnerabilityOption func(*VulnerabilityMutation)

// newVulnerabilityMutation creates new mutation for the Vulnerability entity.
func newVulnerabilityMutation(c config, op Op, opts ...vulnerabilityOption) *VulnerabilityMutation {
	m := &VulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityID sets the ID field of the mutation.
func withVulnerabilityID(id int) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Vulnerability
		)
		m.oldValue = func(ctx context.Context) (*Vulnerability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerability sets the old Vulnerability of the mutation.
func withVulnerability(node *Vulnerability) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		m.oldValue = func(context.Context) (*Vulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetVid sets the "vid" field.
func (m *VulnerabilityMutation) SetVid(s string) {
	m.vid = &s
}

// Vid returns the value of the "vid" field in the mutation.
func (m *VulnerabilityMutation) Vid() (r string, exists bool) {
	v := m.vid
	if v == nil {
		return
	}
	return *v, true
}

// OldVid returns the old "vid" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldVid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVid: %w", err)
	}
	return oldValue.Vid, nil
}

// ResetVid resets all changes to the "vid" field.
func (m *VulnerabilityMutation) ResetVid() {
	m.vid = nil
}

// SetSummary sets the "summary" field.
func (m *VulnerabilityMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *VulnerabilityMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *VulnerabilityMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[vulnerability.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *VulnerabilityMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *VulnerabilityMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, vulnerability.FieldSummary)
}

// SetDescription sets the "description" field.
func (m *VulnerabilityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VulnerabilityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VulnerabilityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vulnerability.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VulnerabilityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VulnerabilityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vulnerability.FieldDescription)
}

// SetSeverityScore sets the "severity_score" field.
func (m *VulnerabilityMutation) SetSeverityScore(f float64) {
	m.severity_score = &f
	m.addseverity_score = nil
}

// SeverityScore returns the value of the "severity_score" field in the mutation.
func (m *VulnerabilityMutation) SeverityScore() (r float64, exists bool) {
	v := m.severity_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverityScore returns the old "severity_score" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSeverityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverityScore: %w", err)
	}
	return oldValue.SeverityScore, nil
}

// AddSeverityScore adds f to the "severity_score" field.
func (m *VulnerabilityMutation) AddSeverityScore(f float64) {
	if m.addseverity_score != nil {
		*m.addseverity_score += f
	} else {
		m.addseverity_score = &f
	}
}

// AddedSeverityScore returns the value that was added to the "severity_score" field in this mutation.
func (m *VulnerabilityMutation) AddedSeverityScore() (r float64, exists bool) {
	v := m.addseverity_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeverityScore resets all changes to the "severity_score" field.
func (m *VulnerabilityMutation) ResetSeverityScore() {
	m.severity_score = nil
	m.addseverity_score = nil
}

// SetSeverity sets the "severity" field.
func (m *VulnerabilityMutation) SetSeverity(v vulnerability.Severity) {
	m.severity = &v
}

// Severity returns the value of the "severity" field in the mutation.
func (m *VulnerabilityMutation) Severity() (r vulnerability.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldSeverity(ctx context.Context) (v vulnerability.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *VulnerabilityMutation) ResetSeverity() {
	m.severity = nil
}

// SetPublished sets the "published" field.
func (m *VulnerabilityMutation) SetPublished(t time.Time) {
	m.published = &t
}

// Published returns the value of the "published" field in the mutation.
func (m *VulnerabilityMutation) Published() (r time.Time, exists bool) {
	v := m.published
	if v == nil {
		return
	}
	return *v, true
}

// OldPublished returns the old "published" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldPublished(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublished: %w", err)
	}
	return oldValue.Published, nil
}

// ClearPublished clears the value of the "published" field.
func (m *VulnerabilityMutation) ClearPublished() {
	m.published = nil
	m.clearedFields[vulnerability.FieldPublished] = struct{}{}
}

// PublishedCleared returns if the "published" field was cleared in this mutation.
func (m *VulnerabilityMutation) PublishedCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldPublished]
	return ok
}

// ResetPublished resets all changes to the "published" field.
func (m *VulnerabilityMutation) ResetPublished() {
	m.published = nil
	delete(m.clearedFields, vulnerability.FieldPublished)
}

// SetModified sets the "modified" field.
func (m *VulnerabilityMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *VulnerabilityMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *VulnerabilityMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[vulnerability.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *VulnerabilityMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *VulnerabilityMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, vulnerability.FieldModified)
}

// SetMetadata sets the "metadata" field.
func (m *VulnerabilityMutation) SetMetadata(s schema.Metadata) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *VulnerabilityMutation) Metadata() (r schema.Metadata, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Vulnerability entity.
// If the Vulnerability object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityMutation) OldMetadata(ctx context.Context) (v schema.Metadata, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *VulnerabilityMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[vulnerability.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *VulnerabilityMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[vulnerability.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *VulnerabilityMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, vulnerability.FieldMetadata)
}

// SetOwnerID sets the "owner" edge to the Organization entity by id.
func (m *VulnerabilityMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *VulnerabilityMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *VulnerabilityMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *VulnerabilityMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *VulnerabilityMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *VulnerabilityMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *VulnerabilityMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *VulnerabilityMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *VulnerabilityMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *VulnerabilityMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *VulnerabilityMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *VulnerabilityMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddReviewIDs adds the "reviews" edge to the VulnerabilityReview entity by ids.
func (m *VulnerabilityMutation) AddReviewIDs(ids ...int) {
	if m.reviews == nil {
		m.reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the VulnerabilityReview entity.
func (m *VulnerabilityMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the VulnerabilityReview entity was cleared.
func (m *VulnerabilityMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the VulnerabilityReview entity by IDs.
func (m *VulnerabilityMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the VulnerabilityReview entity.
func (m *VulnerabilityMutation) RemovedReviewsIDs() (ids []int) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *VulnerabilityMutation) ReviewsIDs() (ids []int) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *VulnerabilityMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddInstanceIDs adds the "instances" edge to the ReleaseVulnerability entity by ids.
func (m *VulnerabilityMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the ReleaseVulnerability entity was cleared.
func (m *VulnerabilityMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the ReleaseVulnerability entity by IDs.
func (m *VulnerabilityMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *VulnerabilityMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *VulnerabilityMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the VulnerabilityMutation builder.
func (m *VulnerabilityMutation) Where(ps ...predicate.Vulnerability) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnerabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vulnerability).
func (m *VulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.vid != nil {
		fields = append(fields, vulnerability.FieldVid)
	}
	if m.summary != nil {
		fields = append(fields, vulnerability.FieldSummary)
	}
	if m.description != nil {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.severity_score != nil {
		fields = append(fields, vulnerability.FieldSeverityScore)
	}
	if m.severity != nil {
		fields = append(fields, vulnerability.FieldSeverity)
	}
	if m.published != nil {
		fields = append(fields, vulnerability.FieldPublished)
	}
	if m.modified != nil {
		fields = append(fields, vulnerability.FieldModified)
	}
	if m.metadata != nil {
		fields = append(fields, vulnerability.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldVid:
		return m.Vid()
	case vulnerability.FieldSummary:
		return m.Summary()
	case vulnerability.FieldDescription:
		return m.Description()
	case vulnerability.FieldSeverityScore:
		return m.SeverityScore()
	case vulnerability.FieldSeverity:
		return m.Severity()
	case vulnerability.FieldPublished:
		return m.Published()
	case vulnerability.FieldModified:
		return m.Modified()
	case vulnerability.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerability.FieldVid:
		return m.OldVid(ctx)
	case vulnerability.FieldSummary:
		return m.OldSummary(ctx)
	case vulnerability.FieldDescription:
		return m.OldDescription(ctx)
	case vulnerability.FieldSeverityScore:
		return m.OldSeverityScore(ctx)
	case vulnerability.FieldSeverity:
		return m.OldSeverity(ctx)
	case vulnerability.FieldPublished:
		return m.OldPublished(ctx)
	case vulnerability.FieldModified:
		return m.OldModified(ctx)
	case vulnerability.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Vulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldVid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVid(v)
		return nil
	case vulnerability.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case vulnerability.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vulnerability.FieldSeverityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverityScore(v)
		return nil
	case vulnerability.FieldSeverity:
		v, ok := value.(vulnerability.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case vulnerability.FieldPublished:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublished(v)
		return nil
	case vulnerability.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	case vulnerability.FieldMetadata:
		v, ok := value.(schema.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityMutation) AddedFields() []string {
	var fields []string
	if m.addseverity_score != nil {
		fields = append(fields, vulnerability.FieldSeverityScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vulnerability.FieldSeverityScore:
		return m.AddedSeverityScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vulnerability.FieldSeverityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeverityScore(v)
		return nil
	}
	return fmt.Errorf("unknown Vulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vulnerability.FieldSummary) {
		fields = append(fields, vulnerability.FieldSummary)
	}
	if m.FieldCleared(vulnerability.FieldDescription) {
		fields = append(fields, vulnerability.FieldDescription)
	}
	if m.FieldCleared(vulnerability.FieldPublished) {
		fields = append(fields, vulnerability.FieldPublished)
	}
	if m.FieldCleared(vulnerability.FieldModified) {
		fields = append(fields, vulnerability.FieldModified)
	}
	if m.FieldCleared(vulnerability.FieldMetadata) {
		fields = append(fields, vulnerability.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ClearField(name string) error {
	switch name {
	case vulnerability.FieldSummary:
		m.ClearSummary()
		return nil
	case vulnerability.FieldDescription:
		m.ClearDescription()
		return nil
	case vulnerability.FieldPublished:
		m.ClearPublished()
		return nil
	case vulnerability.FieldModified:
		m.ClearModified()
		return nil
	case vulnerability.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ResetField(name string) error {
	switch name {
	case vulnerability.FieldVid:
		m.ResetVid()
		return nil
	case vulnerability.FieldSummary:
		m.ResetSummary()
		return nil
	case vulnerability.FieldDescription:
		m.ResetDescription()
		return nil
	case vulnerability.FieldSeverityScore:
		m.ResetSeverityScore()
		return nil
	case vulnerability.FieldSeverity:
		m.ResetSeverity()
		return nil
	case vulnerability.FieldPublished:
		m.ResetPublished()
		return nil
	case vulnerability.FieldModified:
		m.ResetModified()
		return nil
	case vulnerability.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, vulnerability.EdgeOwner)
	}
	if m.components != nil {
		edges = append(edges, vulnerability.EdgeComponents)
	}
	if m.reviews != nil {
		edges = append(edges, vulnerability.EdgeReviews)
	}
	if m.instances != nil {
		edges = append(edges, vulnerability.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case vulnerability.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomponents != nil {
		edges = append(edges, vulnerability.EdgeComponents)
	}
	if m.removedreviews != nil {
		edges = append(edges, vulnerability.EdgeReviews)
	}
	if m.removedinstances != nil {
		edges = append(edges, vulnerability.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case vulnerability.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, vulnerability.EdgeOwner)
	}
	if m.clearedcomponents {
		edges = append(edges, vulnerability.EdgeComponents)
	}
	if m.clearedreviews {
		edges = append(edges, vulnerability.EdgeReviews)
	}
	if m.clearedinstances {
		edges = append(edges, vulnerability.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerability.EdgeOwner:
		return m.clearedowner
	case vulnerability.EdgeComponents:
		return m.clearedcomponents
	case vulnerability.EdgeReviews:
		return m.clearedreviews
	case vulnerability.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	case vulnerability.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case vulnerability.EdgeOwner:
		m.ResetOwner()
		return nil
	case vulnerability.EdgeComponents:
		m.ResetComponents()
		return nil
	case vulnerability.EdgeReviews:
		m.ResetReviews()
		return nil
	case vulnerability.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability edge %s", name)
}

// VulnerabilityReviewMutation represents an operation that mutates the VulnerabilityReview nodes in the graph.
type VulnerabilityReviewMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	note                 *string
	decision             *vulnerabilityreview.Decision
	clearedFields        map[string]struct{}
	vulnerability        *int
	clearedvulnerability bool
	projects             map[int]struct{}
	removedprojects      map[int]struct{}
	clearedprojects      bool
	repos                map[int]struct{}
	removedrepos         map[int]struct{}
	clearedrepos         bool
	releases             map[int]struct{}
	removedreleases      map[int]struct{}
	clearedreleases      bool
	instances            map[int]struct{}
	removedinstances     map[int]struct{}
	clearedinstances     bool
	done                 bool
	oldValue             func(context.Context) (*VulnerabilityReview, error)
	predicates           []predicate.VulnerabilityReview
}

var _ ent.Mutation = (*VulnerabilityReviewMutation)(nil)

// vulnerabilityreviewOption allows management of the mutation configuration using functional options.
type vulnerabilityreviewOption func(*VulnerabilityReviewMutation)

// newVulnerabilityReviewMutation creates new mutation for the VulnerabilityReview entity.
func newVulnerabilityReviewMutation(c config, op Op, opts ...vulnerabilityreviewOption) *VulnerabilityReviewMutation {
	m := &VulnerabilityReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerabilityReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityReviewID sets the ID field of the mutation.
func withVulnerabilityReviewID(id int) vulnerabilityreviewOption {
	return func(m *VulnerabilityReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *VulnerabilityReview
		)
		m.oldValue = func(ctx context.Context) (*VulnerabilityReview, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VulnerabilityReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerabilityReview sets the old VulnerabilityReview of the mutation.
func withVulnerabilityReview(node *VulnerabilityReview) vulnerabilityreviewOption {
	return func(m *VulnerabilityReviewMutation) {
		m.oldValue = func(context.Context) (*VulnerabilityReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNote sets the "note" field.
func (m *VulnerabilityReviewMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *VulnerabilityReviewMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the VulnerabilityReview entity.
// If the VulnerabilityReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityReviewMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *VulnerabilityReviewMutation) ResetNote() {
	m.note = nil
}

// SetDecision sets the "decision" field.
func (m *VulnerabilityReviewMutation) SetDecision(v vulnerabilityreview.Decision) {
	m.decision = &v
}

// Decision returns the value of the "decision" field in the mutation.
func (m *VulnerabilityReviewMutation) Decision() (r vulnerabilityreview.Decision, exists bool) {
	v := m.decision
	if v == nil {
		return
	}
	return *v, true
}

// OldDecision returns the old "decision" field's value of the VulnerabilityReview entity.
// If the VulnerabilityReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VulnerabilityReviewMutation) OldDecision(ctx context.Context) (v vulnerabilityreview.Decision, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDecision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDecision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecision: %w", err)
	}
	return oldValue.Decision, nil
}

// ResetDecision resets all changes to the "decision" field.
func (m *VulnerabilityReviewMutation) ResetDecision() {
	m.decision = nil
}

// SetVulnerabilityID sets the "vulnerability" edge to the Vulnerability entity by id.
func (m *VulnerabilityReviewMutation) SetVulnerabilityID(id int) {
	m.vulnerability = &id
}

// ClearVulnerability clears the "vulnerability" edge to the Vulnerability entity.
func (m *VulnerabilityReviewMutation) ClearVulnerability() {
	m.clearedvulnerability = true
}

// VulnerabilityCleared reports if the "vulnerability" edge to the Vulnerability entity was cleared.
func (m *VulnerabilityReviewMutation) VulnerabilityCleared() bool {
	return m.clearedvulnerability
}

// VulnerabilityID returns the "vulnerability" edge ID in the mutation.
func (m *VulnerabilityReviewMutation) VulnerabilityID() (id int, exists bool) {
	if m.vulnerability != nil {
		return *m.vulnerability, true
	}
	return
}

// VulnerabilityIDs returns the "vulnerability" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VulnerabilityID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityReviewMutation) VulnerabilityIDs() (ids []int) {
	if id := m.vulnerability; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVulnerability resets all changes to the "vulnerability" edge.
func (m *VulnerabilityReviewMutation) ResetVulnerability() {
	m.vulnerability = nil
	m.clearedvulnerability = false
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *VulnerabilityReviewMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *VulnerabilityReviewMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *VulnerabilityReviewMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *VulnerabilityReviewMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *VulnerabilityReviewMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddRepoIDs adds the "repos" edge to the Repo entity by ids.
func (m *VulnerabilityReviewMutation) AddRepoIDs(ids ...int) {
	if m.repos == nil {
		m.repos = make(map[int]struct{})
	}
	for i := range ids {
		m.repos[ids[i]] = struct{}{}
	}
}

// ClearRepos clears the "repos" edge to the Repo entity.
func (m *VulnerabilityReviewMutation) ClearRepos() {
	m.clearedrepos = true
}

// ReposCleared reports if the "repos" edge to the Repo entity was cleared.
func (m *VulnerabilityReviewMutation) ReposCleared() bool {
	return m.clearedrepos
}

// RemoveRepoIDs removes the "repos" edge to the Repo entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepos == nil {
		m.removedrepos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repos, ids[i])
		m.removedrepos[ids[i]] = struct{}{}
	}
}

// RemovedRepos returns the removed IDs of the "repos" edge to the Repo entity.
func (m *VulnerabilityReviewMutation) RemovedReposIDs() (ids []int) {
	for id := range m.removedrepos {
		ids = append(ids, id)
	}
	return
}

// ReposIDs returns the "repos" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) ReposIDs() (ids []int) {
	for id := range m.repos {
		ids = append(ids, id)
	}
	return
}

// ResetRepos resets all changes to the "repos" edge.
func (m *VulnerabilityReviewMutation) ResetRepos() {
	m.repos = nil
	m.clearedrepos = false
	m.removedrepos = nil
}

// AddReleaseIDs adds the "releases" edge to the Release entity by ids.
func (m *VulnerabilityReviewMutation) AddReleaseIDs(ids ...int) {
	if m.releases == nil {
		m.releases = make(map[int]struct{})
	}
	for i := range ids {
		m.releases[ids[i]] = struct{}{}
	}
}

// ClearReleases clears the "releases" edge to the Release entity.
func (m *VulnerabilityReviewMutation) ClearReleases() {
	m.clearedreleases = true
}

// ReleasesCleared reports if the "releases" edge to the Release entity was cleared.
func (m *VulnerabilityReviewMutation) ReleasesCleared() bool {
	return m.clearedreleases
}

// RemoveReleaseIDs removes the "releases" edge to the Release entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveReleaseIDs(ids ...int) {
	if m.removedreleases == nil {
		m.removedreleases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.releases, ids[i])
		m.removedreleases[ids[i]] = struct{}{}
	}
}

// RemovedReleases returns the removed IDs of the "releases" edge to the Release entity.
func (m *VulnerabilityReviewMutation) RemovedReleasesIDs() (ids []int) {
	for id := range m.removedreleases {
		ids = append(ids, id)
	}
	return
}

// ReleasesIDs returns the "releases" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) ReleasesIDs() (ids []int) {
	for id := range m.releases {
		ids = append(ids, id)
	}
	return
}

// ResetReleases resets all changes to the "releases" edge.
func (m *VulnerabilityReviewMutation) ResetReleases() {
	m.releases = nil
	m.clearedreleases = false
	m.removedreleases = nil
}

// AddInstanceIDs adds the "instances" edge to the ReleaseVulnerability entity by ids.
func (m *VulnerabilityReviewMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityReviewMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the ReleaseVulnerability entity was cleared.
func (m *VulnerabilityReviewMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the ReleaseVulnerability entity by IDs.
func (m *VulnerabilityReviewMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the ReleaseVulnerability entity.
func (m *VulnerabilityReviewMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *VulnerabilityReviewMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *VulnerabilityReviewMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the VulnerabilityReviewMutation builder.
func (m *VulnerabilityReviewMutation) Where(ps ...predicate.VulnerabilityReview) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VulnerabilityReviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VulnerabilityReview).
func (m *VulnerabilityReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityReviewMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.note != nil {
		fields = append(fields, vulnerabilityreview.FieldNote)
	}
	if m.decision != nil {
		fields = append(fields, vulnerabilityreview.FieldDecision)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vulnerabilityreview.FieldNote:
		return m.Note()
	case vulnerabilityreview.FieldDecision:
		return m.Decision()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vulnerabilityreview.FieldNote:
		return m.OldNote(ctx)
	case vulnerabilityreview.FieldDecision:
		return m.OldDecision(ctx)
	}
	return nil, fmt.Errorf("unknown VulnerabilityReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vulnerabilityreview.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case vulnerabilityreview.FieldDecision:
		v, ok := value.(vulnerabilityreview.Decision)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecision(v)
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityReviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityReviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VulnerabilityReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VulnerabilityReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityReviewMutation) ResetField(name string) error {
	switch name {
	case vulnerabilityreview.FieldNote:
		m.ResetNote()
		return nil
	case vulnerabilityreview.FieldDecision:
		m.ResetDecision()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.vulnerability != nil {
		edges = append(edges, vulnerabilityreview.EdgeVulnerability)
	}
	if m.projects != nil {
		edges = append(edges, vulnerabilityreview.EdgeProjects)
	}
	if m.repos != nil {
		edges = append(edges, vulnerabilityreview.EdgeRepos)
	}
	if m.releases != nil {
		edges = append(edges, vulnerabilityreview.EdgeReleases)
	}
	if m.instances != nil {
		edges = append(edges, vulnerabilityreview.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		if id := m.vulnerability; id != nil {
			return []ent.Value{*id}
		}
	case vulnerabilityreview.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.repos))
		for id := range m.repos {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeReleases:
		ids := make([]ent.Value, 0, len(m.releases))
		for id := range m.releases {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedprojects != nil {
		edges = append(edges, vulnerabilityreview.EdgeProjects)
	}
	if m.removedrepos != nil {
		edges = append(edges, vulnerabilityreview.EdgeRepos)
	}
	if m.removedreleases != nil {
		edges = append(edges, vulnerabilityreview.EdgeReleases)
	}
	if m.removedinstances != nil {
		edges = append(edges, vulnerabilityreview.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vulnerabilityreview.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.removedrepos))
		for id := range m.removedrepos {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeReleases:
		ids := make([]ent.Value, 0, len(m.removedreleases))
		for id := range m.removedreleases {
			ids = append(ids, id)
		}
		return ids
	case vulnerabilityreview.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedvulnerability {
		edges = append(edges, vulnerabilityreview.EdgeVulnerability)
	}
	if m.clearedprojects {
		edges = append(edges, vulnerabilityreview.EdgeProjects)
	}
	if m.clearedrepos {
		edges = append(edges, vulnerabilityreview.EdgeRepos)
	}
	if m.clearedreleases {
		edges = append(edges, vulnerabilityreview.EdgeReleases)
	}
	if m.clearedinstances {
		edges = append(edges, vulnerabilityreview.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		return m.clearedvulnerability
	case vulnerabilityreview.EdgeProjects:
		return m.clearedprojects
	case vulnerabilityreview.EdgeRepos:
		return m.clearedrepos
	case vulnerabilityreview.EdgeReleases:
		return m.clearedreleases
	case vulnerabilityreview.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityReviewMutation) ClearEdge(name string) error {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		m.ClearVulnerability()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityReviewMutation) ResetEdge(name string) error {
	switch name {
	case vulnerabilityreview.EdgeVulnerability:
		m.ResetVulnerability()
		return nil
	case vulnerabilityreview.EdgeProjects:
		m.ResetProjects()
		return nil
	case vulnerabilityreview.EdgeRepos:
		m.ResetRepos()
		return nil
	case vulnerabilityreview.EdgeReleases:
		m.ResetReleases()
		return nil
	case vulnerabilityreview.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown VulnerabilityReview edge %s", name)
}
