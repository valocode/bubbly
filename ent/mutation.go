// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/cve"
	"github.com/valocode/bubbly/ent/cverule"
	"github.com/valocode/bubbly/ent/cvescan"
	"github.com/valocode/bubbly/ent/cwe"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licensescan"
	"github.com/valocode/bubbly/ent/licenseusage"
	"github.com/valocode/bubbly/ent/predicate"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecheck"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArtifact      = "Artifact"
	TypeCVE           = "CVE"
	TypeCVERule       = "CVERule"
	TypeCVEScan       = "CVEScan"
	TypeCWE           = "CWE"
	TypeCodeIssue     = "CodeIssue"
	TypeCodeScan      = "CodeScan"
	TypeComponent     = "Component"
	TypeGitCommit     = "GitCommit"
	TypeLicense       = "License"
	TypeLicenseScan   = "LicenseScan"
	TypeLicenseUsage  = "LicenseUsage"
	TypeProject       = "Project"
	TypeRelease       = "Release"
	TypeReleaseCheck  = "ReleaseCheck"
	TypeReleaseEntry  = "ReleaseEntry"
	TypeRepo          = "Repo"
	TypeTestCase      = "TestCase"
	TypeTestRun       = "TestRun"
	TypeVulnerability = "Vulnerability"
)

// ArtifactMutation represents an operation that mutates the Artifact nodes in the graph.
type ArtifactMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	sha256         *string
	_type          *artifact.Type
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	entry          *int
	clearedentry   bool
	done           bool
	oldValue       func(context.Context) (*Artifact, error)
	predicates     []predicate.Artifact
}

var _ ent.Mutation = (*ArtifactMutation)(nil)

// artifactOption allows management of the mutation configuration using functional options.
type artifactOption func(*ArtifactMutation)

// newArtifactMutation creates new mutation for the Artifact entity.
func newArtifactMutation(c config, op Op, opts ...artifactOption) *ArtifactMutation {
	m := &ArtifactMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactID sets the ID field of the mutation.
func withArtifactID(id int) artifactOption {
	return func(m *ArtifactMutation) {
		var (
			err   error
			once  sync.Once
			value *Artifact
		)
		m.oldValue = func(ctx context.Context) (*Artifact, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artifact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifact sets the old Artifact of the mutation.
func withArtifact(node *Artifact) artifactOption {
	return func(m *ArtifactMutation) {
		m.oldValue = func(context.Context) (*Artifact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ArtifactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ArtifactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ArtifactMutation) ResetName() {
	m.name = nil
}

// SetSha256 sets the "sha256" field.
func (m *ArtifactMutation) SetSha256(s string) {
	m.sha256 = &s
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *ArtifactMutation) Sha256() (r string, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *ArtifactMutation) ResetSha256() {
	m.sha256 = nil
}

// SetType sets the "type" field.
func (m *ArtifactMutation) SetType(a artifact.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *ArtifactMutation) GetType() (r artifact.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Artifact entity.
// If the Artifact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactMutation) OldType(ctx context.Context) (v artifact.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ArtifactMutation) ResetType() {
	m._type = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ArtifactMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ArtifactMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ArtifactMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ArtifactMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ArtifactMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *ArtifactMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *ArtifactMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *ArtifactMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *ArtifactMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *ArtifactMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *ArtifactMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// Op returns the operation name.
func (m *ArtifactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Artifact).
func (m *ArtifactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, artifact.FieldName)
	}
	if m.sha256 != nil {
		fields = append(fields, artifact.FieldSha256)
	}
	if m._type != nil {
		fields = append(fields, artifact.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifact.FieldName:
		return m.Name()
	case artifact.FieldSha256:
		return m.Sha256()
	case artifact.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifact.FieldName:
		return m.OldName(ctx)
	case artifact.FieldSha256:
		return m.OldSha256(ctx)
	case artifact.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Artifact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case artifact.FieldSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case artifact.FieldType:
		v, ok := value.(artifact.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Artifact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artifact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactMutation) ResetField(name string) error {
	switch name {
	case artifact.FieldName:
		m.ResetName()
		return nil
	case artifact.FieldSha256:
		m.ResetSha256()
		return nil
	case artifact.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Artifact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.release != nil {
		edges = append(edges, artifact.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, artifact.EdgeEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifact.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case artifact.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrelease {
		edges = append(edges, artifact.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, artifact.EdgeEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactMutation) EdgeCleared(name string) bool {
	switch name {
	case artifact.EdgeRelease:
		return m.clearedrelease
	case artifact.EdgeEntry:
		return m.clearedentry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactMutation) ClearEdge(name string) error {
	switch name {
	case artifact.EdgeRelease:
		m.ClearRelease()
		return nil
	case artifact.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown Artifact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactMutation) ResetEdge(name string) error {
	switch name {
	case artifact.EdgeRelease:
		m.ResetRelease()
		return nil
	case artifact.EdgeEntry:
		m.ResetEntry()
		return nil
	}
	return fmt.Errorf("unknown Artifact edge %s", name)
}

// CVEMutation represents an operation that mutates the CVE nodes in the graph.
type CVEMutation struct {
	config
	op                Op
	typ               string
	id                *int
	cve_id            *string
	description       *string
	severity_score    *float64
	addseverity_score *float64
	severity          *cve.Severity
	published_data    *time.Time
	modified_data     *time.Time
	clearedFields     map[string]struct{}
	found             map[int]struct{}
	removedfound      map[int]struct{}
	clearedfound      bool
	rules             map[int]struct{}
	removedrules      map[int]struct{}
	clearedrules      bool
	done              bool
	oldValue          func(context.Context) (*CVE, error)
	predicates        []predicate.CVE
}

var _ ent.Mutation = (*CVEMutation)(nil)

// cveOption allows management of the mutation configuration using functional options.
type cveOption func(*CVEMutation)

// newCVEMutation creates new mutation for the CVE entity.
func newCVEMutation(c config, op Op, opts ...cveOption) *CVEMutation {
	m := &CVEMutation{
		config:        c,
		op:            op,
		typ:           TypeCVE,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCVEID sets the ID field of the mutation.
func withCVEID(id int) cveOption {
	return func(m *CVEMutation) {
		var (
			err   error
			once  sync.Once
			value *CVE
		)
		m.oldValue = func(ctx context.Context) (*CVE, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CVE.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCVE sets the old CVE of the mutation.
func withCVE(node *CVE) cveOption {
	return func(m *CVEMutation) {
		m.oldValue = func(context.Context) (*CVE, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CVEMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CVEMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CVEMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCveID sets the "cve_id" field.
func (m *CVEMutation) SetCveID(s string) {
	m.cve_id = &s
}

// CveID returns the value of the "cve_id" field in the mutation.
func (m *CVEMutation) CveID() (r string, exists bool) {
	v := m.cve_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCveID returns the old "cve_id" field's value of the CVE entity.
// If the CVE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVEMutation) OldCveID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCveID: %w", err)
	}
	return oldValue.CveID, nil
}

// ResetCveID resets all changes to the "cve_id" field.
func (m *CVEMutation) ResetCveID() {
	m.cve_id = nil
}

// SetDescription sets the "description" field.
func (m *CVEMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CVEMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CVE entity.
// If the CVE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVEMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CVEMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cve.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CVEMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cve.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CVEMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cve.FieldDescription)
}

// SetSeverityScore sets the "severity_score" field.
func (m *CVEMutation) SetSeverityScore(f float64) {
	m.severity_score = &f
	m.addseverity_score = nil
}

// SeverityScore returns the value of the "severity_score" field in the mutation.
func (m *CVEMutation) SeverityScore() (r float64, exists bool) {
	v := m.severity_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverityScore returns the old "severity_score" field's value of the CVE entity.
// If the CVE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVEMutation) OldSeverityScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverityScore: %w", err)
	}
	return oldValue.SeverityScore, nil
}

// AddSeverityScore adds f to the "severity_score" field.
func (m *CVEMutation) AddSeverityScore(f float64) {
	if m.addseverity_score != nil {
		*m.addseverity_score += f
	} else {
		m.addseverity_score = &f
	}
}

// AddedSeverityScore returns the value that was added to the "severity_score" field in this mutation.
func (m *CVEMutation) AddedSeverityScore() (r float64, exists bool) {
	v := m.addseverity_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeverityScore resets all changes to the "severity_score" field.
func (m *CVEMutation) ResetSeverityScore() {
	m.severity_score = nil
	m.addseverity_score = nil
}

// SetSeverity sets the "severity" field.
func (m *CVEMutation) SetSeverity(c cve.Severity) {
	m.severity = &c
}

// Severity returns the value of the "severity" field in the mutation.
func (m *CVEMutation) Severity() (r cve.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the CVE entity.
// If the CVE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVEMutation) OldSeverity(ctx context.Context) (v cve.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *CVEMutation) ResetSeverity() {
	m.severity = nil
}

// SetPublishedData sets the "published_data" field.
func (m *CVEMutation) SetPublishedData(t time.Time) {
	m.published_data = &t
}

// PublishedData returns the value of the "published_data" field in the mutation.
func (m *CVEMutation) PublishedData() (r time.Time, exists bool) {
	v := m.published_data
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedData returns the old "published_data" field's value of the CVE entity.
// If the CVE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVEMutation) OldPublishedData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublishedData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublishedData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedData: %w", err)
	}
	return oldValue.PublishedData, nil
}

// ClearPublishedData clears the value of the "published_data" field.
func (m *CVEMutation) ClearPublishedData() {
	m.published_data = nil
	m.clearedFields[cve.FieldPublishedData] = struct{}{}
}

// PublishedDataCleared returns if the "published_data" field was cleared in this mutation.
func (m *CVEMutation) PublishedDataCleared() bool {
	_, ok := m.clearedFields[cve.FieldPublishedData]
	return ok
}

// ResetPublishedData resets all changes to the "published_data" field.
func (m *CVEMutation) ResetPublishedData() {
	m.published_data = nil
	delete(m.clearedFields, cve.FieldPublishedData)
}

// SetModifiedData sets the "modified_data" field.
func (m *CVEMutation) SetModifiedData(t time.Time) {
	m.modified_data = &t
}

// ModifiedData returns the value of the "modified_data" field in the mutation.
func (m *CVEMutation) ModifiedData() (r time.Time, exists bool) {
	v := m.modified_data
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedData returns the old "modified_data" field's value of the CVE entity.
// If the CVE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVEMutation) OldModifiedData(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModifiedData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModifiedData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedData: %w", err)
	}
	return oldValue.ModifiedData, nil
}

// ClearModifiedData clears the value of the "modified_data" field.
func (m *CVEMutation) ClearModifiedData() {
	m.modified_data = nil
	m.clearedFields[cve.FieldModifiedData] = struct{}{}
}

// ModifiedDataCleared returns if the "modified_data" field was cleared in this mutation.
func (m *CVEMutation) ModifiedDataCleared() bool {
	_, ok := m.clearedFields[cve.FieldModifiedData]
	return ok
}

// ResetModifiedData resets all changes to the "modified_data" field.
func (m *CVEMutation) ResetModifiedData() {
	m.modified_data = nil
	delete(m.clearedFields, cve.FieldModifiedData)
}

// AddFoundIDs adds the "found" edge to the Vulnerability entity by ids.
func (m *CVEMutation) AddFoundIDs(ids ...int) {
	if m.found == nil {
		m.found = make(map[int]struct{})
	}
	for i := range ids {
		m.found[ids[i]] = struct{}{}
	}
}

// ClearFound clears the "found" edge to the Vulnerability entity.
func (m *CVEMutation) ClearFound() {
	m.clearedfound = true
}

// FoundCleared reports if the "found" edge to the Vulnerability entity was cleared.
func (m *CVEMutation) FoundCleared() bool {
	return m.clearedfound
}

// RemoveFoundIDs removes the "found" edge to the Vulnerability entity by IDs.
func (m *CVEMutation) RemoveFoundIDs(ids ...int) {
	if m.removedfound == nil {
		m.removedfound = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.found, ids[i])
		m.removedfound[ids[i]] = struct{}{}
	}
}

// RemovedFound returns the removed IDs of the "found" edge to the Vulnerability entity.
func (m *CVEMutation) RemovedFoundIDs() (ids []int) {
	for id := range m.removedfound {
		ids = append(ids, id)
	}
	return
}

// FoundIDs returns the "found" edge IDs in the mutation.
func (m *CVEMutation) FoundIDs() (ids []int) {
	for id := range m.found {
		ids = append(ids, id)
	}
	return
}

// ResetFound resets all changes to the "found" edge.
func (m *CVEMutation) ResetFound() {
	m.found = nil
	m.clearedfound = false
	m.removedfound = nil
}

// AddRuleIDs adds the "rules" edge to the CVERule entity by ids.
func (m *CVEMutation) AddRuleIDs(ids ...int) {
	if m.rules == nil {
		m.rules = make(map[int]struct{})
	}
	for i := range ids {
		m.rules[ids[i]] = struct{}{}
	}
}

// ClearRules clears the "rules" edge to the CVERule entity.
func (m *CVEMutation) ClearRules() {
	m.clearedrules = true
}

// RulesCleared reports if the "rules" edge to the CVERule entity was cleared.
func (m *CVEMutation) RulesCleared() bool {
	return m.clearedrules
}

// RemoveRuleIDs removes the "rules" edge to the CVERule entity by IDs.
func (m *CVEMutation) RemoveRuleIDs(ids ...int) {
	if m.removedrules == nil {
		m.removedrules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rules, ids[i])
		m.removedrules[ids[i]] = struct{}{}
	}
}

// RemovedRules returns the removed IDs of the "rules" edge to the CVERule entity.
func (m *CVEMutation) RemovedRulesIDs() (ids []int) {
	for id := range m.removedrules {
		ids = append(ids, id)
	}
	return
}

// RulesIDs returns the "rules" edge IDs in the mutation.
func (m *CVEMutation) RulesIDs() (ids []int) {
	for id := range m.rules {
		ids = append(ids, id)
	}
	return
}

// ResetRules resets all changes to the "rules" edge.
func (m *CVEMutation) ResetRules() {
	m.rules = nil
	m.clearedrules = false
	m.removedrules = nil
}

// Op returns the operation name.
func (m *CVEMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CVE).
func (m *CVEMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CVEMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.cve_id != nil {
		fields = append(fields, cve.FieldCveID)
	}
	if m.description != nil {
		fields = append(fields, cve.FieldDescription)
	}
	if m.severity_score != nil {
		fields = append(fields, cve.FieldSeverityScore)
	}
	if m.severity != nil {
		fields = append(fields, cve.FieldSeverity)
	}
	if m.published_data != nil {
		fields = append(fields, cve.FieldPublishedData)
	}
	if m.modified_data != nil {
		fields = append(fields, cve.FieldModifiedData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CVEMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cve.FieldCveID:
		return m.CveID()
	case cve.FieldDescription:
		return m.Description()
	case cve.FieldSeverityScore:
		return m.SeverityScore()
	case cve.FieldSeverity:
		return m.Severity()
	case cve.FieldPublishedData:
		return m.PublishedData()
	case cve.FieldModifiedData:
		return m.ModifiedData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CVEMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cve.FieldCveID:
		return m.OldCveID(ctx)
	case cve.FieldDescription:
		return m.OldDescription(ctx)
	case cve.FieldSeverityScore:
		return m.OldSeverityScore(ctx)
	case cve.FieldSeverity:
		return m.OldSeverity(ctx)
	case cve.FieldPublishedData:
		return m.OldPublishedData(ctx)
	case cve.FieldModifiedData:
		return m.OldModifiedData(ctx)
	}
	return nil, fmt.Errorf("unknown CVE field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CVEMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cve.FieldCveID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCveID(v)
		return nil
	case cve.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cve.FieldSeverityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverityScore(v)
		return nil
	case cve.FieldSeverity:
		v, ok := value.(cve.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case cve.FieldPublishedData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedData(v)
		return nil
	case cve.FieldModifiedData:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedData(v)
		return nil
	}
	return fmt.Errorf("unknown CVE field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CVEMutation) AddedFields() []string {
	var fields []string
	if m.addseverity_score != nil {
		fields = append(fields, cve.FieldSeverityScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CVEMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cve.FieldSeverityScore:
		return m.AddedSeverityScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CVEMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cve.FieldSeverityScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeverityScore(v)
		return nil
	}
	return fmt.Errorf("unknown CVE numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CVEMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cve.FieldDescription) {
		fields = append(fields, cve.FieldDescription)
	}
	if m.FieldCleared(cve.FieldPublishedData) {
		fields = append(fields, cve.FieldPublishedData)
	}
	if m.FieldCleared(cve.FieldModifiedData) {
		fields = append(fields, cve.FieldModifiedData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CVEMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CVEMutation) ClearField(name string) error {
	switch name {
	case cve.FieldDescription:
		m.ClearDescription()
		return nil
	case cve.FieldPublishedData:
		m.ClearPublishedData()
		return nil
	case cve.FieldModifiedData:
		m.ClearModifiedData()
		return nil
	}
	return fmt.Errorf("unknown CVE nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CVEMutation) ResetField(name string) error {
	switch name {
	case cve.FieldCveID:
		m.ResetCveID()
		return nil
	case cve.FieldDescription:
		m.ResetDescription()
		return nil
	case cve.FieldSeverityScore:
		m.ResetSeverityScore()
		return nil
	case cve.FieldSeverity:
		m.ResetSeverity()
		return nil
	case cve.FieldPublishedData:
		m.ResetPublishedData()
		return nil
	case cve.FieldModifiedData:
		m.ResetModifiedData()
		return nil
	}
	return fmt.Errorf("unknown CVE field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CVEMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.found != nil {
		edges = append(edges, cve.EdgeFound)
	}
	if m.rules != nil {
		edges = append(edges, cve.EdgeRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CVEMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cve.EdgeFound:
		ids := make([]ent.Value, 0, len(m.found))
		for id := range m.found {
			ids = append(ids, id)
		}
		return ids
	case cve.EdgeRules:
		ids := make([]ent.Value, 0, len(m.rules))
		for id := range m.rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CVEMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfound != nil {
		edges = append(edges, cve.EdgeFound)
	}
	if m.removedrules != nil {
		edges = append(edges, cve.EdgeRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CVEMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cve.EdgeFound:
		ids := make([]ent.Value, 0, len(m.removedfound))
		for id := range m.removedfound {
			ids = append(ids, id)
		}
		return ids
	case cve.EdgeRules:
		ids := make([]ent.Value, 0, len(m.removedrules))
		for id := range m.removedrules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CVEMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfound {
		edges = append(edges, cve.EdgeFound)
	}
	if m.clearedrules {
		edges = append(edges, cve.EdgeRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CVEMutation) EdgeCleared(name string) bool {
	switch name {
	case cve.EdgeFound:
		return m.clearedfound
	case cve.EdgeRules:
		return m.clearedrules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CVEMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CVE unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CVEMutation) ResetEdge(name string) error {
	switch name {
	case cve.EdgeFound:
		m.ResetFound()
		return nil
	case cve.EdgeRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown CVE edge %s", name)
}

// CVERuleMutation represents an operation that mutates the CVERule nodes in the graph.
type CVERuleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	clearedFields  map[string]struct{}
	cve            *int
	clearedcve     bool
	project        map[int]struct{}
	removedproject map[int]struct{}
	clearedproject bool
	repo           map[int]struct{}
	removedrepo    map[int]struct{}
	clearedrepo    bool
	done           bool
	oldValue       func(context.Context) (*CVERule, error)
	predicates     []predicate.CVERule
}

var _ ent.Mutation = (*CVERuleMutation)(nil)

// cveruleOption allows management of the mutation configuration using functional options.
type cveruleOption func(*CVERuleMutation)

// newCVERuleMutation creates new mutation for the CVERule entity.
func newCVERuleMutation(c config, op Op, opts ...cveruleOption) *CVERuleMutation {
	m := &CVERuleMutation{
		config:        c,
		op:            op,
		typ:           TypeCVERule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCVERuleID sets the ID field of the mutation.
func withCVERuleID(id int) cveruleOption {
	return func(m *CVERuleMutation) {
		var (
			err   error
			once  sync.Once
			value *CVERule
		)
		m.oldValue = func(ctx context.Context) (*CVERule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CVERule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCVERule sets the old CVERule of the mutation.
func withCVERule(node *CVERule) cveruleOption {
	return func(m *CVERuleMutation) {
		m.oldValue = func(context.Context) (*CVERule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CVERuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CVERuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CVERuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *CVERuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CVERuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CVERule entity.
// If the CVERule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVERuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CVERuleMutation) ClearName() {
	m.name = nil
	m.clearedFields[cverule.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CVERuleMutation) NameCleared() bool {
	_, ok := m.clearedFields[cverule.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CVERuleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cverule.FieldName)
}

// SetCveID sets the "cve" edge to the CVE entity by id.
func (m *CVERuleMutation) SetCveID(id int) {
	m.cve = &id
}

// ClearCve clears the "cve" edge to the CVE entity.
func (m *CVERuleMutation) ClearCve() {
	m.clearedcve = true
}

// CveCleared reports if the "cve" edge to the CVE entity was cleared.
func (m *CVERuleMutation) CveCleared() bool {
	return m.clearedcve
}

// CveID returns the "cve" edge ID in the mutation.
func (m *CVERuleMutation) CveID() (id int, exists bool) {
	if m.cve != nil {
		return *m.cve, true
	}
	return
}

// CveIDs returns the "cve" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CveID instead. It exists only for internal usage by the builders.
func (m *CVERuleMutation) CveIDs() (ids []int) {
	if id := m.cve; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCve resets all changes to the "cve" edge.
func (m *CVERuleMutation) ResetCve() {
	m.cve = nil
	m.clearedcve = false
}

// AddProjectIDs adds the "project" edge to the Project entity by ids.
func (m *CVERuleMutation) AddProjectIDs(ids ...int) {
	if m.project == nil {
		m.project = make(map[int]struct{})
	}
	for i := range ids {
		m.project[ids[i]] = struct{}{}
	}
}

// ClearProject clears the "project" edge to the Project entity.
func (m *CVERuleMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *CVERuleMutation) ProjectCleared() bool {
	return m.clearedproject
}

// RemoveProjectIDs removes the "project" edge to the Project entity by IDs.
func (m *CVERuleMutation) RemoveProjectIDs(ids ...int) {
	if m.removedproject == nil {
		m.removedproject = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project, ids[i])
		m.removedproject[ids[i]] = struct{}{}
	}
}

// RemovedProject returns the removed IDs of the "project" edge to the Project entity.
func (m *CVERuleMutation) RemovedProjectIDs() (ids []int) {
	for id := range m.removedproject {
		ids = append(ids, id)
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
func (m *CVERuleMutation) ProjectIDs() (ids []int) {
	for id := range m.project {
		ids = append(ids, id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *CVERuleMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
	m.removedproject = nil
}

// AddRepoIDs adds the "repo" edge to the Repo entity by ids.
func (m *CVERuleMutation) AddRepoIDs(ids ...int) {
	if m.repo == nil {
		m.repo = make(map[int]struct{})
	}
	for i := range ids {
		m.repo[ids[i]] = struct{}{}
	}
}

// ClearRepo clears the "repo" edge to the Repo entity.
func (m *CVERuleMutation) ClearRepo() {
	m.clearedrepo = true
}

// RepoCleared reports if the "repo" edge to the Repo entity was cleared.
func (m *CVERuleMutation) RepoCleared() bool {
	return m.clearedrepo
}

// RemoveRepoIDs removes the "repo" edge to the Repo entity by IDs.
func (m *CVERuleMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepo == nil {
		m.removedrepo = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repo, ids[i])
		m.removedrepo[ids[i]] = struct{}{}
	}
}

// RemovedRepo returns the removed IDs of the "repo" edge to the Repo entity.
func (m *CVERuleMutation) RemovedRepoIDs() (ids []int) {
	for id := range m.removedrepo {
		ids = append(ids, id)
	}
	return
}

// RepoIDs returns the "repo" edge IDs in the mutation.
func (m *CVERuleMutation) RepoIDs() (ids []int) {
	for id := range m.repo {
		ids = append(ids, id)
	}
	return
}

// ResetRepo resets all changes to the "repo" edge.
func (m *CVERuleMutation) ResetRepo() {
	m.repo = nil
	m.clearedrepo = false
	m.removedrepo = nil
}

// Op returns the operation name.
func (m *CVERuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CVERule).
func (m *CVERuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CVERuleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cverule.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CVERuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cverule.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CVERuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cverule.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CVERule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CVERuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cverule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CVERule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CVERuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CVERuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CVERuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CVERule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CVERuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cverule.FieldName) {
		fields = append(fields, cverule.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CVERuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CVERuleMutation) ClearField(name string) error {
	switch name {
	case cverule.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown CVERule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CVERuleMutation) ResetField(name string) error {
	switch name {
	case cverule.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CVERule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CVERuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cve != nil {
		edges = append(edges, cverule.EdgeCve)
	}
	if m.project != nil {
		edges = append(edges, cverule.EdgeProject)
	}
	if m.repo != nil {
		edges = append(edges, cverule.EdgeRepo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CVERuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cverule.EdgeCve:
		if id := m.cve; id != nil {
			return []ent.Value{*id}
		}
	case cverule.EdgeProject:
		ids := make([]ent.Value, 0, len(m.project))
		for id := range m.project {
			ids = append(ids, id)
		}
		return ids
	case cverule.EdgeRepo:
		ids := make([]ent.Value, 0, len(m.repo))
		for id := range m.repo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CVERuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproject != nil {
		edges = append(edges, cverule.EdgeProject)
	}
	if m.removedrepo != nil {
		edges = append(edges, cverule.EdgeRepo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CVERuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cverule.EdgeProject:
		ids := make([]ent.Value, 0, len(m.removedproject))
		for id := range m.removedproject {
			ids = append(ids, id)
		}
		return ids
	case cverule.EdgeRepo:
		ids := make([]ent.Value, 0, len(m.removedrepo))
		for id := range m.removedrepo {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CVERuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcve {
		edges = append(edges, cverule.EdgeCve)
	}
	if m.clearedproject {
		edges = append(edges, cverule.EdgeProject)
	}
	if m.clearedrepo {
		edges = append(edges, cverule.EdgeRepo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CVERuleMutation) EdgeCleared(name string) bool {
	switch name {
	case cverule.EdgeCve:
		return m.clearedcve
	case cverule.EdgeProject:
		return m.clearedproject
	case cverule.EdgeRepo:
		return m.clearedrepo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CVERuleMutation) ClearEdge(name string) error {
	switch name {
	case cverule.EdgeCve:
		m.ClearCve()
		return nil
	}
	return fmt.Errorf("unknown CVERule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CVERuleMutation) ResetEdge(name string) error {
	switch name {
	case cverule.EdgeCve:
		m.ResetCve()
		return nil
	case cverule.EdgeProject:
		m.ResetProject()
		return nil
	case cverule.EdgeRepo:
		m.ResetRepo()
		return nil
	}
	return fmt.Errorf("unknown CVERule edge %s", name)
}

// CVEScanMutation represents an operation that mutates the CVEScan nodes in the graph.
type CVEScanMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	tool                   *string
	clearedFields          map[string]struct{}
	release                *int
	clearedrelease         bool
	entry                  *int
	clearedentry           bool
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	done                   bool
	oldValue               func(context.Context) (*CVEScan, error)
	predicates             []predicate.CVEScan
}

var _ ent.Mutation = (*CVEScanMutation)(nil)

// cvescanOption allows management of the mutation configuration using functional options.
type cvescanOption func(*CVEScanMutation)

// newCVEScanMutation creates new mutation for the CVEScan entity.
func newCVEScanMutation(c config, op Op, opts ...cvescanOption) *CVEScanMutation {
	m := &CVEScanMutation{
		config:        c,
		op:            op,
		typ:           TypeCVEScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCVEScanID sets the ID field of the mutation.
func withCVEScanID(id int) cvescanOption {
	return func(m *CVEScanMutation) {
		var (
			err   error
			once  sync.Once
			value *CVEScan
		)
		m.oldValue = func(ctx context.Context) (*CVEScan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CVEScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCVEScan sets the old CVEScan of the mutation.
func withCVEScan(node *CVEScan) cvescanOption {
	return func(m *CVEScanMutation) {
		m.oldValue = func(context.Context) (*CVEScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CVEScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CVEScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CVEScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *CVEScanMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *CVEScanMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the CVEScan entity.
// If the CVEScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CVEScanMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *CVEScanMutation) ResetTool() {
	m.tool = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *CVEScanMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *CVEScanMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *CVEScanMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *CVEScanMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *CVEScanMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *CVEScanMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *CVEScanMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *CVEScanMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *CVEScanMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *CVEScanMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *CVEScanMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *CVEScanMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the Vulnerability entity by ids.
func (m *CVEScanMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the Vulnerability entity.
func (m *CVEScanMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the Vulnerability entity was cleared.
func (m *CVEScanMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the Vulnerability entity by IDs.
func (m *CVEScanMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the Vulnerability entity.
func (m *CVEScanMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *CVEScanMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *CVEScanMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// Op returns the operation name.
func (m *CVEScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CVEScan).
func (m *CVEScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CVEScanMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tool != nil {
		fields = append(fields, cvescan.FieldTool)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CVEScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cvescan.FieldTool:
		return m.Tool()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CVEScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cvescan.FieldTool:
		return m.OldTool(ctx)
	}
	return nil, fmt.Errorf("unknown CVEScan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CVEScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cvescan.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	}
	return fmt.Errorf("unknown CVEScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CVEScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CVEScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CVEScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CVEScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CVEScanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CVEScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CVEScanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CVEScan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CVEScanMutation) ResetField(name string) error {
	switch name {
	case cvescan.FieldTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown CVEScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CVEScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.release != nil {
		edges = append(edges, cvescan.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, cvescan.EdgeEntry)
	}
	if m.vulnerabilities != nil {
		edges = append(edges, cvescan.EdgeVulnerabilities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CVEScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cvescan.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case cvescan.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case cvescan.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CVEScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvulnerabilities != nil {
		edges = append(edges, cvescan.EdgeVulnerabilities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CVEScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cvescan.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CVEScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelease {
		edges = append(edges, cvescan.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, cvescan.EdgeEntry)
	}
	if m.clearedvulnerabilities {
		edges = append(edges, cvescan.EdgeVulnerabilities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CVEScanMutation) EdgeCleared(name string) bool {
	switch name {
	case cvescan.EdgeRelease:
		return m.clearedrelease
	case cvescan.EdgeEntry:
		return m.clearedentry
	case cvescan.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CVEScanMutation) ClearEdge(name string) error {
	switch name {
	case cvescan.EdgeRelease:
		m.ClearRelease()
		return nil
	case cvescan.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown CVEScan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CVEScanMutation) ResetEdge(name string) error {
	switch name {
	case cvescan.EdgeRelease:
		m.ResetRelease()
		return nil
	case cvescan.EdgeEntry:
		m.ResetEntry()
		return nil
	case cvescan.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	}
	return fmt.Errorf("unknown CVEScan edge %s", name)
}

// CWEMutation represents an operation that mutates the CWE nodes in the graph.
type CWEMutation struct {
	config
	op            Op
	typ           string
	id            *int
	cwe_id        *string
	description   *string
	url           *float64
	addurl        *float64
	clearedFields map[string]struct{}
	issues        map[int]struct{}
	removedissues map[int]struct{}
	clearedissues bool
	done          bool
	oldValue      func(context.Context) (*CWE, error)
	predicates    []predicate.CWE
}

var _ ent.Mutation = (*CWEMutation)(nil)

// cweOption allows management of the mutation configuration using functional options.
type cweOption func(*CWEMutation)

// newCWEMutation creates new mutation for the CWE entity.
func newCWEMutation(c config, op Op, opts ...cweOption) *CWEMutation {
	m := &CWEMutation{
		config:        c,
		op:            op,
		typ:           TypeCWE,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCWEID sets the ID field of the mutation.
func withCWEID(id int) cweOption {
	return func(m *CWEMutation) {
		var (
			err   error
			once  sync.Once
			value *CWE
		)
		m.oldValue = func(ctx context.Context) (*CWE, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CWE.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCWE sets the old CWE of the mutation.
func withCWE(node *CWE) cweOption {
	return func(m *CWEMutation) {
		m.oldValue = func(context.Context) (*CWE, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CWEMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CWEMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CWEMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCweID sets the "cwe_id" field.
func (m *CWEMutation) SetCweID(s string) {
	m.cwe_id = &s
}

// CweID returns the value of the "cwe_id" field in the mutation.
func (m *CWEMutation) CweID() (r string, exists bool) {
	v := m.cwe_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCweID returns the old "cwe_id" field's value of the CWE entity.
// If the CWE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CWEMutation) OldCweID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCweID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCweID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCweID: %w", err)
	}
	return oldValue.CweID, nil
}

// ResetCweID resets all changes to the "cwe_id" field.
func (m *CWEMutation) ResetCweID() {
	m.cwe_id = nil
}

// SetDescription sets the "description" field.
func (m *CWEMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CWEMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CWE entity.
// If the CWE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CWEMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CWEMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cwe.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CWEMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cwe.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CWEMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cwe.FieldDescription)
}

// SetURL sets the "url" field.
func (m *CWEMutation) SetURL(f float64) {
	m.url = &f
	m.addurl = nil
}

// URL returns the value of the "url" field in the mutation.
func (m *CWEMutation) URL() (r float64, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the CWE entity.
// If the CWE object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CWEMutation) OldURL(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// AddURL adds f to the "url" field.
func (m *CWEMutation) AddURL(f float64) {
	if m.addurl != nil {
		*m.addurl += f
	} else {
		m.addurl = &f
	}
}

// AddedURL returns the value that was added to the "url" field in this mutation.
func (m *CWEMutation) AddedURL() (r float64, exists bool) {
	v := m.addurl
	if v == nil {
		return
	}
	return *v, true
}

// ClearURL clears the value of the "url" field.
func (m *CWEMutation) ClearURL() {
	m.url = nil
	m.addurl = nil
	m.clearedFields[cwe.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *CWEMutation) URLCleared() bool {
	_, ok := m.clearedFields[cwe.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *CWEMutation) ResetURL() {
	m.url = nil
	m.addurl = nil
	delete(m.clearedFields, cwe.FieldURL)
}

// AddIssueIDs adds the "issues" edge to the CodeIssue entity by ids.
func (m *CWEMutation) AddIssueIDs(ids ...int) {
	if m.issues == nil {
		m.issues = make(map[int]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the CodeIssue entity.
func (m *CWEMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the CodeIssue entity was cleared.
func (m *CWEMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the CodeIssue entity by IDs.
func (m *CWEMutation) RemoveIssueIDs(ids ...int) {
	if m.removedissues == nil {
		m.removedissues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the CodeIssue entity.
func (m *CWEMutation) RemovedIssuesIDs() (ids []int) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *CWEMutation) IssuesIDs() (ids []int) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *CWEMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// Op returns the operation name.
func (m *CWEMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CWE).
func (m *CWEMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CWEMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.cwe_id != nil {
		fields = append(fields, cwe.FieldCweID)
	}
	if m.description != nil {
		fields = append(fields, cwe.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, cwe.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CWEMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cwe.FieldCweID:
		return m.CweID()
	case cwe.FieldDescription:
		return m.Description()
	case cwe.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CWEMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cwe.FieldCweID:
		return m.OldCweID(ctx)
	case cwe.FieldDescription:
		return m.OldDescription(ctx)
	case cwe.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown CWE field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CWEMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cwe.FieldCweID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCweID(v)
		return nil
	case cwe.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cwe.FieldURL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown CWE field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CWEMutation) AddedFields() []string {
	var fields []string
	if m.addurl != nil {
		fields = append(fields, cwe.FieldURL)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CWEMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cwe.FieldURL:
		return m.AddedURL()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CWEMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cwe.FieldURL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddURL(v)
		return nil
	}
	return fmt.Errorf("unknown CWE numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CWEMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cwe.FieldDescription) {
		fields = append(fields, cwe.FieldDescription)
	}
	if m.FieldCleared(cwe.FieldURL) {
		fields = append(fields, cwe.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CWEMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CWEMutation) ClearField(name string) error {
	switch name {
	case cwe.FieldDescription:
		m.ClearDescription()
		return nil
	case cwe.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown CWE nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CWEMutation) ResetField(name string) error {
	switch name {
	case cwe.FieldCweID:
		m.ResetCweID()
		return nil
	case cwe.FieldDescription:
		m.ResetDescription()
		return nil
	case cwe.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown CWE field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CWEMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.issues != nil {
		edges = append(edges, cwe.EdgeIssues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CWEMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cwe.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CWEMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedissues != nil {
		edges = append(edges, cwe.EdgeIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CWEMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cwe.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CWEMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedissues {
		edges = append(edges, cwe.EdgeIssues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CWEMutation) EdgeCleared(name string) bool {
	switch name {
	case cwe.EdgeIssues:
		return m.clearedissues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CWEMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CWE unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CWEMutation) ResetEdge(name string) error {
	switch name {
	case cwe.EdgeIssues:
		m.ResetIssues()
		return nil
	}
	return fmt.Errorf("unknown CWE edge %s", name)
}

// CodeIssueMutation represents an operation that mutates the CodeIssue nodes in the graph.
type CodeIssueMutation struct {
	config
	op            Op
	typ           string
	id            *int
	rule_id       *string
	message       *string
	severity      *codeissue.Severity
	_type         *codeissue.Type
	clearedFields map[string]struct{}
	cwe           map[int]struct{}
	removedcwe    map[int]struct{}
	clearedcwe    bool
	scan          *int
	clearedscan   bool
	done          bool
	oldValue      func(context.Context) (*CodeIssue, error)
	predicates    []predicate.CodeIssue
}

var _ ent.Mutation = (*CodeIssueMutation)(nil)

// codeissueOption allows management of the mutation configuration using functional options.
type codeissueOption func(*CodeIssueMutation)

// newCodeIssueMutation creates new mutation for the CodeIssue entity.
func newCodeIssueMutation(c config, op Op, opts ...codeissueOption) *CodeIssueMutation {
	m := &CodeIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeIssueID sets the ID field of the mutation.
func withCodeIssueID(id int) codeissueOption {
	return func(m *CodeIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeIssue
		)
		m.oldValue = func(ctx context.Context) (*CodeIssue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeIssue sets the old CodeIssue of the mutation.
func withCodeIssue(node *CodeIssue) codeissueOption {
	return func(m *CodeIssueMutation) {
		m.oldValue = func(context.Context) (*CodeIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeIssueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRuleID sets the "rule_id" field.
func (m *CodeIssueMutation) SetRuleID(s string) {
	m.rule_id = &s
}

// RuleID returns the value of the "rule_id" field in the mutation.
func (m *CodeIssueMutation) RuleID() (r string, exists bool) {
	v := m.rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuleID returns the old "rule_id" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldRuleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuleID: %w", err)
	}
	return oldValue.RuleID, nil
}

// ResetRuleID resets all changes to the "rule_id" field.
func (m *CodeIssueMutation) ResetRuleID() {
	m.rule_id = nil
}

// SetMessage sets the "message" field.
func (m *CodeIssueMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CodeIssueMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CodeIssueMutation) ResetMessage() {
	m.message = nil
}

// SetSeverity sets the "severity" field.
func (m *CodeIssueMutation) SetSeverity(c codeissue.Severity) {
	m.severity = &c
}

// Severity returns the value of the "severity" field in the mutation.
func (m *CodeIssueMutation) Severity() (r codeissue.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldSeverity(ctx context.Context) (v codeissue.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *CodeIssueMutation) ResetSeverity() {
	m.severity = nil
}

// SetType sets the "type" field.
func (m *CodeIssueMutation) SetType(c codeissue.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CodeIssueMutation) GetType() (r codeissue.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CodeIssue entity.
// If the CodeIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeIssueMutation) OldType(ctx context.Context) (v codeissue.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CodeIssueMutation) ResetType() {
	m._type = nil
}

// AddCweIDs adds the "cwe" edge to the CWE entity by ids.
func (m *CodeIssueMutation) AddCweIDs(ids ...int) {
	if m.cwe == nil {
		m.cwe = make(map[int]struct{})
	}
	for i := range ids {
		m.cwe[ids[i]] = struct{}{}
	}
}

// ClearCwe clears the "cwe" edge to the CWE entity.
func (m *CodeIssueMutation) ClearCwe() {
	m.clearedcwe = true
}

// CweCleared reports if the "cwe" edge to the CWE entity was cleared.
func (m *CodeIssueMutation) CweCleared() bool {
	return m.clearedcwe
}

// RemoveCweIDs removes the "cwe" edge to the CWE entity by IDs.
func (m *CodeIssueMutation) RemoveCweIDs(ids ...int) {
	if m.removedcwe == nil {
		m.removedcwe = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cwe, ids[i])
		m.removedcwe[ids[i]] = struct{}{}
	}
}

// RemovedCwe returns the removed IDs of the "cwe" edge to the CWE entity.
func (m *CodeIssueMutation) RemovedCweIDs() (ids []int) {
	for id := range m.removedcwe {
		ids = append(ids, id)
	}
	return
}

// CweIDs returns the "cwe" edge IDs in the mutation.
func (m *CodeIssueMutation) CweIDs() (ids []int) {
	for id := range m.cwe {
		ids = append(ids, id)
	}
	return
}

// ResetCwe resets all changes to the "cwe" edge.
func (m *CodeIssueMutation) ResetCwe() {
	m.cwe = nil
	m.clearedcwe = false
	m.removedcwe = nil
}

// SetScanID sets the "scan" edge to the CodeScan entity by id.
func (m *CodeIssueMutation) SetScanID(id int) {
	m.scan = &id
}

// ClearScan clears the "scan" edge to the CodeScan entity.
func (m *CodeIssueMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the CodeScan entity was cleared.
func (m *CodeIssueMutation) ScanCleared() bool {
	return m.clearedscan
}

// ScanID returns the "scan" edge ID in the mutation.
func (m *CodeIssueMutation) ScanID() (id int, exists bool) {
	if m.scan != nil {
		return *m.scan, true
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScanID instead. It exists only for internal usage by the builders.
func (m *CodeIssueMutation) ScanIDs() (ids []int) {
	if id := m.scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *CodeIssueMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
}

// Op returns the operation name.
func (m *CodeIssueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodeIssue).
func (m *CodeIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeIssueMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.rule_id != nil {
		fields = append(fields, codeissue.FieldRuleID)
	}
	if m.message != nil {
		fields = append(fields, codeissue.FieldMessage)
	}
	if m.severity != nil {
		fields = append(fields, codeissue.FieldSeverity)
	}
	if m._type != nil {
		fields = append(fields, codeissue.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codeissue.FieldRuleID:
		return m.RuleID()
	case codeissue.FieldMessage:
		return m.Message()
	case codeissue.FieldSeverity:
		return m.Severity()
	case codeissue.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codeissue.FieldRuleID:
		return m.OldRuleID(ctx)
	case codeissue.FieldMessage:
		return m.OldMessage(ctx)
	case codeissue.FieldSeverity:
		return m.OldSeverity(ctx)
	case codeissue.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown CodeIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codeissue.FieldRuleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuleID(v)
		return nil
	case codeissue.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case codeissue.FieldSeverity:
		v, ok := value.(codeissue.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case codeissue.FieldType:
		v, ok := value.(codeissue.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown CodeIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeIssueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeIssueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodeIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeIssueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeIssueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodeIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeIssueMutation) ResetField(name string) error {
	switch name {
	case codeissue.FieldRuleID:
		m.ResetRuleID()
		return nil
	case codeissue.FieldMessage:
		m.ResetMessage()
		return nil
	case codeissue.FieldSeverity:
		m.ResetSeverity()
		return nil
	case codeissue.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cwe != nil {
		edges = append(edges, codeissue.EdgeCwe)
	}
	if m.scan != nil {
		edges = append(edges, codeissue.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeIssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codeissue.EdgeCwe:
		ids := make([]ent.Value, 0, len(m.cwe))
		for id := range m.cwe {
			ids = append(ids, id)
		}
		return ids
	case codeissue.EdgeScan:
		if id := m.scan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcwe != nil {
		edges = append(edges, codeissue.EdgeCwe)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeIssueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case codeissue.EdgeCwe:
		ids := make([]ent.Value, 0, len(m.removedcwe))
		for id := range m.removedcwe {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcwe {
		edges = append(edges, codeissue.EdgeCwe)
	}
	if m.clearedscan {
		edges = append(edges, codeissue.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeIssueMutation) EdgeCleared(name string) bool {
	switch name {
	case codeissue.EdgeCwe:
		return m.clearedcwe
	case codeissue.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeIssueMutation) ClearEdge(name string) error {
	switch name {
	case codeissue.EdgeScan:
		m.ClearScan()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeIssueMutation) ResetEdge(name string) error {
	switch name {
	case codeissue.EdgeCwe:
		m.ResetCwe()
		return nil
	case codeissue.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown CodeIssue edge %s", name)
}

// CodeScanMutation represents an operation that mutates the CodeScan nodes in the graph.
type CodeScanMutation struct {
	config
	op             Op
	typ            string
	id             *int
	tool           *string
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	issues         map[int]struct{}
	removedissues  map[int]struct{}
	clearedissues  bool
	entry          *int
	clearedentry   bool
	done           bool
	oldValue       func(context.Context) (*CodeScan, error)
	predicates     []predicate.CodeScan
}

var _ ent.Mutation = (*CodeScanMutation)(nil)

// codescanOption allows management of the mutation configuration using functional options.
type codescanOption func(*CodeScanMutation)

// newCodeScanMutation creates new mutation for the CodeScan entity.
func newCodeScanMutation(c config, op Op, opts ...codescanOption) *CodeScanMutation {
	m := &CodeScanMutation{
		config:        c,
		op:            op,
		typ:           TypeCodeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCodeScanID sets the ID field of the mutation.
func withCodeScanID(id int) codescanOption {
	return func(m *CodeScanMutation) {
		var (
			err   error
			once  sync.Once
			value *CodeScan
		)
		m.oldValue = func(ctx context.Context) (*CodeScan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CodeScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCodeScan sets the old CodeScan of the mutation.
func withCodeScan(node *CodeScan) codescanOption {
	return func(m *CodeScanMutation) {
		m.oldValue = func(context.Context) (*CodeScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CodeScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CodeScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CodeScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *CodeScanMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *CodeScanMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the CodeScan entity.
// If the CodeScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CodeScanMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *CodeScanMutation) ResetTool() {
	m.tool = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *CodeScanMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *CodeScanMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *CodeScanMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *CodeScanMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *CodeScanMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *CodeScanMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddIssueIDs adds the "issues" edge to the CodeIssue entity by ids.
func (m *CodeScanMutation) AddIssueIDs(ids ...int) {
	if m.issues == nil {
		m.issues = make(map[int]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the CodeIssue entity.
func (m *CodeScanMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the CodeIssue entity was cleared.
func (m *CodeScanMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the CodeIssue entity by IDs.
func (m *CodeScanMutation) RemoveIssueIDs(ids ...int) {
	if m.removedissues == nil {
		m.removedissues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the CodeIssue entity.
func (m *CodeScanMutation) RemovedIssuesIDs() (ids []int) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *CodeScanMutation) IssuesIDs() (ids []int) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *CodeScanMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *CodeScanMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *CodeScanMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *CodeScanMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *CodeScanMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *CodeScanMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *CodeScanMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// Op returns the operation name.
func (m *CodeScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CodeScan).
func (m *CodeScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CodeScanMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tool != nil {
		fields = append(fields, codescan.FieldTool)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CodeScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case codescan.FieldTool:
		return m.Tool()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CodeScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case codescan.FieldTool:
		return m.OldTool(ctx)
	}
	return nil, fmt.Errorf("unknown CodeScan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case codescan.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	}
	return fmt.Errorf("unknown CodeScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CodeScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CodeScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CodeScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CodeScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CodeScanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CodeScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CodeScanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CodeScan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CodeScanMutation) ResetField(name string) error {
	switch name {
	case codescan.FieldTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown CodeScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CodeScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.release != nil {
		edges = append(edges, codescan.EdgeRelease)
	}
	if m.issues != nil {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.entry != nil {
		edges = append(edges, codescan.EdgeEntry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CodeScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case codescan.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case codescan.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	case codescan.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CodeScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedissues != nil {
		edges = append(edges, codescan.EdgeIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CodeScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case codescan.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CodeScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelease {
		edges = append(edges, codescan.EdgeRelease)
	}
	if m.clearedissues {
		edges = append(edges, codescan.EdgeIssues)
	}
	if m.clearedentry {
		edges = append(edges, codescan.EdgeEntry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CodeScanMutation) EdgeCleared(name string) bool {
	switch name {
	case codescan.EdgeRelease:
		return m.clearedrelease
	case codescan.EdgeIssues:
		return m.clearedissues
	case codescan.EdgeEntry:
		return m.clearedentry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CodeScanMutation) ClearEdge(name string) error {
	switch name {
	case codescan.EdgeRelease:
		m.ClearRelease()
		return nil
	case codescan.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown CodeScan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CodeScanMutation) ResetEdge(name string) error {
	switch name {
	case codescan.EdgeRelease:
		m.ResetRelease()
		return nil
	case codescan.EdgeIssues:
		m.ResetIssues()
		return nil
	case codescan.EdgeEntry:
		m.ResetEntry()
		return nil
	}
	return fmt.Errorf("unknown CodeScan edge %s", name)
}

// ComponentMutation represents an operation that mutates the Component nodes in the graph.
type ComponentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	vendor                 *string
	version                *string
	description            *string
	url                    *string
	clearedFields          map[string]struct{}
	vulnerabilities        map[int]struct{}
	removedvulnerabilities map[int]struct{}
	clearedvulnerabilities bool
	licenses               map[int]struct{}
	removedlicenses        map[int]struct{}
	clearedlicenses        bool
	release                map[int]struct{}
	removedrelease         map[int]struct{}
	clearedrelease         bool
	done                   bool
	oldValue               func(context.Context) (*Component, error)
	predicates             []predicate.Component
}

var _ ent.Mutation = (*ComponentMutation)(nil)

// componentOption allows management of the mutation configuration using functional options.
type componentOption func(*ComponentMutation)

// newComponentMutation creates new mutation for the Component entity.
func newComponentMutation(c config, op Op, opts ...componentOption) *ComponentMutation {
	m := &ComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComponentID sets the ID field of the mutation.
func withComponentID(id int) componentOption {
	return func(m *ComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *Component
		)
		m.oldValue = func(ctx context.Context) (*Component, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Component.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComponent sets the old Component of the mutation.
func withComponent(node *Component) componentOption {
	return func(m *ComponentMutation) {
		m.oldValue = func(context.Context) (*Component, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComponentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ComponentMutation) ResetName() {
	m.name = nil
}

// SetVendor sets the "vendor" field.
func (m *ComponentMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ComponentMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ComponentMutation) ResetVendor() {
	m.vendor = nil
}

// SetVersion sets the "version" field.
func (m *ComponentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ComponentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ComponentMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *ComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ComponentMutation) ResetDescription() {
	m.description = nil
}

// SetURL sets the "url" field.
func (m *ComponentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ComponentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ComponentMutation) ResetURL() {
	m.url = nil
}

// AddVulnerabilityIDs adds the "vulnerabilities" edge to the Vulnerability entity by ids.
func (m *ComponentMutation) AddVulnerabilityIDs(ids ...int) {
	if m.vulnerabilities == nil {
		m.vulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		m.vulnerabilities[ids[i]] = struct{}{}
	}
}

// ClearVulnerabilities clears the "vulnerabilities" edge to the Vulnerability entity.
func (m *ComponentMutation) ClearVulnerabilities() {
	m.clearedvulnerabilities = true
}

// VulnerabilitiesCleared reports if the "vulnerabilities" edge to the Vulnerability entity was cleared.
func (m *ComponentMutation) VulnerabilitiesCleared() bool {
	return m.clearedvulnerabilities
}

// RemoveVulnerabilityIDs removes the "vulnerabilities" edge to the Vulnerability entity by IDs.
func (m *ComponentMutation) RemoveVulnerabilityIDs(ids ...int) {
	if m.removedvulnerabilities == nil {
		m.removedvulnerabilities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.vulnerabilities, ids[i])
		m.removedvulnerabilities[ids[i]] = struct{}{}
	}
}

// RemovedVulnerabilities returns the removed IDs of the "vulnerabilities" edge to the Vulnerability entity.
func (m *ComponentMutation) RemovedVulnerabilitiesIDs() (ids []int) {
	for id := range m.removedvulnerabilities {
		ids = append(ids, id)
	}
	return
}

// VulnerabilitiesIDs returns the "vulnerabilities" edge IDs in the mutation.
func (m *ComponentMutation) VulnerabilitiesIDs() (ids []int) {
	for id := range m.vulnerabilities {
		ids = append(ids, id)
	}
	return
}

// ResetVulnerabilities resets all changes to the "vulnerabilities" edge.
func (m *ComponentMutation) ResetVulnerabilities() {
	m.vulnerabilities = nil
	m.clearedvulnerabilities = false
	m.removedvulnerabilities = nil
}

// AddLicenseIDs adds the "licenses" edge to the License entity by ids.
func (m *ComponentMutation) AddLicenseIDs(ids ...int) {
	if m.licenses == nil {
		m.licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.licenses[ids[i]] = struct{}{}
	}
}

// ClearLicenses clears the "licenses" edge to the License entity.
func (m *ComponentMutation) ClearLicenses() {
	m.clearedlicenses = true
}

// LicensesCleared reports if the "licenses" edge to the License entity was cleared.
func (m *ComponentMutation) LicensesCleared() bool {
	return m.clearedlicenses
}

// RemoveLicenseIDs removes the "licenses" edge to the License entity by IDs.
func (m *ComponentMutation) RemoveLicenseIDs(ids ...int) {
	if m.removedlicenses == nil {
		m.removedlicenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.licenses, ids[i])
		m.removedlicenses[ids[i]] = struct{}{}
	}
}

// RemovedLicenses returns the removed IDs of the "licenses" edge to the License entity.
func (m *ComponentMutation) RemovedLicensesIDs() (ids []int) {
	for id := range m.removedlicenses {
		ids = append(ids, id)
	}
	return
}

// LicensesIDs returns the "licenses" edge IDs in the mutation.
func (m *ComponentMutation) LicensesIDs() (ids []int) {
	for id := range m.licenses {
		ids = append(ids, id)
	}
	return
}

// ResetLicenses resets all changes to the "licenses" edge.
func (m *ComponentMutation) ResetLicenses() {
	m.licenses = nil
	m.clearedlicenses = false
	m.removedlicenses = nil
}

// AddReleaseIDs adds the "release" edge to the Release entity by ids.
func (m *ComponentMutation) AddReleaseIDs(ids ...int) {
	if m.release == nil {
		m.release = make(map[int]struct{})
	}
	for i := range ids {
		m.release[ids[i]] = struct{}{}
	}
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ComponentMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ComponentMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// RemoveReleaseIDs removes the "release" edge to the Release entity by IDs.
func (m *ComponentMutation) RemoveReleaseIDs(ids ...int) {
	if m.removedrelease == nil {
		m.removedrelease = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.release, ids[i])
		m.removedrelease[ids[i]] = struct{}{}
	}
}

// RemovedRelease returns the removed IDs of the "release" edge to the Release entity.
func (m *ComponentMutation) RemovedReleaseIDs() (ids []int) {
	for id := range m.removedrelease {
		ids = append(ids, id)
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
func (m *ComponentMutation) ReleaseIDs() (ids []int) {
	for id := range m.release {
		ids = append(ids, id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ComponentMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
	m.removedrelease = nil
}

// Op returns the operation name.
func (m *ComponentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Component).
func (m *ComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComponentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, component.FieldName)
	}
	if m.vendor != nil {
		fields = append(fields, component.FieldVendor)
	}
	if m.version != nil {
		fields = append(fields, component.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, component.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, component.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case component.FieldName:
		return m.Name()
	case component.FieldVendor:
		return m.Vendor()
	case component.FieldVersion:
		return m.Version()
	case component.FieldDescription:
		return m.Description()
	case component.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case component.FieldName:
		return m.OldName(ctx)
	case component.FieldVendor:
		return m.OldVendor(ctx)
	case component.FieldVersion:
		return m.OldVersion(ctx)
	case component.FieldDescription:
		return m.OldDescription(ctx)
	case component.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Component field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case component.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case component.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case component.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case component.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case component.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Component numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComponentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComponentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Component nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComponentMutation) ResetField(name string) error {
	switch name {
	case component.FieldName:
		m.ResetName()
		return nil
	case component.FieldVendor:
		m.ResetVendor()
		return nil
	case component.FieldVersion:
		m.ResetVersion()
		return nil
	case component.FieldDescription:
		m.ResetDescription()
		return nil
	case component.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.vulnerabilities != nil {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.licenses != nil {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.release != nil {
		edges = append(edges, component.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.vulnerabilities))
		for id := range m.vulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.licenses))
		for id := range m.licenses {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeRelease:
		ids := make([]ent.Value, 0, len(m.release))
		for id := range m.release {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvulnerabilities != nil {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.removedlicenses != nil {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.removedrelease != nil {
		edges = append(edges, component.EdgeRelease)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeVulnerabilities:
		ids := make([]ent.Value, 0, len(m.removedvulnerabilities))
		for id := range m.removedvulnerabilities {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.removedlicenses))
		for id := range m.removedlicenses {
			ids = append(ids, id)
		}
		return ids
	case component.EdgeRelease:
		ids := make([]ent.Value, 0, len(m.removedrelease))
		for id := range m.removedrelease {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedvulnerabilities {
		edges = append(edges, component.EdgeVulnerabilities)
	}
	if m.clearedlicenses {
		edges = append(edges, component.EdgeLicenses)
	}
	if m.clearedrelease {
		edges = append(edges, component.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case component.EdgeVulnerabilities:
		return m.clearedvulnerabilities
	case component.EdgeLicenses:
		return m.clearedlicenses
	case component.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComponentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Component unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComponentMutation) ResetEdge(name string) error {
	switch name {
	case component.EdgeVulnerabilities:
		m.ResetVulnerabilities()
		return nil
	case component.EdgeLicenses:
		m.ResetLicenses()
		return nil
	case component.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown Component edge %s", name)
}

// GitCommitMutation represents an operation that mutates the GitCommit nodes in the graph.
type GitCommitMutation struct {
	config
	op             Op
	typ            string
	id             *int
	hash           *string
	branch         *string
	tag            *string
	time           *time.Time
	clearedFields  map[string]struct{}
	repo           *int
	clearedrepo    bool
	release        *int
	clearedrelease bool
	done           bool
	oldValue       func(context.Context) (*GitCommit, error)
	predicates     []predicate.GitCommit
}

var _ ent.Mutation = (*GitCommitMutation)(nil)

// gitcommitOption allows management of the mutation configuration using functional options.
type gitcommitOption func(*GitCommitMutation)

// newGitCommitMutation creates new mutation for the GitCommit entity.
func newGitCommitMutation(c config, op Op, opts ...gitcommitOption) *GitCommitMutation {
	m := &GitCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeGitCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGitCommitID sets the ID field of the mutation.
func withGitCommitID(id int) gitcommitOption {
	return func(m *GitCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *GitCommit
		)
		m.oldValue = func(ctx context.Context) (*GitCommit, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GitCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGitCommit sets the old GitCommit of the mutation.
func withGitCommit(node *GitCommit) gitcommitOption {
	return func(m *GitCommitMutation) {
		m.oldValue = func(context.Context) (*GitCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GitCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GitCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GitCommitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHash sets the "hash" field.
func (m *GitCommitMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *GitCommitMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *GitCommitMutation) ResetHash() {
	m.hash = nil
}

// SetBranch sets the "branch" field.
func (m *GitCommitMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the value of the "branch" field in the mutation.
func (m *GitCommitMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old "branch" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch resets all changes to the "branch" field.
func (m *GitCommitMutation) ResetBranch() {
	m.branch = nil
}

// SetTag sets the "tag" field.
func (m *GitCommitMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *GitCommitMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *GitCommitMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[gitcommit.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *GitCommitMutation) TagCleared() bool {
	_, ok := m.clearedFields[gitcommit.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *GitCommitMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, gitcommit.FieldTag)
}

// SetTime sets the "time" field.
func (m *GitCommitMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *GitCommitMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the GitCommit entity.
// If the GitCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GitCommitMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *GitCommitMutation) ResetTime() {
	m.time = nil
}

// SetRepoID sets the "repo" edge to the Repo entity by id.
func (m *GitCommitMutation) SetRepoID(id int) {
	m.repo = &id
}

// ClearRepo clears the "repo" edge to the Repo entity.
func (m *GitCommitMutation) ClearRepo() {
	m.clearedrepo = true
}

// RepoCleared reports if the "repo" edge to the Repo entity was cleared.
func (m *GitCommitMutation) RepoCleared() bool {
	return m.clearedrepo
}

// RepoID returns the "repo" edge ID in the mutation.
func (m *GitCommitMutation) RepoID() (id int, exists bool) {
	if m.repo != nil {
		return *m.repo, true
	}
	return
}

// RepoIDs returns the "repo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepoID instead. It exists only for internal usage by the builders.
func (m *GitCommitMutation) RepoIDs() (ids []int) {
	if id := m.repo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepo resets all changes to the "repo" edge.
func (m *GitCommitMutation) ResetRepo() {
	m.repo = nil
	m.clearedrepo = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *GitCommitMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *GitCommitMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *GitCommitMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *GitCommitMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *GitCommitMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *GitCommitMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Op returns the operation name.
func (m *GitCommitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GitCommit).
func (m *GitCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GitCommitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.hash != nil {
		fields = append(fields, gitcommit.FieldHash)
	}
	if m.branch != nil {
		fields = append(fields, gitcommit.FieldBranch)
	}
	if m.tag != nil {
		fields = append(fields, gitcommit.FieldTag)
	}
	if m.time != nil {
		fields = append(fields, gitcommit.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GitCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gitcommit.FieldHash:
		return m.Hash()
	case gitcommit.FieldBranch:
		return m.Branch()
	case gitcommit.FieldTag:
		return m.Tag()
	case gitcommit.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GitCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gitcommit.FieldHash:
		return m.OldHash(ctx)
	case gitcommit.FieldBranch:
		return m.OldBranch(ctx)
	case gitcommit.FieldTag:
		return m.OldTag(ctx)
	case gitcommit.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown GitCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gitcommit.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case gitcommit.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case gitcommit.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case gitcommit.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GitCommitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GitCommitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GitCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GitCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GitCommitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gitcommit.FieldTag) {
		fields = append(fields, gitcommit.FieldTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GitCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GitCommitMutation) ClearField(name string) error {
	switch name {
	case gitcommit.FieldTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown GitCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GitCommitMutation) ResetField(name string) error {
	switch name {
	case gitcommit.FieldHash:
		m.ResetHash()
		return nil
	case gitcommit.FieldBranch:
		m.ResetBranch()
		return nil
	case gitcommit.FieldTag:
		m.ResetTag()
		return nil
	case gitcommit.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown GitCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GitCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.repo != nil {
		edges = append(edges, gitcommit.EdgeRepo)
	}
	if m.release != nil {
		edges = append(edges, gitcommit.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GitCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gitcommit.EdgeRepo:
		if id := m.repo; id != nil {
			return []ent.Value{*id}
		}
	case gitcommit.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GitCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GitCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GitCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrepo {
		edges = append(edges, gitcommit.EdgeRepo)
	}
	if m.clearedrelease {
		edges = append(edges, gitcommit.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GitCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case gitcommit.EdgeRepo:
		return m.clearedrepo
	case gitcommit.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GitCommitMutation) ClearEdge(name string) error {
	switch name {
	case gitcommit.EdgeRepo:
		m.ClearRepo()
		return nil
	case gitcommit.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown GitCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GitCommitMutation) ResetEdge(name string) error {
	switch name {
	case gitcommit.EdgeRepo:
		m.ResetRepo()
		return nil
	case gitcommit.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown GitCommit edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                Op
	typ               string
	id                *int
	spdx_id           *string
	name              *string
	reference         *string
	details_url       *string
	is_osi_approved   *bool
	clearedFields     map[string]struct{}
	components        map[int]struct{}
	removedcomponents map[int]struct{}
	clearedcomponents bool
	usages            map[int]struct{}
	removedusages     map[int]struct{}
	clearedusages     bool
	done              bool
	oldValue          func(context.Context) (*License, error)
	predicates        []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id int) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSpdxID sets the "spdx_id" field.
func (m *LicenseMutation) SetSpdxID(s string) {
	m.spdx_id = &s
}

// SpdxID returns the value of the "spdx_id" field in the mutation.
func (m *LicenseMutation) SpdxID() (r string, exists bool) {
	v := m.spdx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpdxID returns the old "spdx_id" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldSpdxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpdxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpdxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpdxID: %w", err)
	}
	return oldValue.SpdxID, nil
}

// ResetSpdxID resets all changes to the "spdx_id" field.
func (m *LicenseMutation) ResetSpdxID() {
	m.spdx_id = nil
}

// SetName sets the "name" field.
func (m *LicenseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LicenseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LicenseMutation) ResetName() {
	m.name = nil
}

// SetReference sets the "reference" field.
func (m *LicenseMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *LicenseMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *LicenseMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[license.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *LicenseMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[license.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *LicenseMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, license.FieldReference)
}

// SetDetailsURL sets the "details_url" field.
func (m *LicenseMutation) SetDetailsURL(s string) {
	m.details_url = &s
}

// DetailsURL returns the value of the "details_url" field in the mutation.
func (m *LicenseMutation) DetailsURL() (r string, exists bool) {
	v := m.details_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailsURL returns the old "details_url" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldDetailsURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailsURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailsURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailsURL: %w", err)
	}
	return oldValue.DetailsURL, nil
}

// ClearDetailsURL clears the value of the "details_url" field.
func (m *LicenseMutation) ClearDetailsURL() {
	m.details_url = nil
	m.clearedFields[license.FieldDetailsURL] = struct{}{}
}

// DetailsURLCleared returns if the "details_url" field was cleared in this mutation.
func (m *LicenseMutation) DetailsURLCleared() bool {
	_, ok := m.clearedFields[license.FieldDetailsURL]
	return ok
}

// ResetDetailsURL resets all changes to the "details_url" field.
func (m *LicenseMutation) ResetDetailsURL() {
	m.details_url = nil
	delete(m.clearedFields, license.FieldDetailsURL)
}

// SetIsOsiApproved sets the "is_osi_approved" field.
func (m *LicenseMutation) SetIsOsiApproved(b bool) {
	m.is_osi_approved = &b
}

// IsOsiApproved returns the value of the "is_osi_approved" field in the mutation.
func (m *LicenseMutation) IsOsiApproved() (r bool, exists bool) {
	v := m.is_osi_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOsiApproved returns the old "is_osi_approved" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldIsOsiApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsOsiApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsOsiApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOsiApproved: %w", err)
	}
	return oldValue.IsOsiApproved, nil
}

// ResetIsOsiApproved resets all changes to the "is_osi_approved" field.
func (m *LicenseMutation) ResetIsOsiApproved() {
	m.is_osi_approved = nil
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *LicenseMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *LicenseMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *LicenseMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *LicenseMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *LicenseMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *LicenseMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *LicenseMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// AddUsageIDs adds the "usages" edge to the LicenseUsage entity by ids.
func (m *LicenseMutation) AddUsageIDs(ids ...int) {
	if m.usages == nil {
		m.usages = make(map[int]struct{})
	}
	for i := range ids {
		m.usages[ids[i]] = struct{}{}
	}
}

// ClearUsages clears the "usages" edge to the LicenseUsage entity.
func (m *LicenseMutation) ClearUsages() {
	m.clearedusages = true
}

// UsagesCleared reports if the "usages" edge to the LicenseUsage entity was cleared.
func (m *LicenseMutation) UsagesCleared() bool {
	return m.clearedusages
}

// RemoveUsageIDs removes the "usages" edge to the LicenseUsage entity by IDs.
func (m *LicenseMutation) RemoveUsageIDs(ids ...int) {
	if m.removedusages == nil {
		m.removedusages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usages, ids[i])
		m.removedusages[ids[i]] = struct{}{}
	}
}

// RemovedUsages returns the removed IDs of the "usages" edge to the LicenseUsage entity.
func (m *LicenseMutation) RemovedUsagesIDs() (ids []int) {
	for id := range m.removedusages {
		ids = append(ids, id)
	}
	return
}

// UsagesIDs returns the "usages" edge IDs in the mutation.
func (m *LicenseMutation) UsagesIDs() (ids []int) {
	for id := range m.usages {
		ids = append(ids, id)
	}
	return
}

// ResetUsages resets all changes to the "usages" edge.
func (m *LicenseMutation) ResetUsages() {
	m.usages = nil
	m.clearedusages = false
	m.removedusages = nil
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.spdx_id != nil {
		fields = append(fields, license.FieldSpdxID)
	}
	if m.name != nil {
		fields = append(fields, license.FieldName)
	}
	if m.reference != nil {
		fields = append(fields, license.FieldReference)
	}
	if m.details_url != nil {
		fields = append(fields, license.FieldDetailsURL)
	}
	if m.is_osi_approved != nil {
		fields = append(fields, license.FieldIsOsiApproved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldSpdxID:
		return m.SpdxID()
	case license.FieldName:
		return m.Name()
	case license.FieldReference:
		return m.Reference()
	case license.FieldDetailsURL:
		return m.DetailsURL()
	case license.FieldIsOsiApproved:
		return m.IsOsiApproved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldSpdxID:
		return m.OldSpdxID(ctx)
	case license.FieldName:
		return m.OldName(ctx)
	case license.FieldReference:
		return m.OldReference(ctx)
	case license.FieldDetailsURL:
		return m.OldDetailsURL(ctx)
	case license.FieldIsOsiApproved:
		return m.OldIsOsiApproved(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldSpdxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpdxID(v)
		return nil
	case license.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case license.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case license.FieldDetailsURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailsURL(v)
		return nil
	case license.FieldIsOsiApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOsiApproved(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldReference) {
		fields = append(fields, license.FieldReference)
	}
	if m.FieldCleared(license.FieldDetailsURL) {
		fields = append(fields, license.FieldDetailsURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldReference:
		m.ClearReference()
		return nil
	case license.FieldDetailsURL:
		m.ClearDetailsURL()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldSpdxID:
		m.ResetSpdxID()
		return nil
	case license.FieldName:
		m.ResetName()
		return nil
	case license.FieldReference:
		m.ResetReference()
		return nil
	case license.FieldDetailsURL:
		m.ResetDetailsURL()
		return nil
	case license.FieldIsOsiApproved:
		m.ResetIsOsiApproved()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.components != nil {
		edges = append(edges, license.EdgeComponents)
	}
	if m.usages != nil {
		edges = append(edges, license.EdgeUsages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.usages))
		for id := range m.usages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomponents != nil {
		edges = append(edges, license.EdgeComponents)
	}
	if m.removedusages != nil {
		edges = append(edges, license.EdgeUsages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	case license.EdgeUsages:
		ids := make([]ent.Value, 0, len(m.removedusages))
		for id := range m.removedusages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomponents {
		edges = append(edges, license.EdgeComponents)
	}
	if m.clearedusages {
		edges = append(edges, license.EdgeUsages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeComponents:
		return m.clearedcomponents
	case license.EdgeUsages:
		return m.clearedusages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeComponents:
		m.ResetComponents()
		return nil
	case license.EdgeUsages:
		m.ResetUsages()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// LicenseScanMutation represents an operation that mutates the LicenseScan nodes in the graph.
type LicenseScanMutation struct {
	config
	op              Op
	typ             string
	id              *int
	tool            *string
	clearedFields   map[string]struct{}
	release         *int
	clearedrelease  bool
	entry           *int
	clearedentry    bool
	licenses        map[int]struct{}
	removedlicenses map[int]struct{}
	clearedlicenses bool
	done            bool
	oldValue        func(context.Context) (*LicenseScan, error)
	predicates      []predicate.LicenseScan
}

var _ ent.Mutation = (*LicenseScanMutation)(nil)

// licensescanOption allows management of the mutation configuration using functional options.
type licensescanOption func(*LicenseScanMutation)

// newLicenseScanMutation creates new mutation for the LicenseScan entity.
func newLicenseScanMutation(c config, op Op, opts ...licensescanOption) *LicenseScanMutation {
	m := &LicenseScanMutation{
		config:        c,
		op:            op,
		typ:           TypeLicenseScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseScanID sets the ID field of the mutation.
func withLicenseScanID(id int) licensescanOption {
	return func(m *LicenseScanMutation) {
		var (
			err   error
			once  sync.Once
			value *LicenseScan
		)
		m.oldValue = func(ctx context.Context) (*LicenseScan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LicenseScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicenseScan sets the old LicenseScan of the mutation.
func withLicenseScan(node *LicenseScan) licensescanOption {
	return func(m *LicenseScanMutation) {
		m.oldValue = func(context.Context) (*LicenseScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *LicenseScanMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *LicenseScanMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the LicenseScan entity.
// If the LicenseScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseScanMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *LicenseScanMutation) ResetTool() {
	m.tool = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *LicenseScanMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *LicenseScanMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *LicenseScanMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *LicenseScanMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *LicenseScanMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *LicenseScanMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *LicenseScanMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *LicenseScanMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *LicenseScanMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *LicenseScanMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *LicenseScanMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *LicenseScanMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// AddLicenseIDs adds the "licenses" edge to the LicenseUsage entity by ids.
func (m *LicenseScanMutation) AddLicenseIDs(ids ...int) {
	if m.licenses == nil {
		m.licenses = make(map[int]struct{})
	}
	for i := range ids {
		m.licenses[ids[i]] = struct{}{}
	}
}

// ClearLicenses clears the "licenses" edge to the LicenseUsage entity.
func (m *LicenseScanMutation) ClearLicenses() {
	m.clearedlicenses = true
}

// LicensesCleared reports if the "licenses" edge to the LicenseUsage entity was cleared.
func (m *LicenseScanMutation) LicensesCleared() bool {
	return m.clearedlicenses
}

// RemoveLicenseIDs removes the "licenses" edge to the LicenseUsage entity by IDs.
func (m *LicenseScanMutation) RemoveLicenseIDs(ids ...int) {
	if m.removedlicenses == nil {
		m.removedlicenses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.licenses, ids[i])
		m.removedlicenses[ids[i]] = struct{}{}
	}
}

// RemovedLicenses returns the removed IDs of the "licenses" edge to the LicenseUsage entity.
func (m *LicenseScanMutation) RemovedLicensesIDs() (ids []int) {
	for id := range m.removedlicenses {
		ids = append(ids, id)
	}
	return
}

// LicensesIDs returns the "licenses" edge IDs in the mutation.
func (m *LicenseScanMutation) LicensesIDs() (ids []int) {
	for id := range m.licenses {
		ids = append(ids, id)
	}
	return
}

// ResetLicenses resets all changes to the "licenses" edge.
func (m *LicenseScanMutation) ResetLicenses() {
	m.licenses = nil
	m.clearedlicenses = false
	m.removedlicenses = nil
}

// Op returns the operation name.
func (m *LicenseScanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LicenseScan).
func (m *LicenseScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseScanMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tool != nil {
		fields = append(fields, licensescan.FieldTool)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case licensescan.FieldTool:
		return m.Tool()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case licensescan.FieldTool:
		return m.OldTool(ctx)
	}
	return nil, fmt.Errorf("unknown LicenseScan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case licensescan.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	}
	return fmt.Errorf("unknown LicenseScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LicenseScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseScanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseScanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LicenseScan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseScanMutation) ResetField(name string) error {
	switch name {
	case licensescan.FieldTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown LicenseScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.release != nil {
		edges = append(edges, licensescan.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, licensescan.EdgeEntry)
	}
	if m.licenses != nil {
		edges = append(edges, licensescan.EdgeLicenses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case licensescan.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case licensescan.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case licensescan.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.licenses))
		for id := range m.licenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlicenses != nil {
		edges = append(edges, licensescan.EdgeLicenses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case licensescan.EdgeLicenses:
		ids := make([]ent.Value, 0, len(m.removedlicenses))
		for id := range m.removedlicenses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelease {
		edges = append(edges, licensescan.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, licensescan.EdgeEntry)
	}
	if m.clearedlicenses {
		edges = append(edges, licensescan.EdgeLicenses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseScanMutation) EdgeCleared(name string) bool {
	switch name {
	case licensescan.EdgeRelease:
		return m.clearedrelease
	case licensescan.EdgeEntry:
		return m.clearedentry
	case licensescan.EdgeLicenses:
		return m.clearedlicenses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseScanMutation) ClearEdge(name string) error {
	switch name {
	case licensescan.EdgeRelease:
		m.ClearRelease()
		return nil
	case licensescan.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown LicenseScan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseScanMutation) ResetEdge(name string) error {
	switch name {
	case licensescan.EdgeRelease:
		m.ResetRelease()
		return nil
	case licensescan.EdgeEntry:
		m.ResetEntry()
		return nil
	case licensescan.EdgeLicenses:
		m.ResetLicenses()
		return nil
	}
	return fmt.Errorf("unknown LicenseScan edge %s", name)
}

// LicenseUsageMutation represents an operation that mutates the LicenseUsage nodes in the graph.
type LicenseUsageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	license        *int
	clearedlicense bool
	scan           *int
	clearedscan    bool
	done           bool
	oldValue       func(context.Context) (*LicenseUsage, error)
	predicates     []predicate.LicenseUsage
}

var _ ent.Mutation = (*LicenseUsageMutation)(nil)

// licenseusageOption allows management of the mutation configuration using functional options.
type licenseusageOption func(*LicenseUsageMutation)

// newLicenseUsageMutation creates new mutation for the LicenseUsage entity.
func newLicenseUsageMutation(c config, op Op, opts ...licenseusageOption) *LicenseUsageMutation {
	m := &LicenseUsageMutation{
		config:        c,
		op:            op,
		typ:           TypeLicenseUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseUsageID sets the ID field of the mutation.
func withLicenseUsageID(id int) licenseusageOption {
	return func(m *LicenseUsageMutation) {
		var (
			err   error
			once  sync.Once
			value *LicenseUsage
		)
		m.oldValue = func(ctx context.Context) (*LicenseUsage, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LicenseUsage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicenseUsage sets the old LicenseUsage of the mutation.
func withLicenseUsage(node *LicenseUsage) licenseusageOption {
	return func(m *LicenseUsageMutation) {
		m.oldValue = func(context.Context) (*LicenseUsage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseUsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseUsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseUsageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLicenseID sets the "license" edge to the License entity by id.
func (m *LicenseUsageMutation) SetLicenseID(id int) {
	m.license = &id
}

// ClearLicense clears the "license" edge to the License entity.
func (m *LicenseUsageMutation) ClearLicense() {
	m.clearedlicense = true
}

// LicenseCleared reports if the "license" edge to the License entity was cleared.
func (m *LicenseUsageMutation) LicenseCleared() bool {
	return m.clearedlicense
}

// LicenseID returns the "license" edge ID in the mutation.
func (m *LicenseUsageMutation) LicenseID() (id int, exists bool) {
	if m.license != nil {
		return *m.license, true
	}
	return
}

// LicenseIDs returns the "license" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *LicenseUsageMutation) LicenseIDs() (ids []int) {
	if id := m.license; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "license" edge.
func (m *LicenseUsageMutation) ResetLicense() {
	m.license = nil
	m.clearedlicense = false
}

// SetScanID sets the "scan" edge to the LicenseScan entity by id.
func (m *LicenseUsageMutation) SetScanID(id int) {
	m.scan = &id
}

// ClearScan clears the "scan" edge to the LicenseScan entity.
func (m *LicenseUsageMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the LicenseScan entity was cleared.
func (m *LicenseUsageMutation) ScanCleared() bool {
	return m.clearedscan
}

// ScanID returns the "scan" edge ID in the mutation.
func (m *LicenseUsageMutation) ScanID() (id int, exists bool) {
	if m.scan != nil {
		return *m.scan, true
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScanID instead. It exists only for internal usage by the builders.
func (m *LicenseUsageMutation) ScanIDs() (ids []int) {
	if id := m.scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *LicenseUsageMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
}

// Op returns the operation name.
func (m *LicenseUsageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LicenseUsage).
func (m *LicenseUsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseUsageMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseUsageMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseUsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown LicenseUsage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseUsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LicenseUsage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseUsageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseUsageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseUsageMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown LicenseUsage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseUsageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseUsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseUsageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LicenseUsage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseUsageMutation) ResetField(name string) error {
	return fmt.Errorf("unknown LicenseUsage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseUsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.license != nil {
		edges = append(edges, licenseusage.EdgeLicense)
	}
	if m.scan != nil {
		edges = append(edges, licenseusage.EdgeScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseUsageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case licenseusage.EdgeLicense:
		if id := m.license; id != nil {
			return []ent.Value{*id}
		}
	case licenseusage.EdgeScan:
		if id := m.scan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseUsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseUsageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseUsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlicense {
		edges = append(edges, licenseusage.EdgeLicense)
	}
	if m.clearedscan {
		edges = append(edges, licenseusage.EdgeScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseUsageMutation) EdgeCleared(name string) bool {
	switch name {
	case licenseusage.EdgeLicense:
		return m.clearedlicense
	case licenseusage.EdgeScan:
		return m.clearedscan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseUsageMutation) ClearEdge(name string) error {
	switch name {
	case licenseusage.EdgeLicense:
		m.ClearLicense()
		return nil
	case licenseusage.EdgeScan:
		m.ClearScan()
		return nil
	}
	return fmt.Errorf("unknown LicenseUsage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseUsageMutation) ResetEdge(name string) error {
	switch name {
	case licenseusage.EdgeLicense:
		m.ResetLicense()
		return nil
	case licenseusage.EdgeScan:
		m.ResetScan()
		return nil
	}
	return fmt.Errorf("unknown LicenseUsage edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	repos            map[int]struct{}
	removedrepos     map[int]struct{}
	clearedrepos     bool
	releases         map[int]struct{}
	removedreleases  map[int]struct{}
	clearedreleases  bool
	cve_rules        map[int]struct{}
	removedcve_rules map[int]struct{}
	clearedcve_rules bool
	done             bool
	oldValue         func(context.Context) (*Project, error)
	predicates       []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// AddRepoIDs adds the "repos" edge to the Repo entity by ids.
func (m *ProjectMutation) AddRepoIDs(ids ...int) {
	if m.repos == nil {
		m.repos = make(map[int]struct{})
	}
	for i := range ids {
		m.repos[ids[i]] = struct{}{}
	}
}

// ClearRepos clears the "repos" edge to the Repo entity.
func (m *ProjectMutation) ClearRepos() {
	m.clearedrepos = true
}

// ReposCleared reports if the "repos" edge to the Repo entity was cleared.
func (m *ProjectMutation) ReposCleared() bool {
	return m.clearedrepos
}

// RemoveRepoIDs removes the "repos" edge to the Repo entity by IDs.
func (m *ProjectMutation) RemoveRepoIDs(ids ...int) {
	if m.removedrepos == nil {
		m.removedrepos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repos, ids[i])
		m.removedrepos[ids[i]] = struct{}{}
	}
}

// RemovedRepos returns the removed IDs of the "repos" edge to the Repo entity.
func (m *ProjectMutation) RemovedReposIDs() (ids []int) {
	for id := range m.removedrepos {
		ids = append(ids, id)
	}
	return
}

// ReposIDs returns the "repos" edge IDs in the mutation.
func (m *ProjectMutation) ReposIDs() (ids []int) {
	for id := range m.repos {
		ids = append(ids, id)
	}
	return
}

// ResetRepos resets all changes to the "repos" edge.
func (m *ProjectMutation) ResetRepos() {
	m.repos = nil
	m.clearedrepos = false
	m.removedrepos = nil
}

// AddReleaseIDs adds the "releases" edge to the Release entity by ids.
func (m *ProjectMutation) AddReleaseIDs(ids ...int) {
	if m.releases == nil {
		m.releases = make(map[int]struct{})
	}
	for i := range ids {
		m.releases[ids[i]] = struct{}{}
	}
}

// ClearReleases clears the "releases" edge to the Release entity.
func (m *ProjectMutation) ClearReleases() {
	m.clearedreleases = true
}

// ReleasesCleared reports if the "releases" edge to the Release entity was cleared.
func (m *ProjectMutation) ReleasesCleared() bool {
	return m.clearedreleases
}

// RemoveReleaseIDs removes the "releases" edge to the Release entity by IDs.
func (m *ProjectMutation) RemoveReleaseIDs(ids ...int) {
	if m.removedreleases == nil {
		m.removedreleases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.releases, ids[i])
		m.removedreleases[ids[i]] = struct{}{}
	}
}

// RemovedReleases returns the removed IDs of the "releases" edge to the Release entity.
func (m *ProjectMutation) RemovedReleasesIDs() (ids []int) {
	for id := range m.removedreleases {
		ids = append(ids, id)
	}
	return
}

// ReleasesIDs returns the "releases" edge IDs in the mutation.
func (m *ProjectMutation) ReleasesIDs() (ids []int) {
	for id := range m.releases {
		ids = append(ids, id)
	}
	return
}

// ResetReleases resets all changes to the "releases" edge.
func (m *ProjectMutation) ResetReleases() {
	m.releases = nil
	m.clearedreleases = false
	m.removedreleases = nil
}

// AddCveRuleIDs adds the "cve_rules" edge to the CVERule entity by ids.
func (m *ProjectMutation) AddCveRuleIDs(ids ...int) {
	if m.cve_rules == nil {
		m.cve_rules = make(map[int]struct{})
	}
	for i := range ids {
		m.cve_rules[ids[i]] = struct{}{}
	}
}

// ClearCveRules clears the "cve_rules" edge to the CVERule entity.
func (m *ProjectMutation) ClearCveRules() {
	m.clearedcve_rules = true
}

// CveRulesCleared reports if the "cve_rules" edge to the CVERule entity was cleared.
func (m *ProjectMutation) CveRulesCleared() bool {
	return m.clearedcve_rules
}

// RemoveCveRuleIDs removes the "cve_rules" edge to the CVERule entity by IDs.
func (m *ProjectMutation) RemoveCveRuleIDs(ids ...int) {
	if m.removedcve_rules == nil {
		m.removedcve_rules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cve_rules, ids[i])
		m.removedcve_rules[ids[i]] = struct{}{}
	}
}

// RemovedCveRules returns the removed IDs of the "cve_rules" edge to the CVERule entity.
func (m *ProjectMutation) RemovedCveRulesIDs() (ids []int) {
	for id := range m.removedcve_rules {
		ids = append(ids, id)
	}
	return
}

// CveRulesIDs returns the "cve_rules" edge IDs in the mutation.
func (m *ProjectMutation) CveRulesIDs() (ids []int) {
	for id := range m.cve_rules {
		ids = append(ids, id)
	}
	return
}

// ResetCveRules resets all changes to the "cve_rules" edge.
func (m *ProjectMutation) ResetCveRules() {
	m.cve_rules = nil
	m.clearedcve_rules = false
	m.removedcve_rules = nil
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.repos != nil {
		edges = append(edges, project.EdgeRepos)
	}
	if m.releases != nil {
		edges = append(edges, project.EdgeReleases)
	}
	if m.cve_rules != nil {
		edges = append(edges, project.EdgeCveRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.repos))
		for id := range m.repos {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeReleases:
		ids := make([]ent.Value, 0, len(m.releases))
		for id := range m.releases {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCveRules:
		ids := make([]ent.Value, 0, len(m.cve_rules))
		for id := range m.cve_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrepos != nil {
		edges = append(edges, project.EdgeRepos)
	}
	if m.removedreleases != nil {
		edges = append(edges, project.EdgeReleases)
	}
	if m.removedcve_rules != nil {
		edges = append(edges, project.EdgeCveRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeRepos:
		ids := make([]ent.Value, 0, len(m.removedrepos))
		for id := range m.removedrepos {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeReleases:
		ids := make([]ent.Value, 0, len(m.removedreleases))
		for id := range m.removedreleases {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeCveRules:
		ids := make([]ent.Value, 0, len(m.removedcve_rules))
		for id := range m.removedcve_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrepos {
		edges = append(edges, project.EdgeRepos)
	}
	if m.clearedreleases {
		edges = append(edges, project.EdgeReleases)
	}
	if m.clearedcve_rules {
		edges = append(edges, project.EdgeCveRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeRepos:
		return m.clearedrepos
	case project.EdgeReleases:
		return m.clearedreleases
	case project.EdgeCveRules:
		return m.clearedcve_rules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeRepos:
		m.ResetRepos()
		return nil
	case project.EdgeReleases:
		m.ResetReleases()
		return nil
	case project.EdgeCveRules:
		m.ResetCveRules()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ReleaseMutation represents an operation that mutates the Release nodes in the graph.
type ReleaseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	version              *string
	status               *release.Status
	clearedFields        map[string]struct{}
	subreleases          map[int]struct{}
	removedsubreleases   map[int]struct{}
	clearedsubreleases   bool
	dependencies         map[int]struct{}
	removeddependencies  map[int]struct{}
	cleareddependencies  bool
	project              *int
	clearedproject       bool
	commit               *int
	clearedcommit        bool
	artifacts            map[int]struct{}
	removedartifacts     map[int]struct{}
	clearedartifacts     bool
	checks               map[int]struct{}
	removedchecks        map[int]struct{}
	clearedchecks        bool
	log                  map[int]struct{}
	removedlog           map[int]struct{}
	clearedlog           bool
	code_scans           map[int]struct{}
	removedcode_scans    map[int]struct{}
	clearedcode_scans    bool
	cve_scans            map[int]struct{}
	removedcve_scans     map[int]struct{}
	clearedcve_scans     bool
	license_scans        map[int]struct{}
	removedlicense_scans map[int]struct{}
	clearedlicense_scans bool
	test_runs            map[int]struct{}
	removedtest_runs     map[int]struct{}
	clearedtest_runs     bool
	components           map[int]struct{}
	removedcomponents    map[int]struct{}
	clearedcomponents    bool
	done                 bool
	oldValue             func(context.Context) (*Release, error)
	predicates           []predicate.Release
}

var _ ent.Mutation = (*ReleaseMutation)(nil)

// releaseOption allows management of the mutation configuration using functional options.
type releaseOption func(*ReleaseMutation)

// newReleaseMutation creates new mutation for the Release entity.
func newReleaseMutation(c config, op Op, opts ...releaseOption) *ReleaseMutation {
	m := &ReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseID sets the ID field of the mutation.
func withReleaseID(id int) releaseOption {
	return func(m *ReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Release
		)
		m.oldValue = func(ctx context.Context) (*Release, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Release.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelease sets the old Release of the mutation.
func withRelease(node *Release) releaseOption {
	return func(m *ReleaseMutation) {
		m.oldValue = func(context.Context) (*Release, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ReleaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReleaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReleaseMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *ReleaseMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ReleaseMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ReleaseMutation) ResetVersion() {
	m.version = nil
}

// SetStatus sets the "status" field.
func (m *ReleaseMutation) SetStatus(r release.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReleaseMutation) Status() (r release.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldStatus(ctx context.Context) (v release.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReleaseMutation) ResetStatus() {
	m.status = nil
}

// AddSubreleaseIDs adds the "subreleases" edge to the Release entity by ids.
func (m *ReleaseMutation) AddSubreleaseIDs(ids ...int) {
	if m.subreleases == nil {
		m.subreleases = make(map[int]struct{})
	}
	for i := range ids {
		m.subreleases[ids[i]] = struct{}{}
	}
}

// ClearSubreleases clears the "subreleases" edge to the Release entity.
func (m *ReleaseMutation) ClearSubreleases() {
	m.clearedsubreleases = true
}

// SubreleasesCleared reports if the "subreleases" edge to the Release entity was cleared.
func (m *ReleaseMutation) SubreleasesCleared() bool {
	return m.clearedsubreleases
}

// RemoveSubreleaseIDs removes the "subreleases" edge to the Release entity by IDs.
func (m *ReleaseMutation) RemoveSubreleaseIDs(ids ...int) {
	if m.removedsubreleases == nil {
		m.removedsubreleases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subreleases, ids[i])
		m.removedsubreleases[ids[i]] = struct{}{}
	}
}

// RemovedSubreleases returns the removed IDs of the "subreleases" edge to the Release entity.
func (m *ReleaseMutation) RemovedSubreleasesIDs() (ids []int) {
	for id := range m.removedsubreleases {
		ids = append(ids, id)
	}
	return
}

// SubreleasesIDs returns the "subreleases" edge IDs in the mutation.
func (m *ReleaseMutation) SubreleasesIDs() (ids []int) {
	for id := range m.subreleases {
		ids = append(ids, id)
	}
	return
}

// ResetSubreleases resets all changes to the "subreleases" edge.
func (m *ReleaseMutation) ResetSubreleases() {
	m.subreleases = nil
	m.clearedsubreleases = false
	m.removedsubreleases = nil
}

// AddDependencyIDs adds the "dependencies" edge to the Release entity by ids.
func (m *ReleaseMutation) AddDependencyIDs(ids ...int) {
	if m.dependencies == nil {
		m.dependencies = make(map[int]struct{})
	}
	for i := range ids {
		m.dependencies[ids[i]] = struct{}{}
	}
}

// ClearDependencies clears the "dependencies" edge to the Release entity.
func (m *ReleaseMutation) ClearDependencies() {
	m.cleareddependencies = true
}

// DependenciesCleared reports if the "dependencies" edge to the Release entity was cleared.
func (m *ReleaseMutation) DependenciesCleared() bool {
	return m.cleareddependencies
}

// RemoveDependencyIDs removes the "dependencies" edge to the Release entity by IDs.
func (m *ReleaseMutation) RemoveDependencyIDs(ids ...int) {
	if m.removeddependencies == nil {
		m.removeddependencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dependencies, ids[i])
		m.removeddependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependencies returns the removed IDs of the "dependencies" edge to the Release entity.
func (m *ReleaseMutation) RemovedDependenciesIDs() (ids []int) {
	for id := range m.removeddependencies {
		ids = append(ids, id)
	}
	return
}

// DependenciesIDs returns the "dependencies" edge IDs in the mutation.
func (m *ReleaseMutation) DependenciesIDs() (ids []int) {
	for id := range m.dependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependencies resets all changes to the "dependencies" edge.
func (m *ReleaseMutation) ResetDependencies() {
	m.dependencies = nil
	m.cleareddependencies = false
	m.removeddependencies = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ReleaseMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ReleaseMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ReleaseMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ReleaseMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ReleaseMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ReleaseMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetCommitID sets the "commit" edge to the GitCommit entity by id.
func (m *ReleaseMutation) SetCommitID(id int) {
	m.commit = &id
}

// ClearCommit clears the "commit" edge to the GitCommit entity.
func (m *ReleaseMutation) ClearCommit() {
	m.clearedcommit = true
}

// CommitCleared reports if the "commit" edge to the GitCommit entity was cleared.
func (m *ReleaseMutation) CommitCleared() bool {
	return m.clearedcommit
}

// CommitID returns the "commit" edge ID in the mutation.
func (m *ReleaseMutation) CommitID() (id int, exists bool) {
	if m.commit != nil {
		return *m.commit, true
	}
	return
}

// CommitIDs returns the "commit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommitID instead. It exists only for internal usage by the builders.
func (m *ReleaseMutation) CommitIDs() (ids []int) {
	if id := m.commit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommit resets all changes to the "commit" edge.
func (m *ReleaseMutation) ResetCommit() {
	m.commit = nil
	m.clearedcommit = false
}

// AddArtifactIDs adds the "artifacts" edge to the Artifact entity by ids.
func (m *ReleaseMutation) AddArtifactIDs(ids ...int) {
	if m.artifacts == nil {
		m.artifacts = make(map[int]struct{})
	}
	for i := range ids {
		m.artifacts[ids[i]] = struct{}{}
	}
}

// ClearArtifacts clears the "artifacts" edge to the Artifact entity.
func (m *ReleaseMutation) ClearArtifacts() {
	m.clearedartifacts = true
}

// ArtifactsCleared reports if the "artifacts" edge to the Artifact entity was cleared.
func (m *ReleaseMutation) ArtifactsCleared() bool {
	return m.clearedartifacts
}

// RemoveArtifactIDs removes the "artifacts" edge to the Artifact entity by IDs.
func (m *ReleaseMutation) RemoveArtifactIDs(ids ...int) {
	if m.removedartifacts == nil {
		m.removedartifacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifacts, ids[i])
		m.removedartifacts[ids[i]] = struct{}{}
	}
}

// RemovedArtifacts returns the removed IDs of the "artifacts" edge to the Artifact entity.
func (m *ReleaseMutation) RemovedArtifactsIDs() (ids []int) {
	for id := range m.removedartifacts {
		ids = append(ids, id)
	}
	return
}

// ArtifactsIDs returns the "artifacts" edge IDs in the mutation.
func (m *ReleaseMutation) ArtifactsIDs() (ids []int) {
	for id := range m.artifacts {
		ids = append(ids, id)
	}
	return
}

// ResetArtifacts resets all changes to the "artifacts" edge.
func (m *ReleaseMutation) ResetArtifacts() {
	m.artifacts = nil
	m.clearedartifacts = false
	m.removedartifacts = nil
}

// AddCheckIDs adds the "checks" edge to the ReleaseCheck entity by ids.
func (m *ReleaseMutation) AddCheckIDs(ids ...int) {
	if m.checks == nil {
		m.checks = make(map[int]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the ReleaseCheck entity.
func (m *ReleaseMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the ReleaseCheck entity was cleared.
func (m *ReleaseMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the ReleaseCheck entity by IDs.
func (m *ReleaseMutation) RemoveCheckIDs(ids ...int) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the ReleaseCheck entity.
func (m *ReleaseMutation) RemovedChecksIDs() (ids []int) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *ReleaseMutation) ChecksIDs() (ids []int) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *ReleaseMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// AddLogIDs adds the "log" edge to the ReleaseEntry entity by ids.
func (m *ReleaseMutation) AddLogIDs(ids ...int) {
	if m.log == nil {
		m.log = make(map[int]struct{})
	}
	for i := range ids {
		m.log[ids[i]] = struct{}{}
	}
}

// ClearLog clears the "log" edge to the ReleaseEntry entity.
func (m *ReleaseMutation) ClearLog() {
	m.clearedlog = true
}

// LogCleared reports if the "log" edge to the ReleaseEntry entity was cleared.
func (m *ReleaseMutation) LogCleared() bool {
	return m.clearedlog
}

// RemoveLogIDs removes the "log" edge to the ReleaseEntry entity by IDs.
func (m *ReleaseMutation) RemoveLogIDs(ids ...int) {
	if m.removedlog == nil {
		m.removedlog = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.log, ids[i])
		m.removedlog[ids[i]] = struct{}{}
	}
}

// RemovedLog returns the removed IDs of the "log" edge to the ReleaseEntry entity.
func (m *ReleaseMutation) RemovedLogIDs() (ids []int) {
	for id := range m.removedlog {
		ids = append(ids, id)
	}
	return
}

// LogIDs returns the "log" edge IDs in the mutation.
func (m *ReleaseMutation) LogIDs() (ids []int) {
	for id := range m.log {
		ids = append(ids, id)
	}
	return
}

// ResetLog resets all changes to the "log" edge.
func (m *ReleaseMutation) ResetLog() {
	m.log = nil
	m.clearedlog = false
	m.removedlog = nil
}

// AddCodeScanIDs adds the "code_scans" edge to the CodeScan entity by ids.
func (m *ReleaseMutation) AddCodeScanIDs(ids ...int) {
	if m.code_scans == nil {
		m.code_scans = make(map[int]struct{})
	}
	for i := range ids {
		m.code_scans[ids[i]] = struct{}{}
	}
}

// ClearCodeScans clears the "code_scans" edge to the CodeScan entity.
func (m *ReleaseMutation) ClearCodeScans() {
	m.clearedcode_scans = true
}

// CodeScansCleared reports if the "code_scans" edge to the CodeScan entity was cleared.
func (m *ReleaseMutation) CodeScansCleared() bool {
	return m.clearedcode_scans
}

// RemoveCodeScanIDs removes the "code_scans" edge to the CodeScan entity by IDs.
func (m *ReleaseMutation) RemoveCodeScanIDs(ids ...int) {
	if m.removedcode_scans == nil {
		m.removedcode_scans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.code_scans, ids[i])
		m.removedcode_scans[ids[i]] = struct{}{}
	}
}

// RemovedCodeScans returns the removed IDs of the "code_scans" edge to the CodeScan entity.
func (m *ReleaseMutation) RemovedCodeScansIDs() (ids []int) {
	for id := range m.removedcode_scans {
		ids = append(ids, id)
	}
	return
}

// CodeScansIDs returns the "code_scans" edge IDs in the mutation.
func (m *ReleaseMutation) CodeScansIDs() (ids []int) {
	for id := range m.code_scans {
		ids = append(ids, id)
	}
	return
}

// ResetCodeScans resets all changes to the "code_scans" edge.
func (m *ReleaseMutation) ResetCodeScans() {
	m.code_scans = nil
	m.clearedcode_scans = false
	m.removedcode_scans = nil
}

// AddCveScanIDs adds the "cve_scans" edge to the CVEScan entity by ids.
func (m *ReleaseMutation) AddCveScanIDs(ids ...int) {
	if m.cve_scans == nil {
		m.cve_scans = make(map[int]struct{})
	}
	for i := range ids {
		m.cve_scans[ids[i]] = struct{}{}
	}
}

// ClearCveScans clears the "cve_scans" edge to the CVEScan entity.
func (m *ReleaseMutation) ClearCveScans() {
	m.clearedcve_scans = true
}

// CveScansCleared reports if the "cve_scans" edge to the CVEScan entity was cleared.
func (m *ReleaseMutation) CveScansCleared() bool {
	return m.clearedcve_scans
}

// RemoveCveScanIDs removes the "cve_scans" edge to the CVEScan entity by IDs.
func (m *ReleaseMutation) RemoveCveScanIDs(ids ...int) {
	if m.removedcve_scans == nil {
		m.removedcve_scans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cve_scans, ids[i])
		m.removedcve_scans[ids[i]] = struct{}{}
	}
}

// RemovedCveScans returns the removed IDs of the "cve_scans" edge to the CVEScan entity.
func (m *ReleaseMutation) RemovedCveScansIDs() (ids []int) {
	for id := range m.removedcve_scans {
		ids = append(ids, id)
	}
	return
}

// CveScansIDs returns the "cve_scans" edge IDs in the mutation.
func (m *ReleaseMutation) CveScansIDs() (ids []int) {
	for id := range m.cve_scans {
		ids = append(ids, id)
	}
	return
}

// ResetCveScans resets all changes to the "cve_scans" edge.
func (m *ReleaseMutation) ResetCveScans() {
	m.cve_scans = nil
	m.clearedcve_scans = false
	m.removedcve_scans = nil
}

// AddLicenseScanIDs adds the "license_scans" edge to the LicenseScan entity by ids.
func (m *ReleaseMutation) AddLicenseScanIDs(ids ...int) {
	if m.license_scans == nil {
		m.license_scans = make(map[int]struct{})
	}
	for i := range ids {
		m.license_scans[ids[i]] = struct{}{}
	}
}

// ClearLicenseScans clears the "license_scans" edge to the LicenseScan entity.
func (m *ReleaseMutation) ClearLicenseScans() {
	m.clearedlicense_scans = true
}

// LicenseScansCleared reports if the "license_scans" edge to the LicenseScan entity was cleared.
func (m *ReleaseMutation) LicenseScansCleared() bool {
	return m.clearedlicense_scans
}

// RemoveLicenseScanIDs removes the "license_scans" edge to the LicenseScan entity by IDs.
func (m *ReleaseMutation) RemoveLicenseScanIDs(ids ...int) {
	if m.removedlicense_scans == nil {
		m.removedlicense_scans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.license_scans, ids[i])
		m.removedlicense_scans[ids[i]] = struct{}{}
	}
}

// RemovedLicenseScans returns the removed IDs of the "license_scans" edge to the LicenseScan entity.
func (m *ReleaseMutation) RemovedLicenseScansIDs() (ids []int) {
	for id := range m.removedlicense_scans {
		ids = append(ids, id)
	}
	return
}

// LicenseScansIDs returns the "license_scans" edge IDs in the mutation.
func (m *ReleaseMutation) LicenseScansIDs() (ids []int) {
	for id := range m.license_scans {
		ids = append(ids, id)
	}
	return
}

// ResetLicenseScans resets all changes to the "license_scans" edge.
func (m *ReleaseMutation) ResetLicenseScans() {
	m.license_scans = nil
	m.clearedlicense_scans = false
	m.removedlicense_scans = nil
}

// AddTestRunIDs adds the "test_runs" edge to the TestRun entity by ids.
func (m *ReleaseMutation) AddTestRunIDs(ids ...int) {
	if m.test_runs == nil {
		m.test_runs = make(map[int]struct{})
	}
	for i := range ids {
		m.test_runs[ids[i]] = struct{}{}
	}
}

// ClearTestRuns clears the "test_runs" edge to the TestRun entity.
func (m *ReleaseMutation) ClearTestRuns() {
	m.clearedtest_runs = true
}

// TestRunsCleared reports if the "test_runs" edge to the TestRun entity was cleared.
func (m *ReleaseMutation) TestRunsCleared() bool {
	return m.clearedtest_runs
}

// RemoveTestRunIDs removes the "test_runs" edge to the TestRun entity by IDs.
func (m *ReleaseMutation) RemoveTestRunIDs(ids ...int) {
	if m.removedtest_runs == nil {
		m.removedtest_runs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.test_runs, ids[i])
		m.removedtest_runs[ids[i]] = struct{}{}
	}
}

// RemovedTestRuns returns the removed IDs of the "test_runs" edge to the TestRun entity.
func (m *ReleaseMutation) RemovedTestRunsIDs() (ids []int) {
	for id := range m.removedtest_runs {
		ids = append(ids, id)
	}
	return
}

// TestRunsIDs returns the "test_runs" edge IDs in the mutation.
func (m *ReleaseMutation) TestRunsIDs() (ids []int) {
	for id := range m.test_runs {
		ids = append(ids, id)
	}
	return
}

// ResetTestRuns resets all changes to the "test_runs" edge.
func (m *ReleaseMutation) ResetTestRuns() {
	m.test_runs = nil
	m.clearedtest_runs = false
	m.removedtest_runs = nil
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *ReleaseMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *ReleaseMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *ReleaseMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *ReleaseMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *ReleaseMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *ReleaseMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *ReleaseMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// Op returns the operation name.
func (m *ReleaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Release).
func (m *ReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, release.FieldName)
	}
	if m.version != nil {
		fields = append(fields, release.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, release.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case release.FieldName:
		return m.Name()
	case release.FieldVersion:
		return m.Version()
	case release.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case release.FieldName:
		return m.OldName(ctx)
	case release.FieldVersion:
		return m.OldVersion(ctx)
	case release.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Release field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case release.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case release.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case release.FieldStatus:
		v, ok := value.(release.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Release numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Release nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseMutation) ResetField(name string) error {
	switch name {
	case release.FieldName:
		m.ResetName()
		return nil
	case release.FieldVersion:
		m.ResetVersion()
		return nil
	case release.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.subreleases != nil {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.dependencies != nil {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.project != nil {
		edges = append(edges, release.EdgeProject)
	}
	if m.commit != nil {
		edges = append(edges, release.EdgeCommit)
	}
	if m.artifacts != nil {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.checks != nil {
		edges = append(edges, release.EdgeChecks)
	}
	if m.log != nil {
		edges = append(edges, release.EdgeLog)
	}
	if m.code_scans != nil {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.cve_scans != nil {
		edges = append(edges, release.EdgeCveScans)
	}
	if m.license_scans != nil {
		edges = append(edges, release.EdgeLicenseScans)
	}
	if m.test_runs != nil {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.components != nil {
		edges = append(edges, release.EdgeComponents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeSubreleases:
		ids := make([]ent.Value, 0, len(m.subreleases))
		for id := range m.subreleases {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.dependencies))
		for id := range m.dependencies {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case release.EdgeCommit:
		if id := m.commit; id != nil {
			return []ent.Value{*id}
		}
	case release.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.artifacts))
		for id := range m.artifacts {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLog:
		ids := make([]ent.Value, 0, len(m.log))
		for id := range m.log {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCodeScans:
		ids := make([]ent.Value, 0, len(m.code_scans))
		for id := range m.code_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCveScans:
		ids := make([]ent.Value, 0, len(m.cve_scans))
		for id := range m.cve_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLicenseScans:
		ids := make([]ent.Value, 0, len(m.license_scans))
		for id := range m.license_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeTestRuns:
		ids := make([]ent.Value, 0, len(m.test_runs))
		for id := range m.test_runs {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedsubreleases != nil {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.removeddependencies != nil {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.removedartifacts != nil {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.removedchecks != nil {
		edges = append(edges, release.EdgeChecks)
	}
	if m.removedlog != nil {
		edges = append(edges, release.EdgeLog)
	}
	if m.removedcode_scans != nil {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.removedcve_scans != nil {
		edges = append(edges, release.EdgeCveScans)
	}
	if m.removedlicense_scans != nil {
		edges = append(edges, release.EdgeLicenseScans)
	}
	if m.removedtest_runs != nil {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.removedcomponents != nil {
		edges = append(edges, release.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeSubreleases:
		ids := make([]ent.Value, 0, len(m.removedsubreleases))
		for id := range m.removedsubreleases {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeDependencies:
		ids := make([]ent.Value, 0, len(m.removeddependencies))
		for id := range m.removeddependencies {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeArtifacts:
		ids := make([]ent.Value, 0, len(m.removedartifacts))
		for id := range m.removedartifacts {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLog:
		ids := make([]ent.Value, 0, len(m.removedlog))
		for id := range m.removedlog {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCodeScans:
		ids := make([]ent.Value, 0, len(m.removedcode_scans))
		for id := range m.removedcode_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeCveScans:
		ids := make([]ent.Value, 0, len(m.removedcve_scans))
		for id := range m.removedcve_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeLicenseScans:
		ids := make([]ent.Value, 0, len(m.removedlicense_scans))
		for id := range m.removedlicense_scans {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeTestRuns:
		ids := make([]ent.Value, 0, len(m.removedtest_runs))
		for id := range m.removedtest_runs {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedsubreleases {
		edges = append(edges, release.EdgeSubreleases)
	}
	if m.cleareddependencies {
		edges = append(edges, release.EdgeDependencies)
	}
	if m.clearedproject {
		edges = append(edges, release.EdgeProject)
	}
	if m.clearedcommit {
		edges = append(edges, release.EdgeCommit)
	}
	if m.clearedartifacts {
		edges = append(edges, release.EdgeArtifacts)
	}
	if m.clearedchecks {
		edges = append(edges, release.EdgeChecks)
	}
	if m.clearedlog {
		edges = append(edges, release.EdgeLog)
	}
	if m.clearedcode_scans {
		edges = append(edges, release.EdgeCodeScans)
	}
	if m.clearedcve_scans {
		edges = append(edges, release.EdgeCveScans)
	}
	if m.clearedlicense_scans {
		edges = append(edges, release.EdgeLicenseScans)
	}
	if m.clearedtest_runs {
		edges = append(edges, release.EdgeTestRuns)
	}
	if m.clearedcomponents {
		edges = append(edges, release.EdgeComponents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseMutation) EdgeCleared(name string) bool {
	switch name {
	case release.EdgeSubreleases:
		return m.clearedsubreleases
	case release.EdgeDependencies:
		return m.cleareddependencies
	case release.EdgeProject:
		return m.clearedproject
	case release.EdgeCommit:
		return m.clearedcommit
	case release.EdgeArtifacts:
		return m.clearedartifacts
	case release.EdgeChecks:
		return m.clearedchecks
	case release.EdgeLog:
		return m.clearedlog
	case release.EdgeCodeScans:
		return m.clearedcode_scans
	case release.EdgeCveScans:
		return m.clearedcve_scans
	case release.EdgeLicenseScans:
		return m.clearedlicense_scans
	case release.EdgeTestRuns:
		return m.clearedtest_runs
	case release.EdgeComponents:
		return m.clearedcomponents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseMutation) ClearEdge(name string) error {
	switch name {
	case release.EdgeProject:
		m.ClearProject()
		return nil
	case release.EdgeCommit:
		m.ClearCommit()
		return nil
	}
	return fmt.Errorf("unknown Release unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseMutation) ResetEdge(name string) error {
	switch name {
	case release.EdgeSubreleases:
		m.ResetSubreleases()
		return nil
	case release.EdgeDependencies:
		m.ResetDependencies()
		return nil
	case release.EdgeProject:
		m.ResetProject()
		return nil
	case release.EdgeCommit:
		m.ResetCommit()
		return nil
	case release.EdgeArtifacts:
		m.ResetArtifacts()
		return nil
	case release.EdgeChecks:
		m.ResetChecks()
		return nil
	case release.EdgeLog:
		m.ResetLog()
		return nil
	case release.EdgeCodeScans:
		m.ResetCodeScans()
		return nil
	case release.EdgeCveScans:
		m.ResetCveScans()
		return nil
	case release.EdgeLicenseScans:
		m.ResetLicenseScans()
		return nil
	case release.EdgeTestRuns:
		m.ResetTestRuns()
		return nil
	case release.EdgeComponents:
		m.ResetComponents()
		return nil
	}
	return fmt.Errorf("unknown Release edge %s", name)
}

// ReleaseCheckMutation represents an operation that mutates the ReleaseCheck nodes in the graph.
type ReleaseCheckMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_type          *releasecheck.Type
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	done           bool
	oldValue       func(context.Context) (*ReleaseCheck, error)
	predicates     []predicate.ReleaseCheck
}

var _ ent.Mutation = (*ReleaseCheckMutation)(nil)

// releasecheckOption allows management of the mutation configuration using functional options.
type releasecheckOption func(*ReleaseCheckMutation)

// newReleaseCheckMutation creates new mutation for the ReleaseCheck entity.
func newReleaseCheckMutation(c config, op Op, opts ...releasecheckOption) *ReleaseCheckMutation {
	m := &ReleaseCheckMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseCheck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseCheckID sets the ID field of the mutation.
func withReleaseCheckID(id int) releasecheckOption {
	return func(m *ReleaseCheckMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseCheck
		)
		m.oldValue = func(ctx context.Context) (*ReleaseCheck, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseCheck.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseCheck sets the old ReleaseCheck of the mutation.
func withReleaseCheck(node *ReleaseCheck) releasecheckOption {
	return func(m *ReleaseCheckMutation) {
		m.oldValue = func(context.Context) (*ReleaseCheck, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseCheckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseCheckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseCheckMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *ReleaseCheckMutation) SetType(r releasecheck.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReleaseCheckMutation) GetType() (r releasecheck.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReleaseCheck entity.
// If the ReleaseCheck object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseCheckMutation) OldType(ctx context.Context) (v releasecheck.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReleaseCheckMutation) ResetType() {
	m._type = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseCheckMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseCheckMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseCheckMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseCheckMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseCheckMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseCheckMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Op returns the operation name.
func (m *ReleaseCheckMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseCheck).
func (m *ReleaseCheckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseCheckMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, releasecheck.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseCheckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case releasecheck.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseCheckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case releasecheck.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ReleaseCheck field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseCheckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case releasecheck.FieldType:
		v, ok := value.(releasecheck.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ReleaseCheck field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseCheckMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseCheckMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseCheckMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseCheck numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseCheckMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseCheckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseCheckMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseCheck nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseCheckMutation) ResetField(name string) error {
	switch name {
	case releasecheck.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ReleaseCheck field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseCheckMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.release != nil {
		edges = append(edges, releasecheck.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseCheckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releasecheck.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseCheckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseCheckMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseCheckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrelease {
		edges = append(edges, releasecheck.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseCheckMutation) EdgeCleared(name string) bool {
	switch name {
	case releasecheck.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseCheckMutation) ClearEdge(name string) error {
	switch name {
	case releasecheck.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseCheck unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseCheckMutation) ResetEdge(name string) error {
	switch name {
	case releasecheck.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseCheck edge %s", name)
}

// ReleaseEntryMutation represents an operation that mutates the ReleaseEntry nodes in the graph.
type ReleaseEntryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_type               *releaseentry.Type
	time                *time.Time
	clearedFields       map[string]struct{}
	artifact            *int
	clearedartifact     bool
	code_scan           *int
	clearedcode_scan    bool
	test_run            *int
	clearedtest_run     bool
	cve_scan            *int
	clearedcve_scan     bool
	license_scan        *int
	clearedlicense_scan bool
	release             *int
	clearedrelease      bool
	done                bool
	oldValue            func(context.Context) (*ReleaseEntry, error)
	predicates          []predicate.ReleaseEntry
}

var _ ent.Mutation = (*ReleaseEntryMutation)(nil)

// releaseentryOption allows management of the mutation configuration using functional options.
type releaseentryOption func(*ReleaseEntryMutation)

// newReleaseEntryMutation creates new mutation for the ReleaseEntry entity.
func newReleaseEntryMutation(c config, op Op, opts ...releaseentryOption) *ReleaseEntryMutation {
	m := &ReleaseEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeReleaseEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseEntryID sets the ID field of the mutation.
func withReleaseEntryID(id int) releaseentryOption {
	return func(m *ReleaseEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *ReleaseEntry
		)
		m.oldValue = func(ctx context.Context) (*ReleaseEntry, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReleaseEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReleaseEntry sets the old ReleaseEntry of the mutation.
func withReleaseEntry(node *ReleaseEntry) releaseentryOption {
	return func(m *ReleaseEntryMutation) {
		m.oldValue = func(context.Context) (*ReleaseEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *ReleaseEntryMutation) SetType(r releaseentry.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReleaseEntryMutation) GetType() (r releaseentry.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReleaseEntry entity.
// If the ReleaseEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseEntryMutation) OldType(ctx context.Context) (v releaseentry.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReleaseEntryMutation) ResetType() {
	m._type = nil
}

// SetTime sets the "time" field.
func (m *ReleaseEntryMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *ReleaseEntryMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the ReleaseEntry entity.
// If the ReleaseEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseEntryMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *ReleaseEntryMutation) ResetTime() {
	m.time = nil
}

// SetArtifactID sets the "artifact" edge to the Artifact entity by id.
func (m *ReleaseEntryMutation) SetArtifactID(id int) {
	m.artifact = &id
}

// ClearArtifact clears the "artifact" edge to the Artifact entity.
func (m *ReleaseEntryMutation) ClearArtifact() {
	m.clearedartifact = true
}

// ArtifactCleared reports if the "artifact" edge to the Artifact entity was cleared.
func (m *ReleaseEntryMutation) ArtifactCleared() bool {
	return m.clearedartifact
}

// ArtifactID returns the "artifact" edge ID in the mutation.
func (m *ReleaseEntryMutation) ArtifactID() (id int, exists bool) {
	if m.artifact != nil {
		return *m.artifact, true
	}
	return
}

// ArtifactIDs returns the "artifact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArtifactID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) ArtifactIDs() (ids []int) {
	if id := m.artifact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArtifact resets all changes to the "artifact" edge.
func (m *ReleaseEntryMutation) ResetArtifact() {
	m.artifact = nil
	m.clearedartifact = false
}

// SetCodeScanID sets the "code_scan" edge to the CodeScan entity by id.
func (m *ReleaseEntryMutation) SetCodeScanID(id int) {
	m.code_scan = &id
}

// ClearCodeScan clears the "code_scan" edge to the CodeScan entity.
func (m *ReleaseEntryMutation) ClearCodeScan() {
	m.clearedcode_scan = true
}

// CodeScanCleared reports if the "code_scan" edge to the CodeScan entity was cleared.
func (m *ReleaseEntryMutation) CodeScanCleared() bool {
	return m.clearedcode_scan
}

// CodeScanID returns the "code_scan" edge ID in the mutation.
func (m *ReleaseEntryMutation) CodeScanID() (id int, exists bool) {
	if m.code_scan != nil {
		return *m.code_scan, true
	}
	return
}

// CodeScanIDs returns the "code_scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CodeScanID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) CodeScanIDs() (ids []int) {
	if id := m.code_scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCodeScan resets all changes to the "code_scan" edge.
func (m *ReleaseEntryMutation) ResetCodeScan() {
	m.code_scan = nil
	m.clearedcode_scan = false
}

// SetTestRunID sets the "test_run" edge to the TestRun entity by id.
func (m *ReleaseEntryMutation) SetTestRunID(id int) {
	m.test_run = &id
}

// ClearTestRun clears the "test_run" edge to the TestRun entity.
func (m *ReleaseEntryMutation) ClearTestRun() {
	m.clearedtest_run = true
}

// TestRunCleared reports if the "test_run" edge to the TestRun entity was cleared.
func (m *ReleaseEntryMutation) TestRunCleared() bool {
	return m.clearedtest_run
}

// TestRunID returns the "test_run" edge ID in the mutation.
func (m *ReleaseEntryMutation) TestRunID() (id int, exists bool) {
	if m.test_run != nil {
		return *m.test_run, true
	}
	return
}

// TestRunIDs returns the "test_run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestRunID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) TestRunIDs() (ids []int) {
	if id := m.test_run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestRun resets all changes to the "test_run" edge.
func (m *ReleaseEntryMutation) ResetTestRun() {
	m.test_run = nil
	m.clearedtest_run = false
}

// SetCveScanID sets the "cve_scan" edge to the CVEScan entity by id.
func (m *ReleaseEntryMutation) SetCveScanID(id int) {
	m.cve_scan = &id
}

// ClearCveScan clears the "cve_scan" edge to the CVEScan entity.
func (m *ReleaseEntryMutation) ClearCveScan() {
	m.clearedcve_scan = true
}

// CveScanCleared reports if the "cve_scan" edge to the CVEScan entity was cleared.
func (m *ReleaseEntryMutation) CveScanCleared() bool {
	return m.clearedcve_scan
}

// CveScanID returns the "cve_scan" edge ID in the mutation.
func (m *ReleaseEntryMutation) CveScanID() (id int, exists bool) {
	if m.cve_scan != nil {
		return *m.cve_scan, true
	}
	return
}

// CveScanIDs returns the "cve_scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CveScanID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) CveScanIDs() (ids []int) {
	if id := m.cve_scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCveScan resets all changes to the "cve_scan" edge.
func (m *ReleaseEntryMutation) ResetCveScan() {
	m.cve_scan = nil
	m.clearedcve_scan = false
}

// SetLicenseScanID sets the "license_scan" edge to the LicenseScan entity by id.
func (m *ReleaseEntryMutation) SetLicenseScanID(id int) {
	m.license_scan = &id
}

// ClearLicenseScan clears the "license_scan" edge to the LicenseScan entity.
func (m *ReleaseEntryMutation) ClearLicenseScan() {
	m.clearedlicense_scan = true
}

// LicenseScanCleared reports if the "license_scan" edge to the LicenseScan entity was cleared.
func (m *ReleaseEntryMutation) LicenseScanCleared() bool {
	return m.clearedlicense_scan
}

// LicenseScanID returns the "license_scan" edge ID in the mutation.
func (m *ReleaseEntryMutation) LicenseScanID() (id int, exists bool) {
	if m.license_scan != nil {
		return *m.license_scan, true
	}
	return
}

// LicenseScanIDs returns the "license_scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseScanID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) LicenseScanIDs() (ids []int) {
	if id := m.license_scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicenseScan resets all changes to the "license_scan" edge.
func (m *ReleaseEntryMutation) ResetLicenseScan() {
	m.license_scan = nil
	m.clearedlicense_scan = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ReleaseEntryMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ReleaseEntryMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ReleaseEntryMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ReleaseEntryMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ReleaseEntryMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ReleaseEntryMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Op returns the operation name.
func (m *ReleaseEntryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReleaseEntry).
func (m *ReleaseEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseEntryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, releaseentry.FieldType)
	}
	if m.time != nil {
		fields = append(fields, releaseentry.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case releaseentry.FieldType:
		return m.GetType()
	case releaseentry.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case releaseentry.FieldType:
		return m.OldType(ctx)
	case releaseentry.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case releaseentry.FieldType:
		v, ok := value.(releaseentry.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case releaseentry.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseEntryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseEntryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReleaseEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReleaseEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseEntryMutation) ResetField(name string) error {
	switch name {
	case releaseentry.FieldType:
		m.ResetType()
		return nil
	case releaseentry.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.artifact != nil {
		edges = append(edges, releaseentry.EdgeArtifact)
	}
	if m.code_scan != nil {
		edges = append(edges, releaseentry.EdgeCodeScan)
	}
	if m.test_run != nil {
		edges = append(edges, releaseentry.EdgeTestRun)
	}
	if m.cve_scan != nil {
		edges = append(edges, releaseentry.EdgeCveScan)
	}
	if m.license_scan != nil {
		edges = append(edges, releaseentry.EdgeLicenseScan)
	}
	if m.release != nil {
		edges = append(edges, releaseentry.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case releaseentry.EdgeArtifact:
		if id := m.artifact; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeCodeScan:
		if id := m.code_scan; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeTestRun:
		if id := m.test_run; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeCveScan:
		if id := m.cve_scan; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeLicenseScan:
		if id := m.license_scan; id != nil {
			return []ent.Value{*id}
		}
	case releaseentry.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedartifact {
		edges = append(edges, releaseentry.EdgeArtifact)
	}
	if m.clearedcode_scan {
		edges = append(edges, releaseentry.EdgeCodeScan)
	}
	if m.clearedtest_run {
		edges = append(edges, releaseentry.EdgeTestRun)
	}
	if m.clearedcve_scan {
		edges = append(edges, releaseentry.EdgeCveScan)
	}
	if m.clearedlicense_scan {
		edges = append(edges, releaseentry.EdgeLicenseScan)
	}
	if m.clearedrelease {
		edges = append(edges, releaseentry.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case releaseentry.EdgeArtifact:
		return m.clearedartifact
	case releaseentry.EdgeCodeScan:
		return m.clearedcode_scan
	case releaseentry.EdgeTestRun:
		return m.clearedtest_run
	case releaseentry.EdgeCveScan:
		return m.clearedcve_scan
	case releaseentry.EdgeLicenseScan:
		return m.clearedlicense_scan
	case releaseentry.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseEntryMutation) ClearEdge(name string) error {
	switch name {
	case releaseentry.EdgeArtifact:
		m.ClearArtifact()
		return nil
	case releaseentry.EdgeCodeScan:
		m.ClearCodeScan()
		return nil
	case releaseentry.EdgeTestRun:
		m.ClearTestRun()
		return nil
	case releaseentry.EdgeCveScan:
		m.ClearCveScan()
		return nil
	case releaseentry.EdgeLicenseScan:
		m.ClearLicenseScan()
		return nil
	case releaseentry.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseEntryMutation) ResetEdge(name string) error {
	switch name {
	case releaseentry.EdgeArtifact:
		m.ResetArtifact()
		return nil
	case releaseentry.EdgeCodeScan:
		m.ResetCodeScan()
		return nil
	case releaseentry.EdgeTestRun:
		m.ResetTestRun()
		return nil
	case releaseentry.EdgeCveScan:
		m.ResetCveScan()
		return nil
	case releaseentry.EdgeLicenseScan:
		m.ResetLicenseScan()
		return nil
	case releaseentry.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown ReleaseEntry edge %s", name)
}

// RepoMutation represents an operation that mutates the Repo nodes in the graph.
type RepoMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	project          *int
	clearedproject   bool
	commits          map[int]struct{}
	removedcommits   map[int]struct{}
	clearedcommits   bool
	cve_rules        map[int]struct{}
	removedcve_rules map[int]struct{}
	clearedcve_rules bool
	done             bool
	oldValue         func(context.Context) (*Repo, error)
	predicates       []predicate.Repo
}

var _ ent.Mutation = (*RepoMutation)(nil)

// repoOption allows management of the mutation configuration using functional options.
type repoOption func(*RepoMutation)

// newRepoMutation creates new mutation for the Repo entity.
func newRepoMutation(c config, op Op, opts ...repoOption) *RepoMutation {
	m := &RepoMutation{
		config:        c,
		op:            op,
		typ:           TypeRepo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepoID sets the ID field of the mutation.
func withRepoID(id int) repoOption {
	return func(m *RepoMutation) {
		var (
			err   error
			once  sync.Once
			value *Repo
		)
		m.oldValue = func(ctx context.Context) (*Repo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepo sets the old Repo of the mutation.
func withRepo(node *Repo) repoOption {
	return func(m *RepoMutation) {
		m.oldValue = func(context.Context) (*Repo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *RepoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepoMutation) ResetName() {
	m.name = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *RepoMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RepoMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RepoMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *RepoMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RepoMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RepoMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddCommitIDs adds the "commits" edge to the GitCommit entity by ids.
func (m *RepoMutation) AddCommitIDs(ids ...int) {
	if m.commits == nil {
		m.commits = make(map[int]struct{})
	}
	for i := range ids {
		m.commits[ids[i]] = struct{}{}
	}
}

// ClearCommits clears the "commits" edge to the GitCommit entity.
func (m *RepoMutation) ClearCommits() {
	m.clearedcommits = true
}

// CommitsCleared reports if the "commits" edge to the GitCommit entity was cleared.
func (m *RepoMutation) CommitsCleared() bool {
	return m.clearedcommits
}

// RemoveCommitIDs removes the "commits" edge to the GitCommit entity by IDs.
func (m *RepoMutation) RemoveCommitIDs(ids ...int) {
	if m.removedcommits == nil {
		m.removedcommits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.commits, ids[i])
		m.removedcommits[ids[i]] = struct{}{}
	}
}

// RemovedCommits returns the removed IDs of the "commits" edge to the GitCommit entity.
func (m *RepoMutation) RemovedCommitsIDs() (ids []int) {
	for id := range m.removedcommits {
		ids = append(ids, id)
	}
	return
}

// CommitsIDs returns the "commits" edge IDs in the mutation.
func (m *RepoMutation) CommitsIDs() (ids []int) {
	for id := range m.commits {
		ids = append(ids, id)
	}
	return
}

// ResetCommits resets all changes to the "commits" edge.
func (m *RepoMutation) ResetCommits() {
	m.commits = nil
	m.clearedcommits = false
	m.removedcommits = nil
}

// AddCveRuleIDs adds the "cve_rules" edge to the CVERule entity by ids.
func (m *RepoMutation) AddCveRuleIDs(ids ...int) {
	if m.cve_rules == nil {
		m.cve_rules = make(map[int]struct{})
	}
	for i := range ids {
		m.cve_rules[ids[i]] = struct{}{}
	}
}

// ClearCveRules clears the "cve_rules" edge to the CVERule entity.
func (m *RepoMutation) ClearCveRules() {
	m.clearedcve_rules = true
}

// CveRulesCleared reports if the "cve_rules" edge to the CVERule entity was cleared.
func (m *RepoMutation) CveRulesCleared() bool {
	return m.clearedcve_rules
}

// RemoveCveRuleIDs removes the "cve_rules" edge to the CVERule entity by IDs.
func (m *RepoMutation) RemoveCveRuleIDs(ids ...int) {
	if m.removedcve_rules == nil {
		m.removedcve_rules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cve_rules, ids[i])
		m.removedcve_rules[ids[i]] = struct{}{}
	}
}

// RemovedCveRules returns the removed IDs of the "cve_rules" edge to the CVERule entity.
func (m *RepoMutation) RemovedCveRulesIDs() (ids []int) {
	for id := range m.removedcve_rules {
		ids = append(ids, id)
	}
	return
}

// CveRulesIDs returns the "cve_rules" edge IDs in the mutation.
func (m *RepoMutation) CveRulesIDs() (ids []int) {
	for id := range m.cve_rules {
		ids = append(ids, id)
	}
	return
}

// ResetCveRules resets all changes to the "cve_rules" edge.
func (m *RepoMutation) ResetCveRules() {
	m.cve_rules = nil
	m.clearedcve_rules = false
	m.removedcve_rules = nil
}

// Op returns the operation name.
func (m *RepoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repo).
func (m *RepoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepoMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, repo.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repo.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repo.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Repo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepoMutation) ResetField(name string) error {
	switch name {
	case repo.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, repo.EdgeProject)
	}
	if m.commits != nil {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.cve_rules != nil {
		edges = append(edges, repo.EdgeCveRules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case repo.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.commits))
		for id := range m.commits {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeCveRules:
		ids := make([]ent.Value, 0, len(m.cve_rules))
		for id := range m.cve_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcommits != nil {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.removedcve_rules != nil {
		edges = append(edges, repo.EdgeCveRules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeCommits:
		ids := make([]ent.Value, 0, len(m.removedcommits))
		for id := range m.removedcommits {
			ids = append(ids, id)
		}
		return ids
	case repo.EdgeCveRules:
		ids := make([]ent.Value, 0, len(m.removedcve_rules))
		for id := range m.removedcve_rules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, repo.EdgeProject)
	}
	if m.clearedcommits {
		edges = append(edges, repo.EdgeCommits)
	}
	if m.clearedcve_rules {
		edges = append(edges, repo.EdgeCveRules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepoMutation) EdgeCleared(name string) bool {
	switch name {
	case repo.EdgeProject:
		return m.clearedproject
	case repo.EdgeCommits:
		return m.clearedcommits
	case repo.EdgeCveRules:
		return m.clearedcve_rules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepoMutation) ClearEdge(name string) error {
	switch name {
	case repo.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Repo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepoMutation) ResetEdge(name string) error {
	switch name {
	case repo.EdgeProject:
		m.ResetProject()
		return nil
	case repo.EdgeCommits:
		m.ResetCommits()
		return nil
	case repo.EdgeCveRules:
		m.ResetCveRules()
		return nil
	}
	return fmt.Errorf("unknown Repo edge %s", name)
}

// TestCaseMutation represents an operation that mutates the TestCase nodes in the graph.
type TestCaseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	result        *bool
	message       *string
	elapsed       *float64
	addelapsed    *float64
	clearedFields map[string]struct{}
	run           *int
	clearedrun    bool
	done          bool
	oldValue      func(context.Context) (*TestCase, error)
	predicates    []predicate.TestCase
}

var _ ent.Mutation = (*TestCaseMutation)(nil)

// testcaseOption allows management of the mutation configuration using functional options.
type testcaseOption func(*TestCaseMutation)

// newTestCaseMutation creates new mutation for the TestCase entity.
func newTestCaseMutation(c config, op Op, opts ...testcaseOption) *TestCaseMutation {
	m := &TestCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTestCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestCaseID sets the ID field of the mutation.
func withTestCaseID(id int) testcaseOption {
	return func(m *TestCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *TestCase
		)
		m.oldValue = func(ctx context.Context) (*TestCase, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestCase sets the old TestCase of the mutation.
func withTestCase(node *TestCase) testcaseOption {
	return func(m *TestCaseMutation) {
		m.oldValue = func(context.Context) (*TestCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestCaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *TestCaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestCaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestCaseMutation) ResetName() {
	m.name = nil
}

// SetResult sets the "result" field.
func (m *TestCaseMutation) SetResult(b bool) {
	m.result = &b
}

// Result returns the value of the "result" field in the mutation.
func (m *TestCaseMutation) Result() (r bool, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldResult(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *TestCaseMutation) ResetResult() {
	m.result = nil
}

// SetMessage sets the "message" field.
func (m *TestCaseMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TestCaseMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *TestCaseMutation) ResetMessage() {
	m.message = nil
}

// SetElapsed sets the "elapsed" field.
func (m *TestCaseMutation) SetElapsed(f float64) {
	m.elapsed = &f
	m.addelapsed = nil
}

// Elapsed returns the value of the "elapsed" field in the mutation.
func (m *TestCaseMutation) Elapsed() (r float64, exists bool) {
	v := m.elapsed
	if v == nil {
		return
	}
	return *v, true
}

// OldElapsed returns the old "elapsed" field's value of the TestCase entity.
// If the TestCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestCaseMutation) OldElapsed(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldElapsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldElapsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElapsed: %w", err)
	}
	return oldValue.Elapsed, nil
}

// AddElapsed adds f to the "elapsed" field.
func (m *TestCaseMutation) AddElapsed(f float64) {
	if m.addelapsed != nil {
		*m.addelapsed += f
	} else {
		m.addelapsed = &f
	}
}

// AddedElapsed returns the value that was added to the "elapsed" field in this mutation.
func (m *TestCaseMutation) AddedElapsed() (r float64, exists bool) {
	v := m.addelapsed
	if v == nil {
		return
	}
	return *v, true
}

// ResetElapsed resets all changes to the "elapsed" field.
func (m *TestCaseMutation) ResetElapsed() {
	m.elapsed = nil
	m.addelapsed = nil
}

// SetRunID sets the "run" edge to the TestRun entity by id.
func (m *TestCaseMutation) SetRunID(id int) {
	m.run = &id
}

// ClearRun clears the "run" edge to the TestRun entity.
func (m *TestCaseMutation) ClearRun() {
	m.clearedrun = true
}

// RunCleared reports if the "run" edge to the TestRun entity was cleared.
func (m *TestCaseMutation) RunCleared() bool {
	return m.clearedrun
}

// RunID returns the "run" edge ID in the mutation.
func (m *TestCaseMutation) RunID() (id int, exists bool) {
	if m.run != nil {
		return *m.run, true
	}
	return
}

// RunIDs returns the "run" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RunID instead. It exists only for internal usage by the builders.
func (m *TestCaseMutation) RunIDs() (ids []int) {
	if id := m.run; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRun resets all changes to the "run" edge.
func (m *TestCaseMutation) ResetRun() {
	m.run = nil
	m.clearedrun = false
}

// Op returns the operation name.
func (m *TestCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestCase).
func (m *TestCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestCaseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, testcase.FieldName)
	}
	if m.result != nil {
		fields = append(fields, testcase.FieldResult)
	}
	if m.message != nil {
		fields = append(fields, testcase.FieldMessage)
	}
	if m.elapsed != nil {
		fields = append(fields, testcase.FieldElapsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldName:
		return m.Name()
	case testcase.FieldResult:
		return m.Result()
	case testcase.FieldMessage:
		return m.Message()
	case testcase.FieldElapsed:
		return m.Elapsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase.FieldName:
		return m.OldName(ctx)
	case testcase.FieldResult:
		return m.OldResult(ctx)
	case testcase.FieldMessage:
		return m.OldMessage(ctx)
	case testcase.FieldElapsed:
		return m.OldElapsed(ctx)
	}
	return nil, fmt.Errorf("unknown TestCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testcase.FieldResult:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case testcase.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case testcase.FieldElapsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElapsed(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestCaseMutation) AddedFields() []string {
	var fields []string
	if m.addelapsed != nil {
		fields = append(fields, testcase.FieldElapsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldElapsed:
		return m.AddedElapsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldElapsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElapsed(v)
		return nil
	}
	return fmt.Errorf("unknown TestCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestCaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestCaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TestCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestCaseMutation) ResetField(name string) error {
	switch name {
	case testcase.FieldName:
		m.ResetName()
		return nil
	case testcase.FieldResult:
		m.ResetResult()
		return nil
	case testcase.FieldMessage:
		m.ResetMessage()
		return nil
	case testcase.FieldElapsed:
		m.ResetElapsed()
		return nil
	}
	return fmt.Errorf("unknown TestCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.run != nil {
		edges = append(edges, testcase.EdgeRun)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestCaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testcase.EdgeRun:
		if id := m.run; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestCaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrun {
		edges = append(edges, testcase.EdgeRun)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestCaseMutation) EdgeCleared(name string) bool {
	switch name {
	case testcase.EdgeRun:
		return m.clearedrun
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestCaseMutation) ClearEdge(name string) error {
	switch name {
	case testcase.EdgeRun:
		m.ClearRun()
		return nil
	}
	return fmt.Errorf("unknown TestCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestCaseMutation) ResetEdge(name string) error {
	switch name {
	case testcase.EdgeRun:
		m.ResetRun()
		return nil
	}
	return fmt.Errorf("unknown TestCase edge %s", name)
}

// TestRunMutation represents an operation that mutates the TestRun nodes in the graph.
type TestRunMutation struct {
	config
	op             Op
	typ            string
	id             *int
	tool           *string
	clearedFields  map[string]struct{}
	release        *int
	clearedrelease bool
	entry          *int
	clearedentry   bool
	tests          map[int]struct{}
	removedtests   map[int]struct{}
	clearedtests   bool
	done           bool
	oldValue       func(context.Context) (*TestRun, error)
	predicates     []predicate.TestRun
}

var _ ent.Mutation = (*TestRunMutation)(nil)

// testrunOption allows management of the mutation configuration using functional options.
type testrunOption func(*TestRunMutation)

// newTestRunMutation creates new mutation for the TestRun entity.
func newTestRunMutation(c config, op Op, opts ...testrunOption) *TestRunMutation {
	m := &TestRunMutation{
		config:        c,
		op:            op,
		typ:           TypeTestRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestRunID sets the ID field of the mutation.
func withTestRunID(id int) testrunOption {
	return func(m *TestRunMutation) {
		var (
			err   error
			once  sync.Once
			value *TestRun
		)
		m.oldValue = func(ctx context.Context) (*TestRun, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestRun sets the old TestRun of the mutation.
func withTestRun(node *TestRun) testrunOption {
	return func(m *TestRunMutation) {
		m.oldValue = func(context.Context) (*TestRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestRunMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTool sets the "tool" field.
func (m *TestRunMutation) SetTool(s string) {
	m.tool = &s
}

// Tool returns the value of the "tool" field in the mutation.
func (m *TestRunMutation) Tool() (r string, exists bool) {
	v := m.tool
	if v == nil {
		return
	}
	return *v, true
}

// OldTool returns the old "tool" field's value of the TestRun entity.
// If the TestRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestRunMutation) OldTool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTool: %w", err)
	}
	return oldValue.Tool, nil
}

// ResetTool resets all changes to the "tool" field.
func (m *TestRunMutation) ResetTool() {
	m.tool = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *TestRunMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *TestRunMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *TestRunMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *TestRunMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *TestRunMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *TestRunMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// SetEntryID sets the "entry" edge to the ReleaseEntry entity by id.
func (m *TestRunMutation) SetEntryID(id int) {
	m.entry = &id
}

// ClearEntry clears the "entry" edge to the ReleaseEntry entity.
func (m *TestRunMutation) ClearEntry() {
	m.clearedentry = true
}

// EntryCleared reports if the "entry" edge to the ReleaseEntry entity was cleared.
func (m *TestRunMutation) EntryCleared() bool {
	return m.clearedentry
}

// EntryID returns the "entry" edge ID in the mutation.
func (m *TestRunMutation) EntryID() (id int, exists bool) {
	if m.entry != nil {
		return *m.entry, true
	}
	return
}

// EntryIDs returns the "entry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntryID instead. It exists only for internal usage by the builders.
func (m *TestRunMutation) EntryIDs() (ids []int) {
	if id := m.entry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntry resets all changes to the "entry" edge.
func (m *TestRunMutation) ResetEntry() {
	m.entry = nil
	m.clearedentry = false
}

// AddTestIDs adds the "tests" edge to the TestCase entity by ids.
func (m *TestRunMutation) AddTestIDs(ids ...int) {
	if m.tests == nil {
		m.tests = make(map[int]struct{})
	}
	for i := range ids {
		m.tests[ids[i]] = struct{}{}
	}
}

// ClearTests clears the "tests" edge to the TestCase entity.
func (m *TestRunMutation) ClearTests() {
	m.clearedtests = true
}

// TestsCleared reports if the "tests" edge to the TestCase entity was cleared.
func (m *TestRunMutation) TestsCleared() bool {
	return m.clearedtests
}

// RemoveTestIDs removes the "tests" edge to the TestCase entity by IDs.
func (m *TestRunMutation) RemoveTestIDs(ids ...int) {
	if m.removedtests == nil {
		m.removedtests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tests, ids[i])
		m.removedtests[ids[i]] = struct{}{}
	}
}

// RemovedTests returns the removed IDs of the "tests" edge to the TestCase entity.
func (m *TestRunMutation) RemovedTestsIDs() (ids []int) {
	for id := range m.removedtests {
		ids = append(ids, id)
	}
	return
}

// TestsIDs returns the "tests" edge IDs in the mutation.
func (m *TestRunMutation) TestsIDs() (ids []int) {
	for id := range m.tests {
		ids = append(ids, id)
	}
	return
}

// ResetTests resets all changes to the "tests" edge.
func (m *TestRunMutation) ResetTests() {
	m.tests = nil
	m.clearedtests = false
	m.removedtests = nil
}

// Op returns the operation name.
func (m *TestRunMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TestRun).
func (m *TestRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestRunMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tool != nil {
		fields = append(fields, testrun.FieldTool)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testrun.FieldTool:
		return m.Tool()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testrun.FieldTool:
		return m.OldTool(ctx)
	}
	return nil, fmt.Errorf("unknown TestRun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testrun.FieldTool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTool(v)
		return nil
	}
	return fmt.Errorf("unknown TestRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestRunMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestRunMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TestRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestRunMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestRunMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TestRun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestRunMutation) ResetField(name string) error {
	switch name {
	case testrun.FieldTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown TestRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.release != nil {
		edges = append(edges, testrun.EdgeRelease)
	}
	if m.entry != nil {
		edges = append(edges, testrun.EdgeEntry)
	}
	if m.tests != nil {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestRunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testrun.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case testrun.EdgeEntry:
		if id := m.entry; id != nil {
			return []ent.Value{*id}
		}
	case testrun.EdgeTests:
		ids := make([]ent.Value, 0, len(m.tests))
		for id := range m.tests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtests != nil {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestRunMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testrun.EdgeTests:
		ids := make([]ent.Value, 0, len(m.removedtests))
		for id := range m.removedtests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelease {
		edges = append(edges, testrun.EdgeRelease)
	}
	if m.clearedentry {
		edges = append(edges, testrun.EdgeEntry)
	}
	if m.clearedtests {
		edges = append(edges, testrun.EdgeTests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestRunMutation) EdgeCleared(name string) bool {
	switch name {
	case testrun.EdgeRelease:
		return m.clearedrelease
	case testrun.EdgeEntry:
		return m.clearedentry
	case testrun.EdgeTests:
		return m.clearedtests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestRunMutation) ClearEdge(name string) error {
	switch name {
	case testrun.EdgeRelease:
		m.ClearRelease()
		return nil
	case testrun.EdgeEntry:
		m.ClearEntry()
		return nil
	}
	return fmt.Errorf("unknown TestRun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestRunMutation) ResetEdge(name string) error {
	switch name {
	case testrun.EdgeRelease:
		m.ResetRelease()
		return nil
	case testrun.EdgeEntry:
		m.ResetEntry()
		return nil
	case testrun.EdgeTests:
		m.ResetTests()
		return nil
	}
	return fmt.Errorf("unknown TestRun edge %s", name)
}

// VulnerabilityMutation represents an operation that mutates the Vulnerability nodes in the graph.
type VulnerabilityMutation struct {
	config
	op               Op
	typ              string
	id               *int
	clearedFields    map[string]struct{}
	cve              *int
	clearedcve       bool
	scan             *int
	clearedscan      bool
	component        *int
	clearedcomponent bool
	done             bool
	oldValue         func(context.Context) (*Vulnerability, error)
	predicates       []predicate.Vulnerability
}

var _ ent.Mutation = (*VulnerabilityMutation)(nil)

// vulnerabilityOption allows management of the mutation configuration using functional options.
type vulnerabilityOption func(*VulnerabilityMutation)

// newVulnerabilityMutation creates new mutation for the Vulnerability entity.
func newVulnerabilityMutation(c config, op Op, opts ...vulnerabilityOption) *VulnerabilityMutation {
	m := &VulnerabilityMutation{
		config:        c,
		op:            op,
		typ:           TypeVulnerability,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVulnerabilityID sets the ID field of the mutation.
func withVulnerabilityID(id int) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		var (
			err   error
			once  sync.Once
			value *Vulnerability
		)
		m.oldValue = func(ctx context.Context) (*Vulnerability, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vulnerability.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVulnerability sets the old Vulnerability of the mutation.
func withVulnerability(node *Vulnerability) vulnerabilityOption {
	return func(m *VulnerabilityMutation) {
		m.oldValue = func(context.Context) (*Vulnerability, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VulnerabilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VulnerabilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VulnerabilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCveID sets the "cve" edge to the CVE entity by id.
func (m *VulnerabilityMutation) SetCveID(id int) {
	m.cve = &id
}

// ClearCve clears the "cve" edge to the CVE entity.
func (m *VulnerabilityMutation) ClearCve() {
	m.clearedcve = true
}

// CveCleared reports if the "cve" edge to the CVE entity was cleared.
func (m *VulnerabilityMutation) CveCleared() bool {
	return m.clearedcve
}

// CveID returns the "cve" edge ID in the mutation.
func (m *VulnerabilityMutation) CveID() (id int, exists bool) {
	if m.cve != nil {
		return *m.cve, true
	}
	return
}

// CveIDs returns the "cve" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CveID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityMutation) CveIDs() (ids []int) {
	if id := m.cve; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCve resets all changes to the "cve" edge.
func (m *VulnerabilityMutation) ResetCve() {
	m.cve = nil
	m.clearedcve = false
}

// SetScanID sets the "scan" edge to the CVEScan entity by id.
func (m *VulnerabilityMutation) SetScanID(id int) {
	m.scan = &id
}

// ClearScan clears the "scan" edge to the CVEScan entity.
func (m *VulnerabilityMutation) ClearScan() {
	m.clearedscan = true
}

// ScanCleared reports if the "scan" edge to the CVEScan entity was cleared.
func (m *VulnerabilityMutation) ScanCleared() bool {
	return m.clearedscan
}

// ScanID returns the "scan" edge ID in the mutation.
func (m *VulnerabilityMutation) ScanID() (id int, exists bool) {
	if m.scan != nil {
		return *m.scan, true
	}
	return
}

// ScanIDs returns the "scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScanID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityMutation) ScanIDs() (ids []int) {
	if id := m.scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *VulnerabilityMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
}

// SetComponentID sets the "component" edge to the Component entity by id.
func (m *VulnerabilityMutation) SetComponentID(id int) {
	m.component = &id
}

// ClearComponent clears the "component" edge to the Component entity.
func (m *VulnerabilityMutation) ClearComponent() {
	m.clearedcomponent = true
}

// ComponentCleared reports if the "component" edge to the Component entity was cleared.
func (m *VulnerabilityMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentID returns the "component" edge ID in the mutation.
func (m *VulnerabilityMutation) ComponentID() (id int, exists bool) {
	if m.component != nil {
		return *m.component, true
	}
	return
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *VulnerabilityMutation) ComponentIDs() (ids []int) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *VulnerabilityMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// Op returns the operation name.
func (m *VulnerabilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vulnerability).
func (m *VulnerabilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VulnerabilityMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VulnerabilityMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VulnerabilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Vulnerability field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VulnerabilityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VulnerabilityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VulnerabilityMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Vulnerability numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VulnerabilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VulnerabilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vulnerability nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VulnerabilityMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Vulnerability field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VulnerabilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cve != nil {
		edges = append(edges, vulnerability.EdgeCve)
	}
	if m.scan != nil {
		edges = append(edges, vulnerability.EdgeScan)
	}
	if m.component != nil {
		edges = append(edges, vulnerability.EdgeComponent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VulnerabilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vulnerability.EdgeCve:
		if id := m.cve; id != nil {
			return []ent.Value{*id}
		}
	case vulnerability.EdgeScan:
		if id := m.scan; id != nil {
			return []ent.Value{*id}
		}
	case vulnerability.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VulnerabilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VulnerabilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VulnerabilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcve {
		edges = append(edges, vulnerability.EdgeCve)
	}
	if m.clearedscan {
		edges = append(edges, vulnerability.EdgeScan)
	}
	if m.clearedcomponent {
		edges = append(edges, vulnerability.EdgeComponent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VulnerabilityMutation) EdgeCleared(name string) bool {
	switch name {
	case vulnerability.EdgeCve:
		return m.clearedcve
	case vulnerability.EdgeScan:
		return m.clearedscan
	case vulnerability.EdgeComponent:
		return m.clearedcomponent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VulnerabilityMutation) ClearEdge(name string) error {
	switch name {
	case vulnerability.EdgeCve:
		m.ClearCve()
		return nil
	case vulnerability.EdgeScan:
		m.ClearScan()
		return nil
	case vulnerability.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VulnerabilityMutation) ResetEdge(name string) error {
	switch name {
	case vulnerability.EdgeCve:
		m.ResetCve()
		return nil
	case vulnerability.EdgeScan:
		m.ResetScan()
		return nil
	case vulnerability.EdgeComponent:
		m.ResetComponent()
		return nil
	}
	return fmt.Errorf("unknown Vulnerability edge %s", name)
}
