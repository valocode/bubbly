// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/valocode/bubbly/ent/migrate"

	"github.com/valocode/bubbly/ent/adapter"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/event"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/organization"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecomponent"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/releaselicense"
	"github.com/valocode/bubbly/ent/releasepolicy"
	"github.com/valocode/bubbly/ent/releasepolicyviolation"
	"github.com/valocode/bubbly/ent/releasevulnerability"
	"github.com/valocode/bubbly/ent/repository"
	"github.com/valocode/bubbly/ent/spdxlicense"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/valocode/bubbly/ent/vulnerabilityreview"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Adapter is the client for interacting with the Adapter builders.
	Adapter *AdapterClient
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// CodeIssue is the client for interacting with the CodeIssue builders.
	CodeIssue *CodeIssueClient
	// CodeScan is the client for interacting with the CodeScan builders.
	CodeScan *CodeScanClient
	// Component is the client for interacting with the Component builders.
	Component *ComponentClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// GitCommit is the client for interacting with the GitCommit builders.
	GitCommit *GitCommitClient
	// License is the client for interacting with the License builders.
	License *LicenseClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Release is the client for interacting with the Release builders.
	Release *ReleaseClient
	// ReleaseComponent is the client for interacting with the ReleaseComponent builders.
	ReleaseComponent *ReleaseComponentClient
	// ReleaseEntry is the client for interacting with the ReleaseEntry builders.
	ReleaseEntry *ReleaseEntryClient
	// ReleaseLicense is the client for interacting with the ReleaseLicense builders.
	ReleaseLicense *ReleaseLicenseClient
	// ReleasePolicy is the client for interacting with the ReleasePolicy builders.
	ReleasePolicy *ReleasePolicyClient
	// ReleasePolicyViolation is the client for interacting with the ReleasePolicyViolation builders.
	ReleasePolicyViolation *ReleasePolicyViolationClient
	// ReleaseVulnerability is the client for interacting with the ReleaseVulnerability builders.
	ReleaseVulnerability *ReleaseVulnerabilityClient
	// Repository is the client for interacting with the Repository builders.
	Repository *RepositoryClient
	// SPDXLicense is the client for interacting with the SPDXLicense builders.
	SPDXLicense *SPDXLicenseClient
	// TestCase is the client for interacting with the TestCase builders.
	TestCase *TestCaseClient
	// TestRun is the client for interacting with the TestRun builders.
	TestRun *TestRunClient
	// Vulnerability is the client for interacting with the Vulnerability builders.
	Vulnerability *VulnerabilityClient
	// VulnerabilityReview is the client for interacting with the VulnerabilityReview builders.
	VulnerabilityReview *VulnerabilityReviewClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Adapter = NewAdapterClient(c.config)
	c.Artifact = NewArtifactClient(c.config)
	c.CodeIssue = NewCodeIssueClient(c.config)
	c.CodeScan = NewCodeScanClient(c.config)
	c.Component = NewComponentClient(c.config)
	c.Event = NewEventClient(c.config)
	c.GitCommit = NewGitCommitClient(c.config)
	c.License = NewLicenseClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Release = NewReleaseClient(c.config)
	c.ReleaseComponent = NewReleaseComponentClient(c.config)
	c.ReleaseEntry = NewReleaseEntryClient(c.config)
	c.ReleaseLicense = NewReleaseLicenseClient(c.config)
	c.ReleasePolicy = NewReleasePolicyClient(c.config)
	c.ReleasePolicyViolation = NewReleasePolicyViolationClient(c.config)
	c.ReleaseVulnerability = NewReleaseVulnerabilityClient(c.config)
	c.Repository = NewRepositoryClient(c.config)
	c.SPDXLicense = NewSPDXLicenseClient(c.config)
	c.TestCase = NewTestCaseClient(c.config)
	c.TestRun = NewTestRunClient(c.config)
	c.Vulnerability = NewVulnerabilityClient(c.config)
	c.VulnerabilityReview = NewVulnerabilityReviewClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Adapter:                NewAdapterClient(cfg),
		Artifact:               NewArtifactClient(cfg),
		CodeIssue:              NewCodeIssueClient(cfg),
		CodeScan:               NewCodeScanClient(cfg),
		Component:              NewComponentClient(cfg),
		Event:                  NewEventClient(cfg),
		GitCommit:              NewGitCommitClient(cfg),
		License:                NewLicenseClient(cfg),
		Organization:           NewOrganizationClient(cfg),
		Project:                NewProjectClient(cfg),
		Release:                NewReleaseClient(cfg),
		ReleaseComponent:       NewReleaseComponentClient(cfg),
		ReleaseEntry:           NewReleaseEntryClient(cfg),
		ReleaseLicense:         NewReleaseLicenseClient(cfg),
		ReleasePolicy:          NewReleasePolicyClient(cfg),
		ReleasePolicyViolation: NewReleasePolicyViolationClient(cfg),
		ReleaseVulnerability:   NewReleaseVulnerabilityClient(cfg),
		Repository:             NewRepositoryClient(cfg),
		SPDXLicense:            NewSPDXLicenseClient(cfg),
		TestCase:               NewTestCaseClient(cfg),
		TestRun:                NewTestRunClient(cfg),
		Vulnerability:          NewVulnerabilityClient(cfg),
		VulnerabilityReview:    NewVulnerabilityReviewClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:                 cfg,
		Adapter:                NewAdapterClient(cfg),
		Artifact:               NewArtifactClient(cfg),
		CodeIssue:              NewCodeIssueClient(cfg),
		CodeScan:               NewCodeScanClient(cfg),
		Component:              NewComponentClient(cfg),
		Event:                  NewEventClient(cfg),
		GitCommit:              NewGitCommitClient(cfg),
		License:                NewLicenseClient(cfg),
		Organization:           NewOrganizationClient(cfg),
		Project:                NewProjectClient(cfg),
		Release:                NewReleaseClient(cfg),
		ReleaseComponent:       NewReleaseComponentClient(cfg),
		ReleaseEntry:           NewReleaseEntryClient(cfg),
		ReleaseLicense:         NewReleaseLicenseClient(cfg),
		ReleasePolicy:          NewReleasePolicyClient(cfg),
		ReleasePolicyViolation: NewReleasePolicyViolationClient(cfg),
		ReleaseVulnerability:   NewReleaseVulnerabilityClient(cfg),
		Repository:             NewRepositoryClient(cfg),
		SPDXLicense:            NewSPDXLicenseClient(cfg),
		TestCase:               NewTestCaseClient(cfg),
		TestRun:                NewTestRunClient(cfg),
		Vulnerability:          NewVulnerabilityClient(cfg),
		VulnerabilityReview:    NewVulnerabilityReviewClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Adapter.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Adapter.Use(hooks...)
	c.Artifact.Use(hooks...)
	c.CodeIssue.Use(hooks...)
	c.CodeScan.Use(hooks...)
	c.Component.Use(hooks...)
	c.Event.Use(hooks...)
	c.GitCommit.Use(hooks...)
	c.License.Use(hooks...)
	c.Organization.Use(hooks...)
	c.Project.Use(hooks...)
	c.Release.Use(hooks...)
	c.ReleaseComponent.Use(hooks...)
	c.ReleaseEntry.Use(hooks...)
	c.ReleaseLicense.Use(hooks...)
	c.ReleasePolicy.Use(hooks...)
	c.ReleasePolicyViolation.Use(hooks...)
	c.ReleaseVulnerability.Use(hooks...)
	c.Repository.Use(hooks...)
	c.SPDXLicense.Use(hooks...)
	c.TestCase.Use(hooks...)
	c.TestRun.Use(hooks...)
	c.Vulnerability.Use(hooks...)
	c.VulnerabilityReview.Use(hooks...)
}

// AdapterClient is a client for the Adapter schema.
type AdapterClient struct {
	config
}

// NewAdapterClient returns a client for the Adapter from the given config.
func NewAdapterClient(c config) *AdapterClient {
	return &AdapterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adapter.Hooks(f(g(h())))`.
func (c *AdapterClient) Use(hooks ...Hook) {
	c.hooks.Adapter = append(c.hooks.Adapter, hooks...)
}

// Create returns a create builder for Adapter.
func (c *AdapterClient) Create() *AdapterCreate {
	mutation := newAdapterMutation(c.config, OpCreate)
	return &AdapterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Adapter entities.
func (c *AdapterClient) CreateBulk(builders ...*AdapterCreate) *AdapterCreateBulk {
	return &AdapterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Adapter.
func (c *AdapterClient) Update() *AdapterUpdate {
	mutation := newAdapterMutation(c.config, OpUpdate)
	return &AdapterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdapterClient) UpdateOne(a *Adapter) *AdapterUpdateOne {
	mutation := newAdapterMutation(c.config, OpUpdateOne, withAdapter(a))
	return &AdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdapterClient) UpdateOneID(id int) *AdapterUpdateOne {
	mutation := newAdapterMutation(c.config, OpUpdateOne, withAdapterID(id))
	return &AdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Adapter.
func (c *AdapterClient) Delete() *AdapterDelete {
	mutation := newAdapterMutation(c.config, OpDelete)
	return &AdapterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AdapterClient) DeleteOne(a *Adapter) *AdapterDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AdapterClient) DeleteOneID(id int) *AdapterDeleteOne {
	builder := c.Delete().Where(adapter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdapterDeleteOne{builder}
}

// Query returns a query builder for Adapter.
func (c *AdapterClient) Query() *AdapterQuery {
	return &AdapterQuery{
		config: c.config,
	}
}

// Get returns a Adapter entity by its id.
func (c *AdapterClient) Get(ctx context.Context, id int) (*Adapter, error) {
	return c.Query().Where(adapter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdapterClient) GetX(ctx context.Context, id int) *Adapter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Adapter.
func (c *AdapterClient) QueryOwner(a *Adapter) *OrganizationQuery {
	query := &OrganizationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adapter.Table, adapter.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, adapter.OwnerTable, adapter.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AdapterClient) Hooks() []Hook {
	return c.hooks.Adapter
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Create returns a create builder for Artifact.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a Artifact.
func (c *ArtifactClient) QueryRelease(a *Artifact) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, artifact.ReleaseTable, artifact.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a Artifact.
func (c *ArtifactClient) QueryEntry(a *Artifact) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, artifact.EntryTable, artifact.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	hooks := c.hooks.Artifact
	return append(hooks[:len(hooks):len(hooks)], artifact.Hooks[:]...)
}

// CodeIssueClient is a client for the CodeIssue schema.
type CodeIssueClient struct {
	config
}

// NewCodeIssueClient returns a client for the CodeIssue from the given config.
func NewCodeIssueClient(c config) *CodeIssueClient {
	return &CodeIssueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `codeissue.Hooks(f(g(h())))`.
func (c *CodeIssueClient) Use(hooks ...Hook) {
	c.hooks.CodeIssue = append(c.hooks.CodeIssue, hooks...)
}

// Create returns a create builder for CodeIssue.
func (c *CodeIssueClient) Create() *CodeIssueCreate {
	mutation := newCodeIssueMutation(c.config, OpCreate)
	return &CodeIssueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CodeIssue entities.
func (c *CodeIssueClient) CreateBulk(builders ...*CodeIssueCreate) *CodeIssueCreateBulk {
	return &CodeIssueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CodeIssue.
func (c *CodeIssueClient) Update() *CodeIssueUpdate {
	mutation := newCodeIssueMutation(c.config, OpUpdate)
	return &CodeIssueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CodeIssueClient) UpdateOne(ci *CodeIssue) *CodeIssueUpdateOne {
	mutation := newCodeIssueMutation(c.config, OpUpdateOne, withCodeIssue(ci))
	return &CodeIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CodeIssueClient) UpdateOneID(id int) *CodeIssueUpdateOne {
	mutation := newCodeIssueMutation(c.config, OpUpdateOne, withCodeIssueID(id))
	return &CodeIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CodeIssue.
func (c *CodeIssueClient) Delete() *CodeIssueDelete {
	mutation := newCodeIssueMutation(c.config, OpDelete)
	return &CodeIssueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CodeIssueClient) DeleteOne(ci *CodeIssue) *CodeIssueDeleteOne {
	return c.DeleteOneID(ci.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CodeIssueClient) DeleteOneID(id int) *CodeIssueDeleteOne {
	builder := c.Delete().Where(codeissue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CodeIssueDeleteOne{builder}
}

// Query returns a query builder for CodeIssue.
func (c *CodeIssueClient) Query() *CodeIssueQuery {
	return &CodeIssueQuery{
		config: c.config,
	}
}

// Get returns a CodeIssue entity by its id.
func (c *CodeIssueClient) Get(ctx context.Context, id int) (*CodeIssue, error) {
	return c.Query().Where(codeissue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CodeIssueClient) GetX(ctx context.Context, id int) *CodeIssue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScan queries the scan edge of a CodeIssue.
func (c *CodeIssueClient) QueryScan(ci *CodeIssue) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codeissue.Table, codeissue.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, codeissue.ScanTable, codeissue.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CodeIssueClient) Hooks() []Hook {
	return c.hooks.CodeIssue
}

// CodeScanClient is a client for the CodeScan schema.
type CodeScanClient struct {
	config
}

// NewCodeScanClient returns a client for the CodeScan from the given config.
func NewCodeScanClient(c config) *CodeScanClient {
	return &CodeScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `codescan.Hooks(f(g(h())))`.
func (c *CodeScanClient) Use(hooks ...Hook) {
	c.hooks.CodeScan = append(c.hooks.CodeScan, hooks...)
}

// Create returns a create builder for CodeScan.
func (c *CodeScanClient) Create() *CodeScanCreate {
	mutation := newCodeScanMutation(c.config, OpCreate)
	return &CodeScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CodeScan entities.
func (c *CodeScanClient) CreateBulk(builders ...*CodeScanCreate) *CodeScanCreateBulk {
	return &CodeScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CodeScan.
func (c *CodeScanClient) Update() *CodeScanUpdate {
	mutation := newCodeScanMutation(c.config, OpUpdate)
	return &CodeScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CodeScanClient) UpdateOne(cs *CodeScan) *CodeScanUpdateOne {
	mutation := newCodeScanMutation(c.config, OpUpdateOne, withCodeScan(cs))
	return &CodeScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CodeScanClient) UpdateOneID(id int) *CodeScanUpdateOne {
	mutation := newCodeScanMutation(c.config, OpUpdateOne, withCodeScanID(id))
	return &CodeScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CodeScan.
func (c *CodeScanClient) Delete() *CodeScanDelete {
	mutation := newCodeScanMutation(c.config, OpDelete)
	return &CodeScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CodeScanClient) DeleteOne(cs *CodeScan) *CodeScanDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CodeScanClient) DeleteOneID(id int) *CodeScanDeleteOne {
	builder := c.Delete().Where(codescan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CodeScanDeleteOne{builder}
}

// Query returns a query builder for CodeScan.
func (c *CodeScanClient) Query() *CodeScanQuery {
	return &CodeScanQuery{
		config: c.config,
	}
}

// Get returns a CodeScan entity by its id.
func (c *CodeScanClient) Get(ctx context.Context, id int) (*CodeScan, error) {
	return c.Query().Where(codescan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CodeScanClient) GetX(ctx context.Context, id int) *CodeScan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a CodeScan.
func (c *CodeScanClient) QueryRelease(cs *CodeScan) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, codescan.ReleaseTable, codescan.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a CodeScan.
func (c *CodeScanClient) QueryEntry(cs *CodeScan) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, codescan.EntryTable, codescan.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIssues queries the issues edge of a CodeScan.
func (c *CodeScanClient) QueryIssues(cs *CodeScan) *CodeIssueQuery {
	query := &CodeIssueQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(codeissue.Table, codeissue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, codescan.IssuesTable, codescan.IssuesColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a CodeScan.
func (c *CodeScanClient) QueryVulnerabilities(cs *CodeScan) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, codescan.VulnerabilitiesTable, codescan.VulnerabilitiesColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenses queries the licenses edge of a CodeScan.
func (c *CodeScanClient) QueryLicenses(cs *CodeScan) *ReleaseLicenseQuery {
	query := &ReleaseLicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releaselicense.Table, releaselicense.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, codescan.LicensesTable, codescan.LicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a CodeScan.
func (c *CodeScanClient) QueryComponents(cs *CodeScan) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, codescan.ComponentsTable, codescan.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CodeScanClient) Hooks() []Hook {
	hooks := c.hooks.CodeScan
	return append(hooks[:len(hooks):len(hooks)], codescan.Hooks[:]...)
}

// ComponentClient is a client for the Component schema.
type ComponentClient struct {
	config
}

// NewComponentClient returns a client for the Component from the given config.
func NewComponentClient(c config) *ComponentClient {
	return &ComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `component.Hooks(f(g(h())))`.
func (c *ComponentClient) Use(hooks ...Hook) {
	c.hooks.Component = append(c.hooks.Component, hooks...)
}

// Create returns a create builder for Component.
func (c *ComponentClient) Create() *ComponentCreate {
	mutation := newComponentMutation(c.config, OpCreate)
	return &ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Component entities.
func (c *ComponentClient) CreateBulk(builders ...*ComponentCreate) *ComponentCreateBulk {
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Component.
func (c *ComponentClient) Update() *ComponentUpdate {
	mutation := newComponentMutation(c.config, OpUpdate)
	return &ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentClient) UpdateOne(co *Component) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponent(co))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentClient) UpdateOneID(id int) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponentID(id))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Component.
func (c *ComponentClient) Delete() *ComponentDelete {
	mutation := newComponentMutation(c.config, OpDelete)
	return &ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ComponentClient) DeleteOne(co *Component) *ComponentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ComponentClient) DeleteOneID(id int) *ComponentDeleteOne {
	builder := c.Delete().Where(component.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDeleteOne{builder}
}

// Query returns a query builder for Component.
func (c *ComponentClient) Query() *ComponentQuery {
	return &ComponentQuery{
		config: c.config,
	}
}

// Get returns a Component entity by its id.
func (c *ComponentClient) Get(ctx context.Context, id int) (*Component, error) {
	return c.Query().Where(component.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentClient) GetX(ctx context.Context, id int) *Component {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Component.
func (c *ComponentClient) QueryOwner(co *Component) *OrganizationQuery {
	query := &OrganizationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, component.OwnerTable, component.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Component.
func (c *ComponentClient) QueryVulnerabilities(co *Component) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, component.VulnerabilitiesTable, component.VulnerabilitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenses queries the licenses edge of a Component.
func (c *ComponentClient) QueryLicenses(co *Component) *LicenseQuery {
	query := &LicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, component.LicensesTable, component.LicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUses queries the uses edge of a Component.
func (c *ComponentClient) QueryUses(co *Component) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, component.UsesTable, component.UsesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentClient) Hooks() []Hook {
	return c.hooks.Component
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Create returns a create builder for Event.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id int) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EventClient) DeleteOneID(id int) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id int) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id int) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a Event.
func (c *EventClient) QueryRelease(e *Event) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.ReleaseTable, event.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepository queries the repository edge of a Event.
func (c *EventClient) QueryRepository(e *Event) *RepositoryQuery {
	query := &RepositoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.RepositoryTable, event.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Event.
func (c *EventClient) QueryProject(e *Event) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.ProjectTable, event.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// GitCommitClient is a client for the GitCommit schema.
type GitCommitClient struct {
	config
}

// NewGitCommitClient returns a client for the GitCommit from the given config.
func NewGitCommitClient(c config) *GitCommitClient {
	return &GitCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gitcommit.Hooks(f(g(h())))`.
func (c *GitCommitClient) Use(hooks ...Hook) {
	c.hooks.GitCommit = append(c.hooks.GitCommit, hooks...)
}

// Create returns a create builder for GitCommit.
func (c *GitCommitClient) Create() *GitCommitCreate {
	mutation := newGitCommitMutation(c.config, OpCreate)
	return &GitCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GitCommit entities.
func (c *GitCommitClient) CreateBulk(builders ...*GitCommitCreate) *GitCommitCreateBulk {
	return &GitCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GitCommit.
func (c *GitCommitClient) Update() *GitCommitUpdate {
	mutation := newGitCommitMutation(c.config, OpUpdate)
	return &GitCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GitCommitClient) UpdateOne(gc *GitCommit) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommit(gc))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GitCommitClient) UpdateOneID(id int) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommitID(id))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GitCommit.
func (c *GitCommitClient) Delete() *GitCommitDelete {
	mutation := newGitCommitMutation(c.config, OpDelete)
	return &GitCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GitCommitClient) DeleteOne(gc *GitCommit) *GitCommitDeleteOne {
	return c.DeleteOneID(gc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GitCommitClient) DeleteOneID(id int) *GitCommitDeleteOne {
	builder := c.Delete().Where(gitcommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GitCommitDeleteOne{builder}
}

// Query returns a query builder for GitCommit.
func (c *GitCommitClient) Query() *GitCommitQuery {
	return &GitCommitQuery{
		config: c.config,
	}
}

// Get returns a GitCommit entity by its id.
func (c *GitCommitClient) Get(ctx context.Context, id int) (*GitCommit, error) {
	return c.Query().Where(gitcommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GitCommitClient) GetX(ctx context.Context, id int) *GitCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepository queries the repository edge of a GitCommit.
func (c *GitCommitClient) QueryRepository(gc *GitCommit) *RepositoryQuery {
	query := &RepositoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gitcommit.Table, gitcommit.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, gitcommit.RepositoryTable, gitcommit.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a GitCommit.
func (c *GitCommitClient) QueryRelease(gc *GitCommit) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gitcommit.Table, gitcommit.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, gitcommit.ReleaseTable, gitcommit.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GitCommitClient) Hooks() []Hook {
	return c.hooks.GitCommit
}

// LicenseClient is a client for the License schema.
type LicenseClient struct {
	config
}

// NewLicenseClient returns a client for the License from the given config.
func NewLicenseClient(c config) *LicenseClient {
	return &LicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `license.Hooks(f(g(h())))`.
func (c *LicenseClient) Use(hooks ...Hook) {
	c.hooks.License = append(c.hooks.License, hooks...)
}

// Create returns a create builder for License.
func (c *LicenseClient) Create() *LicenseCreate {
	mutation := newLicenseMutation(c.config, OpCreate)
	return &LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of License entities.
func (c *LicenseClient) CreateBulk(builders ...*LicenseCreate) *LicenseCreateBulk {
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for License.
func (c *LicenseClient) Update() *LicenseUpdate {
	mutation := newLicenseMutation(c.config, OpUpdate)
	return &LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseClient) UpdateOne(l *License) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicense(l))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseClient) UpdateOneID(id int) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicenseID(id))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for License.
func (c *LicenseClient) Delete() *LicenseDelete {
	mutation := newLicenseMutation(c.config, OpDelete)
	return &LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LicenseClient) DeleteOne(l *License) *LicenseDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LicenseClient) DeleteOneID(id int) *LicenseDeleteOne {
	builder := c.Delete().Where(license.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseDeleteOne{builder}
}

// Query returns a query builder for License.
func (c *LicenseClient) Query() *LicenseQuery {
	return &LicenseQuery{
		config: c.config,
	}
}

// Get returns a License entity by its id.
func (c *LicenseClient) Get(ctx context.Context, id int) (*License, error) {
	return c.Query().Where(license.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseClient) GetX(ctx context.Context, id int) *License {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a License.
func (c *LicenseClient) QueryOwner(l *License) *OrganizationQuery {
	query := &OrganizationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, license.OwnerTable, license.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySpdx queries the spdx edge of a License.
func (c *LicenseClient) QuerySpdx(l *License) *SPDXLicenseQuery {
	query := &SPDXLicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(spdxlicense.Table, spdxlicense.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, license.SpdxTable, license.SpdxColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a License.
func (c *LicenseClient) QueryComponents(l *License) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, license.ComponentsTable, license.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a License.
func (c *LicenseClient) QueryInstances(l *License) *ReleaseLicenseQuery {
	query := &ReleaseLicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(releaselicense.Table, releaselicense.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, license.InstancesTable, license.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseClient) Hooks() []Hook {
	hooks := c.hooks.License
	return append(hooks[:len(hooks):len(hooks)], license.Hooks[:]...)
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Create returns a create builder for Organization.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProjects queries the projects edge of a Organization.
func (c *OrganizationClient) QueryProjects(o *Organization) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, organization.ProjectsTable, organization.ProjectsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepositories queries the repositories edge of a Organization.
func (c *OrganizationClient) QueryRepositories(o *Organization) *RepositoryQuery {
	query := &RepositoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, organization.RepositoriesTable, organization.RepositoriesColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	return c.hooks.Organization
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Create returns a create builder for Project.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Project.
func (c *ProjectClient) QueryOwner(pr *Project) *OrganizationQuery {
	query := &OrganizationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, project.OwnerTable, project.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepositories queries the repositories edge of a Project.
func (c *ProjectClient) QueryRepositories(pr *Project) *RepositoryQuery {
	query := &RepositoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.RepositoriesTable, project.RepositoriesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// ReleaseClient is a client for the Release schema.
type ReleaseClient struct {
	config
}

// NewReleaseClient returns a client for the Release from the given config.
func NewReleaseClient(c config) *ReleaseClient {
	return &ReleaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `release.Hooks(f(g(h())))`.
func (c *ReleaseClient) Use(hooks ...Hook) {
	c.hooks.Release = append(c.hooks.Release, hooks...)
}

// Create returns a create builder for Release.
func (c *ReleaseClient) Create() *ReleaseCreate {
	mutation := newReleaseMutation(c.config, OpCreate)
	return &ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Release entities.
func (c *ReleaseClient) CreateBulk(builders ...*ReleaseCreate) *ReleaseCreateBulk {
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Release.
func (c *ReleaseClient) Update() *ReleaseUpdate {
	mutation := newReleaseMutation(c.config, OpUpdate)
	return &ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseClient) UpdateOne(r *Release) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withRelease(r))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseClient) UpdateOneID(id int) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withReleaseID(id))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Release.
func (c *ReleaseClient) Delete() *ReleaseDelete {
	mutation := newReleaseMutation(c.config, OpDelete)
	return &ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseClient) DeleteOne(r *Release) *ReleaseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseClient) DeleteOneID(id int) *ReleaseDeleteOne {
	builder := c.Delete().Where(release.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseDeleteOne{builder}
}

// Query returns a query builder for Release.
func (c *ReleaseClient) Query() *ReleaseQuery {
	return &ReleaseQuery{
		config: c.config,
	}
}

// Get returns a Release entity by its id.
func (c *ReleaseClient) Get(ctx context.Context, id int) (*Release, error) {
	return c.Query().Where(release.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseClient) GetX(ctx context.Context, id int) *Release {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubreleases queries the subreleases edge of a Release.
func (c *ReleaseClient) QuerySubreleases(r *Release) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, release.SubreleasesTable, release.SubreleasesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Release.
func (c *ReleaseClient) QueryDependencies(r *Release) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, release.DependenciesTable, release.DependenciesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommit queries the commit edge of a Release.
func (c *ReleaseClient) QueryCommit(r *Release) *GitCommitQuery {
	query := &GitCommitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(gitcommit.Table, gitcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, release.CommitTable, release.CommitColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHeadOf queries the head_of edge of a Release.
func (c *ReleaseClient) QueryHeadOf(r *Release) *RepositoryQuery {
	query := &RepositoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, release.HeadOfTable, release.HeadOfColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLog queries the log edge of a Release.
func (c *ReleaseClient) QueryLog(r *Release) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.LogTable, release.LogColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViolations queries the violations edge of a Release.
func (c *ReleaseClient) QueryViolations(r *Release) *ReleasePolicyViolationQuery {
	query := &ReleasePolicyViolationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releasepolicyviolation.Table, releasepolicyviolation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.ViolationsTable, release.ViolationsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Release.
func (c *ReleaseClient) QueryArtifacts(r *Release) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.ArtifactsTable, release.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a Release.
func (c *ReleaseClient) QueryComponents(r *Release) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.ComponentsTable, release.ComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Release.
func (c *ReleaseClient) QueryVulnerabilities(r *Release) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.VulnerabilitiesTable, release.VulnerabilitiesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenses queries the licenses edge of a Release.
func (c *ReleaseClient) QueryLicenses(r *Release) *ReleaseLicenseQuery {
	query := &ReleaseLicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releaselicense.Table, releaselicense.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.LicensesTable, release.LicensesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCodeScans queries the code_scans edge of a Release.
func (c *ReleaseClient) QueryCodeScans(r *Release) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.CodeScansTable, release.CodeScansColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestRuns queries the test_runs edge of a Release.
func (c *ReleaseClient) QueryTestRuns(r *Release) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.TestRunsTable, release.TestRunsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilityReviews queries the vulnerability_reviews edge of a Release.
func (c *ReleaseClient) QueryVulnerabilityReviews(r *Release) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, release.VulnerabilityReviewsTable, release.VulnerabilityReviewsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseClient) Hooks() []Hook {
	hooks := c.hooks.Release
	return append(hooks[:len(hooks):len(hooks)], release.Hooks[:]...)
}

// ReleaseComponentClient is a client for the ReleaseComponent schema.
type ReleaseComponentClient struct {
	config
}

// NewReleaseComponentClient returns a client for the ReleaseComponent from the given config.
func NewReleaseComponentClient(c config) *ReleaseComponentClient {
	return &ReleaseComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releasecomponent.Hooks(f(g(h())))`.
func (c *ReleaseComponentClient) Use(hooks ...Hook) {
	c.hooks.ReleaseComponent = append(c.hooks.ReleaseComponent, hooks...)
}

// Create returns a create builder for ReleaseComponent.
func (c *ReleaseComponentClient) Create() *ReleaseComponentCreate {
	mutation := newReleaseComponentMutation(c.config, OpCreate)
	return &ReleaseComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseComponent entities.
func (c *ReleaseComponentClient) CreateBulk(builders ...*ReleaseComponentCreate) *ReleaseComponentCreateBulk {
	return &ReleaseComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseComponent.
func (c *ReleaseComponentClient) Update() *ReleaseComponentUpdate {
	mutation := newReleaseComponentMutation(c.config, OpUpdate)
	return &ReleaseComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseComponentClient) UpdateOne(rc *ReleaseComponent) *ReleaseComponentUpdateOne {
	mutation := newReleaseComponentMutation(c.config, OpUpdateOne, withReleaseComponent(rc))
	return &ReleaseComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseComponentClient) UpdateOneID(id int) *ReleaseComponentUpdateOne {
	mutation := newReleaseComponentMutation(c.config, OpUpdateOne, withReleaseComponentID(id))
	return &ReleaseComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseComponent.
func (c *ReleaseComponentClient) Delete() *ReleaseComponentDelete {
	mutation := newReleaseComponentMutation(c.config, OpDelete)
	return &ReleaseComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseComponentClient) DeleteOne(rc *ReleaseComponent) *ReleaseComponentDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseComponentClient) DeleteOneID(id int) *ReleaseComponentDeleteOne {
	builder := c.Delete().Where(releasecomponent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseComponentDeleteOne{builder}
}

// Query returns a query builder for ReleaseComponent.
func (c *ReleaseComponentClient) Query() *ReleaseComponentQuery {
	return &ReleaseComponentQuery{
		config: c.config,
	}
}

// Get returns a ReleaseComponent entity by its id.
func (c *ReleaseComponentClient) Get(ctx context.Context, id int) (*ReleaseComponent, error) {
	return c.Query().Where(releasecomponent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseComponentClient) GetX(ctx context.Context, id int) *ReleaseComponent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryRelease(rc *ReleaseComponent) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasecomponent.ReleaseTable, releasecomponent.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryScans(rc *ReleaseComponent) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, releasecomponent.ScansTable, releasecomponent.ScansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryComponent(rc *ReleaseComponent) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasecomponent.ComponentTable, releasecomponent.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryVulnerabilities(rc *ReleaseComponent) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, releasecomponent.VulnerabilitiesTable, releasecomponent.VulnerabilitiesColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenses queries the licenses edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryLicenses(rc *ReleaseComponent) *ReleaseLicenseQuery {
	query := &ReleaseLicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(releaselicense.Table, releaselicense.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, releasecomponent.LicensesTable, releasecomponent.LicensesColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseComponentClient) Hooks() []Hook {
	return c.hooks.ReleaseComponent
}

// ReleaseEntryClient is a client for the ReleaseEntry schema.
type ReleaseEntryClient struct {
	config
}

// NewReleaseEntryClient returns a client for the ReleaseEntry from the given config.
func NewReleaseEntryClient(c config) *ReleaseEntryClient {
	return &ReleaseEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releaseentry.Hooks(f(g(h())))`.
func (c *ReleaseEntryClient) Use(hooks ...Hook) {
	c.hooks.ReleaseEntry = append(c.hooks.ReleaseEntry, hooks...)
}

// Create returns a create builder for ReleaseEntry.
func (c *ReleaseEntryClient) Create() *ReleaseEntryCreate {
	mutation := newReleaseEntryMutation(c.config, OpCreate)
	return &ReleaseEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseEntry entities.
func (c *ReleaseEntryClient) CreateBulk(builders ...*ReleaseEntryCreate) *ReleaseEntryCreateBulk {
	return &ReleaseEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseEntry.
func (c *ReleaseEntryClient) Update() *ReleaseEntryUpdate {
	mutation := newReleaseEntryMutation(c.config, OpUpdate)
	return &ReleaseEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseEntryClient) UpdateOne(re *ReleaseEntry) *ReleaseEntryUpdateOne {
	mutation := newReleaseEntryMutation(c.config, OpUpdateOne, withReleaseEntry(re))
	return &ReleaseEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseEntryClient) UpdateOneID(id int) *ReleaseEntryUpdateOne {
	mutation := newReleaseEntryMutation(c.config, OpUpdateOne, withReleaseEntryID(id))
	return &ReleaseEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseEntry.
func (c *ReleaseEntryClient) Delete() *ReleaseEntryDelete {
	mutation := newReleaseEntryMutation(c.config, OpDelete)
	return &ReleaseEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseEntryClient) DeleteOne(re *ReleaseEntry) *ReleaseEntryDeleteOne {
	return c.DeleteOneID(re.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseEntryClient) DeleteOneID(id int) *ReleaseEntryDeleteOne {
	builder := c.Delete().Where(releaseentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseEntryDeleteOne{builder}
}

// Query returns a query builder for ReleaseEntry.
func (c *ReleaseEntryClient) Query() *ReleaseEntryQuery {
	return &ReleaseEntryQuery{
		config: c.config,
	}
}

// Get returns a ReleaseEntry entity by its id.
func (c *ReleaseEntryClient) Get(ctx context.Context, id int) (*ReleaseEntry, error) {
	return c.Query().Where(releaseentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseEntryClient) GetX(ctx context.Context, id int) *ReleaseEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifact queries the artifact edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryArtifact(re *ReleaseEntry) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.ArtifactTable, releaseentry.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCodeScan queries the code_scan edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryCodeScan(re *ReleaseEntry) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.CodeScanTable, releaseentry.CodeScanColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestRun queries the test_run edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryTestRun(re *ReleaseEntry) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.TestRunTable, releaseentry.TestRunColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryRelease(re *ReleaseEntry) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releaseentry.ReleaseTable, releaseentry.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseEntryClient) Hooks() []Hook {
	return c.hooks.ReleaseEntry
}

// ReleaseLicenseClient is a client for the ReleaseLicense schema.
type ReleaseLicenseClient struct {
	config
}

// NewReleaseLicenseClient returns a client for the ReleaseLicense from the given config.
func NewReleaseLicenseClient(c config) *ReleaseLicenseClient {
	return &ReleaseLicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releaselicense.Hooks(f(g(h())))`.
func (c *ReleaseLicenseClient) Use(hooks ...Hook) {
	c.hooks.ReleaseLicense = append(c.hooks.ReleaseLicense, hooks...)
}

// Create returns a create builder for ReleaseLicense.
func (c *ReleaseLicenseClient) Create() *ReleaseLicenseCreate {
	mutation := newReleaseLicenseMutation(c.config, OpCreate)
	return &ReleaseLicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseLicense entities.
func (c *ReleaseLicenseClient) CreateBulk(builders ...*ReleaseLicenseCreate) *ReleaseLicenseCreateBulk {
	return &ReleaseLicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseLicense.
func (c *ReleaseLicenseClient) Update() *ReleaseLicenseUpdate {
	mutation := newReleaseLicenseMutation(c.config, OpUpdate)
	return &ReleaseLicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseLicenseClient) UpdateOne(rl *ReleaseLicense) *ReleaseLicenseUpdateOne {
	mutation := newReleaseLicenseMutation(c.config, OpUpdateOne, withReleaseLicense(rl))
	return &ReleaseLicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseLicenseClient) UpdateOneID(id int) *ReleaseLicenseUpdateOne {
	mutation := newReleaseLicenseMutation(c.config, OpUpdateOne, withReleaseLicenseID(id))
	return &ReleaseLicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseLicense.
func (c *ReleaseLicenseClient) Delete() *ReleaseLicenseDelete {
	mutation := newReleaseLicenseMutation(c.config, OpDelete)
	return &ReleaseLicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseLicenseClient) DeleteOne(rl *ReleaseLicense) *ReleaseLicenseDeleteOne {
	return c.DeleteOneID(rl.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseLicenseClient) DeleteOneID(id int) *ReleaseLicenseDeleteOne {
	builder := c.Delete().Where(releaselicense.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseLicenseDeleteOne{builder}
}

// Query returns a query builder for ReleaseLicense.
func (c *ReleaseLicenseClient) Query() *ReleaseLicenseQuery {
	return &ReleaseLicenseQuery{
		config: c.config,
	}
}

// Get returns a ReleaseLicense entity by its id.
func (c *ReleaseLicenseClient) Get(ctx context.Context, id int) (*ReleaseLicense, error) {
	return c.Query().Where(releaselicense.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseLicenseClient) GetX(ctx context.Context, id int) *ReleaseLicense {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLicense queries the license edge of a ReleaseLicense.
func (c *ReleaseLicenseClient) QueryLicense(rl *ReleaseLicense) *LicenseQuery {
	query := &LicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaselicense.Table, releaselicense.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releaselicense.LicenseTable, releaselicense.LicenseColumn),
		)
		fromV = sqlgraph.Neighbors(rl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a ReleaseLicense.
func (c *ReleaseLicenseClient) QueryComponent(rl *ReleaseLicense) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaselicense.Table, releaselicense.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releaselicense.ComponentTable, releaselicense.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(rl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a ReleaseLicense.
func (c *ReleaseLicenseClient) QueryRelease(rl *ReleaseLicense) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaselicense.Table, releaselicense.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releaselicense.ReleaseTable, releaselicense.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(rl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a ReleaseLicense.
func (c *ReleaseLicenseClient) QueryScans(rl *ReleaseLicense) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaselicense.Table, releaselicense.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, releaselicense.ScansTable, releaselicense.ScansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseLicenseClient) Hooks() []Hook {
	return c.hooks.ReleaseLicense
}

// ReleasePolicyClient is a client for the ReleasePolicy schema.
type ReleasePolicyClient struct {
	config
}

// NewReleasePolicyClient returns a client for the ReleasePolicy from the given config.
func NewReleasePolicyClient(c config) *ReleasePolicyClient {
	return &ReleasePolicyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releasepolicy.Hooks(f(g(h())))`.
func (c *ReleasePolicyClient) Use(hooks ...Hook) {
	c.hooks.ReleasePolicy = append(c.hooks.ReleasePolicy, hooks...)
}

// Create returns a create builder for ReleasePolicy.
func (c *ReleasePolicyClient) Create() *ReleasePolicyCreate {
	mutation := newReleasePolicyMutation(c.config, OpCreate)
	return &ReleasePolicyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleasePolicy entities.
func (c *ReleasePolicyClient) CreateBulk(builders ...*ReleasePolicyCreate) *ReleasePolicyCreateBulk {
	return &ReleasePolicyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleasePolicy.
func (c *ReleasePolicyClient) Update() *ReleasePolicyUpdate {
	mutation := newReleasePolicyMutation(c.config, OpUpdate)
	return &ReleasePolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleasePolicyClient) UpdateOne(rp *ReleasePolicy) *ReleasePolicyUpdateOne {
	mutation := newReleasePolicyMutation(c.config, OpUpdateOne, withReleasePolicy(rp))
	return &ReleasePolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleasePolicyClient) UpdateOneID(id int) *ReleasePolicyUpdateOne {
	mutation := newReleasePolicyMutation(c.config, OpUpdateOne, withReleasePolicyID(id))
	return &ReleasePolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleasePolicy.
func (c *ReleasePolicyClient) Delete() *ReleasePolicyDelete {
	mutation := newReleasePolicyMutation(c.config, OpDelete)
	return &ReleasePolicyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleasePolicyClient) DeleteOne(rp *ReleasePolicy) *ReleasePolicyDeleteOne {
	return c.DeleteOneID(rp.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleasePolicyClient) DeleteOneID(id int) *ReleasePolicyDeleteOne {
	builder := c.Delete().Where(releasepolicy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleasePolicyDeleteOne{builder}
}

// Query returns a query builder for ReleasePolicy.
func (c *ReleasePolicyClient) Query() *ReleasePolicyQuery {
	return &ReleasePolicyQuery{
		config: c.config,
	}
}

// Get returns a ReleasePolicy entity by its id.
func (c *ReleasePolicyClient) Get(ctx context.Context, id int) (*ReleasePolicy, error) {
	return c.Query().Where(releasepolicy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleasePolicyClient) GetX(ctx context.Context, id int) *ReleasePolicy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a ReleasePolicy.
func (c *ReleasePolicyClient) QueryOwner(rp *ReleasePolicy) *OrganizationQuery {
	query := &OrganizationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasepolicy.Table, releasepolicy.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasepolicy.OwnerTable, releasepolicy.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(rp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryViolations queries the violations edge of a ReleasePolicy.
func (c *ReleasePolicyClient) QueryViolations(rp *ReleasePolicy) *ReleasePolicyViolationQuery {
	query := &ReleasePolicyViolationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasepolicy.Table, releasepolicy.FieldID, id),
			sqlgraph.To(releasepolicyviolation.Table, releasepolicyviolation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, releasepolicy.ViolationsTable, releasepolicy.ViolationsColumn),
		)
		fromV = sqlgraph.Neighbors(rp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleasePolicyClient) Hooks() []Hook {
	return c.hooks.ReleasePolicy
}

// ReleasePolicyViolationClient is a client for the ReleasePolicyViolation schema.
type ReleasePolicyViolationClient struct {
	config
}

// NewReleasePolicyViolationClient returns a client for the ReleasePolicyViolation from the given config.
func NewReleasePolicyViolationClient(c config) *ReleasePolicyViolationClient {
	return &ReleasePolicyViolationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releasepolicyviolation.Hooks(f(g(h())))`.
func (c *ReleasePolicyViolationClient) Use(hooks ...Hook) {
	c.hooks.ReleasePolicyViolation = append(c.hooks.ReleasePolicyViolation, hooks...)
}

// Create returns a create builder for ReleasePolicyViolation.
func (c *ReleasePolicyViolationClient) Create() *ReleasePolicyViolationCreate {
	mutation := newReleasePolicyViolationMutation(c.config, OpCreate)
	return &ReleasePolicyViolationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleasePolicyViolation entities.
func (c *ReleasePolicyViolationClient) CreateBulk(builders ...*ReleasePolicyViolationCreate) *ReleasePolicyViolationCreateBulk {
	return &ReleasePolicyViolationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleasePolicyViolation.
func (c *ReleasePolicyViolationClient) Update() *ReleasePolicyViolationUpdate {
	mutation := newReleasePolicyViolationMutation(c.config, OpUpdate)
	return &ReleasePolicyViolationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleasePolicyViolationClient) UpdateOne(rpv *ReleasePolicyViolation) *ReleasePolicyViolationUpdateOne {
	mutation := newReleasePolicyViolationMutation(c.config, OpUpdateOne, withReleasePolicyViolation(rpv))
	return &ReleasePolicyViolationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleasePolicyViolationClient) UpdateOneID(id int) *ReleasePolicyViolationUpdateOne {
	mutation := newReleasePolicyViolationMutation(c.config, OpUpdateOne, withReleasePolicyViolationID(id))
	return &ReleasePolicyViolationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleasePolicyViolation.
func (c *ReleasePolicyViolationClient) Delete() *ReleasePolicyViolationDelete {
	mutation := newReleasePolicyViolationMutation(c.config, OpDelete)
	return &ReleasePolicyViolationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleasePolicyViolationClient) DeleteOne(rpv *ReleasePolicyViolation) *ReleasePolicyViolationDeleteOne {
	return c.DeleteOneID(rpv.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleasePolicyViolationClient) DeleteOneID(id int) *ReleasePolicyViolationDeleteOne {
	builder := c.Delete().Where(releasepolicyviolation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleasePolicyViolationDeleteOne{builder}
}

// Query returns a query builder for ReleasePolicyViolation.
func (c *ReleasePolicyViolationClient) Query() *ReleasePolicyViolationQuery {
	return &ReleasePolicyViolationQuery{
		config: c.config,
	}
}

// Get returns a ReleasePolicyViolation entity by its id.
func (c *ReleasePolicyViolationClient) Get(ctx context.Context, id int) (*ReleasePolicyViolation, error) {
	return c.Query().Where(releasepolicyviolation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleasePolicyViolationClient) GetX(ctx context.Context, id int) *ReleasePolicyViolation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPolicy queries the policy edge of a ReleasePolicyViolation.
func (c *ReleasePolicyViolationClient) QueryPolicy(rpv *ReleasePolicyViolation) *ReleasePolicyQuery {
	query := &ReleasePolicyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rpv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasepolicyviolation.Table, releasepolicyviolation.FieldID, id),
			sqlgraph.To(releasepolicy.Table, releasepolicy.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasepolicyviolation.PolicyTable, releasepolicyviolation.PolicyColumn),
		)
		fromV = sqlgraph.Neighbors(rpv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a ReleasePolicyViolation.
func (c *ReleasePolicyViolationClient) QueryRelease(rpv *ReleasePolicyViolation) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rpv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasepolicyviolation.Table, releasepolicyviolation.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasepolicyviolation.ReleaseTable, releasepolicyviolation.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(rpv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleasePolicyViolationClient) Hooks() []Hook {
	return c.hooks.ReleasePolicyViolation
}

// ReleaseVulnerabilityClient is a client for the ReleaseVulnerability schema.
type ReleaseVulnerabilityClient struct {
	config
}

// NewReleaseVulnerabilityClient returns a client for the ReleaseVulnerability from the given config.
func NewReleaseVulnerabilityClient(c config) *ReleaseVulnerabilityClient {
	return &ReleaseVulnerabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releasevulnerability.Hooks(f(g(h())))`.
func (c *ReleaseVulnerabilityClient) Use(hooks ...Hook) {
	c.hooks.ReleaseVulnerability = append(c.hooks.ReleaseVulnerability, hooks...)
}

// Create returns a create builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Create() *ReleaseVulnerabilityCreate {
	mutation := newReleaseVulnerabilityMutation(c.config, OpCreate)
	return &ReleaseVulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseVulnerability entities.
func (c *ReleaseVulnerabilityClient) CreateBulk(builders ...*ReleaseVulnerabilityCreate) *ReleaseVulnerabilityCreateBulk {
	return &ReleaseVulnerabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Update() *ReleaseVulnerabilityUpdate {
	mutation := newReleaseVulnerabilityMutation(c.config, OpUpdate)
	return &ReleaseVulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseVulnerabilityClient) UpdateOne(rv *ReleaseVulnerability) *ReleaseVulnerabilityUpdateOne {
	mutation := newReleaseVulnerabilityMutation(c.config, OpUpdateOne, withReleaseVulnerability(rv))
	return &ReleaseVulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseVulnerabilityClient) UpdateOneID(id int) *ReleaseVulnerabilityUpdateOne {
	mutation := newReleaseVulnerabilityMutation(c.config, OpUpdateOne, withReleaseVulnerabilityID(id))
	return &ReleaseVulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Delete() *ReleaseVulnerabilityDelete {
	mutation := newReleaseVulnerabilityMutation(c.config, OpDelete)
	return &ReleaseVulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseVulnerabilityClient) DeleteOne(rv *ReleaseVulnerability) *ReleaseVulnerabilityDeleteOne {
	return c.DeleteOneID(rv.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseVulnerabilityClient) DeleteOneID(id int) *ReleaseVulnerabilityDeleteOne {
	builder := c.Delete().Where(releasevulnerability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseVulnerabilityDeleteOne{builder}
}

// Query returns a query builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Query() *ReleaseVulnerabilityQuery {
	return &ReleaseVulnerabilityQuery{
		config: c.config,
	}
}

// Get returns a ReleaseVulnerability entity by its id.
func (c *ReleaseVulnerabilityClient) Get(ctx context.Context, id int) (*ReleaseVulnerability, error) {
	return c.Query().Where(releasevulnerability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseVulnerabilityClient) GetX(ctx context.Context, id int) *ReleaseVulnerability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerability queries the vulnerability edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryVulnerability(rv *ReleaseVulnerability) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasevulnerability.VulnerabilityTable, releasevulnerability.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryComponent(rv *ReleaseVulnerability) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasevulnerability.ComponentTable, releasevulnerability.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryRelease(rv *ReleaseVulnerability) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasevulnerability.ReleaseTable, releasevulnerability.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryReviews(rv *ReleaseVulnerability) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, releasevulnerability.ReviewsTable, releasevulnerability.ReviewsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScan queries the scan edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryScan(rv *ReleaseVulnerability) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasevulnerability.ScanTable, releasevulnerability.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseVulnerabilityClient) Hooks() []Hook {
	return c.hooks.ReleaseVulnerability
}

// RepositoryClient is a client for the Repository schema.
type RepositoryClient struct {
	config
}

// NewRepositoryClient returns a client for the Repository from the given config.
func NewRepositoryClient(c config) *RepositoryClient {
	return &RepositoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repository.Hooks(f(g(h())))`.
func (c *RepositoryClient) Use(hooks ...Hook) {
	c.hooks.Repository = append(c.hooks.Repository, hooks...)
}

// Create returns a create builder for Repository.
func (c *RepositoryClient) Create() *RepositoryCreate {
	mutation := newRepositoryMutation(c.config, OpCreate)
	return &RepositoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Repository entities.
func (c *RepositoryClient) CreateBulk(builders ...*RepositoryCreate) *RepositoryCreateBulk {
	return &RepositoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Repository.
func (c *RepositoryClient) Update() *RepositoryUpdate {
	mutation := newRepositoryMutation(c.config, OpUpdate)
	return &RepositoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepositoryClient) UpdateOne(r *Repository) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepository(r))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepositoryClient) UpdateOneID(id int) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepositoryID(id))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Repository.
func (c *RepositoryClient) Delete() *RepositoryDelete {
	mutation := newRepositoryMutation(c.config, OpDelete)
	return &RepositoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RepositoryClient) DeleteOne(r *Repository) *RepositoryDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RepositoryClient) DeleteOneID(id int) *RepositoryDeleteOne {
	builder := c.Delete().Where(repository.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepositoryDeleteOne{builder}
}

// Query returns a query builder for Repository.
func (c *RepositoryClient) Query() *RepositoryQuery {
	return &RepositoryQuery{
		config: c.config,
	}
}

// Get returns a Repository entity by its id.
func (c *RepositoryClient) Get(ctx context.Context, id int) (*Repository, error) {
	return c.Query().Where(repository.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepositoryClient) GetX(ctx context.Context, id int) *Repository {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Repository.
func (c *RepositoryClient) QueryOwner(r *Repository) *OrganizationQuery {
	query := &OrganizationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, repository.OwnerTable, repository.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Repository.
func (c *RepositoryClient) QueryProject(r *Repository) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, repository.ProjectTable, repository.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHead queries the head edge of a Repository.
func (c *RepositoryClient) QueryHead(r *Repository) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, repository.HeadTable, repository.HeadColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommits queries the commits edge of a Repository.
func (c *RepositoryClient) QueryCommits(r *Repository) *GitCommitQuery {
	query := &GitCommitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(gitcommit.Table, gitcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, repository.CommitsTable, repository.CommitsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepositoryClient) Hooks() []Hook {
	return c.hooks.Repository
}

// SPDXLicenseClient is a client for the SPDXLicense schema.
type SPDXLicenseClient struct {
	config
}

// NewSPDXLicenseClient returns a client for the SPDXLicense from the given config.
func NewSPDXLicenseClient(c config) *SPDXLicenseClient {
	return &SPDXLicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `spdxlicense.Hooks(f(g(h())))`.
func (c *SPDXLicenseClient) Use(hooks ...Hook) {
	c.hooks.SPDXLicense = append(c.hooks.SPDXLicense, hooks...)
}

// Create returns a create builder for SPDXLicense.
func (c *SPDXLicenseClient) Create() *SPDXLicenseCreate {
	mutation := newSPDXLicenseMutation(c.config, OpCreate)
	return &SPDXLicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SPDXLicense entities.
func (c *SPDXLicenseClient) CreateBulk(builders ...*SPDXLicenseCreate) *SPDXLicenseCreateBulk {
	return &SPDXLicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SPDXLicense.
func (c *SPDXLicenseClient) Update() *SPDXLicenseUpdate {
	mutation := newSPDXLicenseMutation(c.config, OpUpdate)
	return &SPDXLicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SPDXLicenseClient) UpdateOne(sl *SPDXLicense) *SPDXLicenseUpdateOne {
	mutation := newSPDXLicenseMutation(c.config, OpUpdateOne, withSPDXLicense(sl))
	return &SPDXLicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SPDXLicenseClient) UpdateOneID(id int) *SPDXLicenseUpdateOne {
	mutation := newSPDXLicenseMutation(c.config, OpUpdateOne, withSPDXLicenseID(id))
	return &SPDXLicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SPDXLicense.
func (c *SPDXLicenseClient) Delete() *SPDXLicenseDelete {
	mutation := newSPDXLicenseMutation(c.config, OpDelete)
	return &SPDXLicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SPDXLicenseClient) DeleteOne(sl *SPDXLicense) *SPDXLicenseDeleteOne {
	return c.DeleteOneID(sl.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SPDXLicenseClient) DeleteOneID(id int) *SPDXLicenseDeleteOne {
	builder := c.Delete().Where(spdxlicense.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SPDXLicenseDeleteOne{builder}
}

// Query returns a query builder for SPDXLicense.
func (c *SPDXLicenseClient) Query() *SPDXLicenseQuery {
	return &SPDXLicenseQuery{
		config: c.config,
	}
}

// Get returns a SPDXLicense entity by its id.
func (c *SPDXLicenseClient) Get(ctx context.Context, id int) (*SPDXLicense, error) {
	return c.Query().Where(spdxlicense.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SPDXLicenseClient) GetX(ctx context.Context, id int) *SPDXLicense {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SPDXLicenseClient) Hooks() []Hook {
	hooks := c.hooks.SPDXLicense
	return append(hooks[:len(hooks):len(hooks)], spdxlicense.Hooks[:]...)
}

// TestCaseClient is a client for the TestCase schema.
type TestCaseClient struct {
	config
}

// NewTestCaseClient returns a client for the TestCase from the given config.
func NewTestCaseClient(c config) *TestCaseClient {
	return &TestCaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testcase.Hooks(f(g(h())))`.
func (c *TestCaseClient) Use(hooks ...Hook) {
	c.hooks.TestCase = append(c.hooks.TestCase, hooks...)
}

// Create returns a create builder for TestCase.
func (c *TestCaseClient) Create() *TestCaseCreate {
	mutation := newTestCaseMutation(c.config, OpCreate)
	return &TestCaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestCase entities.
func (c *TestCaseClient) CreateBulk(builders ...*TestCaseCreate) *TestCaseCreateBulk {
	return &TestCaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestCase.
func (c *TestCaseClient) Update() *TestCaseUpdate {
	mutation := newTestCaseMutation(c.config, OpUpdate)
	return &TestCaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestCaseClient) UpdateOne(tc *TestCase) *TestCaseUpdateOne {
	mutation := newTestCaseMutation(c.config, OpUpdateOne, withTestCase(tc))
	return &TestCaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestCaseClient) UpdateOneID(id int) *TestCaseUpdateOne {
	mutation := newTestCaseMutation(c.config, OpUpdateOne, withTestCaseID(id))
	return &TestCaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestCase.
func (c *TestCaseClient) Delete() *TestCaseDelete {
	mutation := newTestCaseMutation(c.config, OpDelete)
	return &TestCaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TestCaseClient) DeleteOne(tc *TestCase) *TestCaseDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TestCaseClient) DeleteOneID(id int) *TestCaseDeleteOne {
	builder := c.Delete().Where(testcase.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestCaseDeleteOne{builder}
}

// Query returns a query builder for TestCase.
func (c *TestCaseClient) Query() *TestCaseQuery {
	return &TestCaseQuery{
		config: c.config,
	}
}

// Get returns a TestCase entity by its id.
func (c *TestCaseClient) Get(ctx context.Context, id int) (*TestCase, error) {
	return c.Query().Where(testcase.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestCaseClient) GetX(ctx context.Context, id int) *TestCase {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRun queries the run edge of a TestCase.
func (c *TestCaseClient) QueryRun(tc *TestCase) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testcase.Table, testcase.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testcase.RunTable, testcase.RunColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestCaseClient) Hooks() []Hook {
	return c.hooks.TestCase
}

// TestRunClient is a client for the TestRun schema.
type TestRunClient struct {
	config
}

// NewTestRunClient returns a client for the TestRun from the given config.
func NewTestRunClient(c config) *TestRunClient {
	return &TestRunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testrun.Hooks(f(g(h())))`.
func (c *TestRunClient) Use(hooks ...Hook) {
	c.hooks.TestRun = append(c.hooks.TestRun, hooks...)
}

// Create returns a create builder for TestRun.
func (c *TestRunClient) Create() *TestRunCreate {
	mutation := newTestRunMutation(c.config, OpCreate)
	return &TestRunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestRun entities.
func (c *TestRunClient) CreateBulk(builders ...*TestRunCreate) *TestRunCreateBulk {
	return &TestRunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestRun.
func (c *TestRunClient) Update() *TestRunUpdate {
	mutation := newTestRunMutation(c.config, OpUpdate)
	return &TestRunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestRunClient) UpdateOne(tr *TestRun) *TestRunUpdateOne {
	mutation := newTestRunMutation(c.config, OpUpdateOne, withTestRun(tr))
	return &TestRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestRunClient) UpdateOneID(id int) *TestRunUpdateOne {
	mutation := newTestRunMutation(c.config, OpUpdateOne, withTestRunID(id))
	return &TestRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestRun.
func (c *TestRunClient) Delete() *TestRunDelete {
	mutation := newTestRunMutation(c.config, OpDelete)
	return &TestRunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TestRunClient) DeleteOne(tr *TestRun) *TestRunDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TestRunClient) DeleteOneID(id int) *TestRunDeleteOne {
	builder := c.Delete().Where(testrun.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestRunDeleteOne{builder}
}

// Query returns a query builder for TestRun.
func (c *TestRunClient) Query() *TestRunQuery {
	return &TestRunQuery{
		config: c.config,
	}
}

// Get returns a TestRun entity by its id.
func (c *TestRunClient) Get(ctx context.Context, id int) (*TestRun, error) {
	return c.Query().Where(testrun.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestRunClient) GetX(ctx context.Context, id int) *TestRun {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a TestRun.
func (c *TestRunClient) QueryRelease(tr *TestRun) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testrun.ReleaseTable, testrun.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a TestRun.
func (c *TestRunClient) QueryEntry(tr *TestRun) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, testrun.EntryTable, testrun.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a TestRun.
func (c *TestRunClient) QueryTests(tr *TestRun) *TestCaseQuery {
	query := &TestCaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(testcase.Table, testcase.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, testrun.TestsTable, testrun.TestsColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestRunClient) Hooks() []Hook {
	hooks := c.hooks.TestRun
	return append(hooks[:len(hooks):len(hooks)], testrun.Hooks[:]...)
}

// VulnerabilityClient is a client for the Vulnerability schema.
type VulnerabilityClient struct {
	config
}

// NewVulnerabilityClient returns a client for the Vulnerability from the given config.
func NewVulnerabilityClient(c config) *VulnerabilityClient {
	return &VulnerabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerability.Hooks(f(g(h())))`.
func (c *VulnerabilityClient) Use(hooks ...Hook) {
	c.hooks.Vulnerability = append(c.hooks.Vulnerability, hooks...)
}

// Create returns a create builder for Vulnerability.
func (c *VulnerabilityClient) Create() *VulnerabilityCreate {
	mutation := newVulnerabilityMutation(c.config, OpCreate)
	return &VulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vulnerability entities.
func (c *VulnerabilityClient) CreateBulk(builders ...*VulnerabilityCreate) *VulnerabilityCreateBulk {
	return &VulnerabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vulnerability.
func (c *VulnerabilityClient) Update() *VulnerabilityUpdate {
	mutation := newVulnerabilityMutation(c.config, OpUpdate)
	return &VulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityClient) UpdateOne(v *Vulnerability) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerability(v))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityClient) UpdateOneID(id int) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerabilityID(id))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vulnerability.
func (c *VulnerabilityClient) Delete() *VulnerabilityDelete {
	mutation := newVulnerabilityMutation(c.config, OpDelete)
	return &VulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VulnerabilityClient) DeleteOne(v *Vulnerability) *VulnerabilityDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VulnerabilityClient) DeleteOneID(id int) *VulnerabilityDeleteOne {
	builder := c.Delete().Where(vulnerability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityDeleteOne{builder}
}

// Query returns a query builder for Vulnerability.
func (c *VulnerabilityClient) Query() *VulnerabilityQuery {
	return &VulnerabilityQuery{
		config: c.config,
	}
}

// Get returns a Vulnerability entity by its id.
func (c *VulnerabilityClient) Get(ctx context.Context, id int) (*Vulnerability, error) {
	return c.Query().Where(vulnerability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityClient) GetX(ctx context.Context, id int) *Vulnerability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Vulnerability.
func (c *VulnerabilityClient) QueryOwner(v *Vulnerability) *OrganizationQuery {
	query := &OrganizationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnerability.OwnerTable, vulnerability.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a Vulnerability.
func (c *VulnerabilityClient) QueryComponents(v *Vulnerability) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, vulnerability.ComponentsTable, vulnerability.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Vulnerability.
func (c *VulnerabilityClient) QueryReviews(v *Vulnerability) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerability.ReviewsTable, vulnerability.ReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a Vulnerability.
func (c *VulnerabilityClient) QueryInstances(v *Vulnerability) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerability.InstancesTable, vulnerability.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityClient) Hooks() []Hook {
	hooks := c.hooks.Vulnerability
	return append(hooks[:len(hooks):len(hooks)], vulnerability.Hooks[:]...)
}

// VulnerabilityReviewClient is a client for the VulnerabilityReview schema.
type VulnerabilityReviewClient struct {
	config
}

// NewVulnerabilityReviewClient returns a client for the VulnerabilityReview from the given config.
func NewVulnerabilityReviewClient(c config) *VulnerabilityReviewClient {
	return &VulnerabilityReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerabilityreview.Hooks(f(g(h())))`.
func (c *VulnerabilityReviewClient) Use(hooks ...Hook) {
	c.hooks.VulnerabilityReview = append(c.hooks.VulnerabilityReview, hooks...)
}

// Create returns a create builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Create() *VulnerabilityReviewCreate {
	mutation := newVulnerabilityReviewMutation(c.config, OpCreate)
	return &VulnerabilityReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnerabilityReview entities.
func (c *VulnerabilityReviewClient) CreateBulk(builders ...*VulnerabilityReviewCreate) *VulnerabilityReviewCreateBulk {
	return &VulnerabilityReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Update() *VulnerabilityReviewUpdate {
	mutation := newVulnerabilityReviewMutation(c.config, OpUpdate)
	return &VulnerabilityReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityReviewClient) UpdateOne(vr *VulnerabilityReview) *VulnerabilityReviewUpdateOne {
	mutation := newVulnerabilityReviewMutation(c.config, OpUpdateOne, withVulnerabilityReview(vr))
	return &VulnerabilityReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityReviewClient) UpdateOneID(id int) *VulnerabilityReviewUpdateOne {
	mutation := newVulnerabilityReviewMutation(c.config, OpUpdateOne, withVulnerabilityReviewID(id))
	return &VulnerabilityReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Delete() *VulnerabilityReviewDelete {
	mutation := newVulnerabilityReviewMutation(c.config, OpDelete)
	return &VulnerabilityReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VulnerabilityReviewClient) DeleteOne(vr *VulnerabilityReview) *VulnerabilityReviewDeleteOne {
	return c.DeleteOneID(vr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VulnerabilityReviewClient) DeleteOneID(id int) *VulnerabilityReviewDeleteOne {
	builder := c.Delete().Where(vulnerabilityreview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityReviewDeleteOne{builder}
}

// Query returns a query builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Query() *VulnerabilityReviewQuery {
	return &VulnerabilityReviewQuery{
		config: c.config,
	}
}

// Get returns a VulnerabilityReview entity by its id.
func (c *VulnerabilityReviewClient) Get(ctx context.Context, id int) (*VulnerabilityReview, error) {
	return c.Query().Where(vulnerabilityreview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityReviewClient) GetX(ctx context.Context, id int) *VulnerabilityReview {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerability queries the vulnerability edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryVulnerability(vr *VulnerabilityReview) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnerabilityreview.VulnerabilityTable, vulnerabilityreview.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReleases queries the releases edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryReleases(vr *VulnerabilityReview) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, vulnerabilityreview.ReleasesTable, vulnerabilityreview.ReleasesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryInstances(vr *VulnerabilityReview) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, vulnerabilityreview.InstancesTable, vulnerabilityreview.InstancesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityReviewClient) Hooks() []Hook {
	return c.hooks.VulnerabilityReview
}
