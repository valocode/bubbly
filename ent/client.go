// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/valocode/bubbly/ent/migrate"

	"github.com/valocode/bubbly/ent/adapter"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/cwe"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licenseuse"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecomponent"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/releasevulnerability"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/valocode/bubbly/ent/vulnerabilityreview"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Adapter is the client for interacting with the Adapter builders.
	Adapter *AdapterClient
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// CWE is the client for interacting with the CWE builders.
	CWE *CWEClient
	// CodeIssue is the client for interacting with the CodeIssue builders.
	CodeIssue *CodeIssueClient
	// CodeScan is the client for interacting with the CodeScan builders.
	CodeScan *CodeScanClient
	// Component is the client for interacting with the Component builders.
	Component *ComponentClient
	// GitCommit is the client for interacting with the GitCommit builders.
	GitCommit *GitCommitClient
	// License is the client for interacting with the License builders.
	License *LicenseClient
	// LicenseUse is the client for interacting with the LicenseUse builders.
	LicenseUse *LicenseUseClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Release is the client for interacting with the Release builders.
	Release *ReleaseClient
	// ReleaseComponent is the client for interacting with the ReleaseComponent builders.
	ReleaseComponent *ReleaseComponentClient
	// ReleaseEntry is the client for interacting with the ReleaseEntry builders.
	ReleaseEntry *ReleaseEntryClient
	// ReleaseVulnerability is the client for interacting with the ReleaseVulnerability builders.
	ReleaseVulnerability *ReleaseVulnerabilityClient
	// Repo is the client for interacting with the Repo builders.
	Repo *RepoClient
	// TestCase is the client for interacting with the TestCase builders.
	TestCase *TestCaseClient
	// TestRun is the client for interacting with the TestRun builders.
	TestRun *TestRunClient
	// Vulnerability is the client for interacting with the Vulnerability builders.
	Vulnerability *VulnerabilityClient
	// VulnerabilityReview is the client for interacting with the VulnerabilityReview builders.
	VulnerabilityReview *VulnerabilityReviewClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Adapter = NewAdapterClient(c.config)
	c.Artifact = NewArtifactClient(c.config)
	c.CWE = NewCWEClient(c.config)
	c.CodeIssue = NewCodeIssueClient(c.config)
	c.CodeScan = NewCodeScanClient(c.config)
	c.Component = NewComponentClient(c.config)
	c.GitCommit = NewGitCommitClient(c.config)
	c.License = NewLicenseClient(c.config)
	c.LicenseUse = NewLicenseUseClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Release = NewReleaseClient(c.config)
	c.ReleaseComponent = NewReleaseComponentClient(c.config)
	c.ReleaseEntry = NewReleaseEntryClient(c.config)
	c.ReleaseVulnerability = NewReleaseVulnerabilityClient(c.config)
	c.Repo = NewRepoClient(c.config)
	c.TestCase = NewTestCaseClient(c.config)
	c.TestRun = NewTestRunClient(c.config)
	c.Vulnerability = NewVulnerabilityClient(c.config)
	c.VulnerabilityReview = NewVulnerabilityReviewClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Adapter:              NewAdapterClient(cfg),
		Artifact:             NewArtifactClient(cfg),
		CWE:                  NewCWEClient(cfg),
		CodeIssue:            NewCodeIssueClient(cfg),
		CodeScan:             NewCodeScanClient(cfg),
		Component:            NewComponentClient(cfg),
		GitCommit:            NewGitCommitClient(cfg),
		License:              NewLicenseClient(cfg),
		LicenseUse:           NewLicenseUseClient(cfg),
		Project:              NewProjectClient(cfg),
		Release:              NewReleaseClient(cfg),
		ReleaseComponent:     NewReleaseComponentClient(cfg),
		ReleaseEntry:         NewReleaseEntryClient(cfg),
		ReleaseVulnerability: NewReleaseVulnerabilityClient(cfg),
		Repo:                 NewRepoClient(cfg),
		TestCase:             NewTestCaseClient(cfg),
		TestRun:              NewTestRunClient(cfg),
		Vulnerability:        NewVulnerabilityClient(cfg),
		VulnerabilityReview:  NewVulnerabilityReviewClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:               cfg,
		Adapter:              NewAdapterClient(cfg),
		Artifact:             NewArtifactClient(cfg),
		CWE:                  NewCWEClient(cfg),
		CodeIssue:            NewCodeIssueClient(cfg),
		CodeScan:             NewCodeScanClient(cfg),
		Component:            NewComponentClient(cfg),
		GitCommit:            NewGitCommitClient(cfg),
		License:              NewLicenseClient(cfg),
		LicenseUse:           NewLicenseUseClient(cfg),
		Project:              NewProjectClient(cfg),
		Release:              NewReleaseClient(cfg),
		ReleaseComponent:     NewReleaseComponentClient(cfg),
		ReleaseEntry:         NewReleaseEntryClient(cfg),
		ReleaseVulnerability: NewReleaseVulnerabilityClient(cfg),
		Repo:                 NewRepoClient(cfg),
		TestCase:             NewTestCaseClient(cfg),
		TestRun:              NewTestRunClient(cfg),
		Vulnerability:        NewVulnerabilityClient(cfg),
		VulnerabilityReview:  NewVulnerabilityReviewClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Adapter.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Adapter.Use(hooks...)
	c.Artifact.Use(hooks...)
	c.CWE.Use(hooks...)
	c.CodeIssue.Use(hooks...)
	c.CodeScan.Use(hooks...)
	c.Component.Use(hooks...)
	c.GitCommit.Use(hooks...)
	c.License.Use(hooks...)
	c.LicenseUse.Use(hooks...)
	c.Project.Use(hooks...)
	c.Release.Use(hooks...)
	c.ReleaseComponent.Use(hooks...)
	c.ReleaseEntry.Use(hooks...)
	c.ReleaseVulnerability.Use(hooks...)
	c.Repo.Use(hooks...)
	c.TestCase.Use(hooks...)
	c.TestRun.Use(hooks...)
	c.Vulnerability.Use(hooks...)
	c.VulnerabilityReview.Use(hooks...)
}

// AdapterClient is a client for the Adapter schema.
type AdapterClient struct {
	config
}

// NewAdapterClient returns a client for the Adapter from the given config.
func NewAdapterClient(c config) *AdapterClient {
	return &AdapterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adapter.Hooks(f(g(h())))`.
func (c *AdapterClient) Use(hooks ...Hook) {
	c.hooks.Adapter = append(c.hooks.Adapter, hooks...)
}

// Create returns a create builder for Adapter.
func (c *AdapterClient) Create() *AdapterCreate {
	mutation := newAdapterMutation(c.config, OpCreate)
	return &AdapterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Adapter entities.
func (c *AdapterClient) CreateBulk(builders ...*AdapterCreate) *AdapterCreateBulk {
	return &AdapterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Adapter.
func (c *AdapterClient) Update() *AdapterUpdate {
	mutation := newAdapterMutation(c.config, OpUpdate)
	return &AdapterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdapterClient) UpdateOne(a *Adapter) *AdapterUpdateOne {
	mutation := newAdapterMutation(c.config, OpUpdateOne, withAdapter(a))
	return &AdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdapterClient) UpdateOneID(id int) *AdapterUpdateOne {
	mutation := newAdapterMutation(c.config, OpUpdateOne, withAdapterID(id))
	return &AdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Adapter.
func (c *AdapterClient) Delete() *AdapterDelete {
	mutation := newAdapterMutation(c.config, OpDelete)
	return &AdapterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AdapterClient) DeleteOne(a *Adapter) *AdapterDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AdapterClient) DeleteOneID(id int) *AdapterDeleteOne {
	builder := c.Delete().Where(adapter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdapterDeleteOne{builder}
}

// Query returns a query builder for Adapter.
func (c *AdapterClient) Query() *AdapterQuery {
	return &AdapterQuery{
		config: c.config,
	}
}

// Get returns a Adapter entity by its id.
func (c *AdapterClient) Get(ctx context.Context, id int) (*Adapter, error) {
	return c.Query().Where(adapter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdapterClient) GetX(ctx context.Context, id int) *Adapter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AdapterClient) Hooks() []Hook {
	return c.hooks.Adapter
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Create returns a create builder for Artifact.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a Artifact.
func (c *ArtifactClient) QueryRelease(a *Artifact) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, artifact.ReleaseTable, artifact.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a Artifact.
func (c *ArtifactClient) QueryEntry(a *Artifact) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, artifact.EntryTable, artifact.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	hooks := c.hooks.Artifact
	return append(hooks[:len(hooks):len(hooks)], artifact.Hooks[:]...)
}

// CWEClient is a client for the CWE schema.
type CWEClient struct {
	config
}

// NewCWEClient returns a client for the CWE from the given config.
func NewCWEClient(c config) *CWEClient {
	return &CWEClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cwe.Hooks(f(g(h())))`.
func (c *CWEClient) Use(hooks ...Hook) {
	c.hooks.CWE = append(c.hooks.CWE, hooks...)
}

// Create returns a create builder for CWE.
func (c *CWEClient) Create() *CWECreate {
	mutation := newCWEMutation(c.config, OpCreate)
	return &CWECreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CWE entities.
func (c *CWEClient) CreateBulk(builders ...*CWECreate) *CWECreateBulk {
	return &CWECreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CWE.
func (c *CWEClient) Update() *CWEUpdate {
	mutation := newCWEMutation(c.config, OpUpdate)
	return &CWEUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CWEClient) UpdateOne(cw *CWE) *CWEUpdateOne {
	mutation := newCWEMutation(c.config, OpUpdateOne, withCWE(cw))
	return &CWEUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CWEClient) UpdateOneID(id int) *CWEUpdateOne {
	mutation := newCWEMutation(c.config, OpUpdateOne, withCWEID(id))
	return &CWEUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CWE.
func (c *CWEClient) Delete() *CWEDelete {
	mutation := newCWEMutation(c.config, OpDelete)
	return &CWEDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CWEClient) DeleteOne(cw *CWE) *CWEDeleteOne {
	return c.DeleteOneID(cw.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CWEClient) DeleteOneID(id int) *CWEDeleteOne {
	builder := c.Delete().Where(cwe.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CWEDeleteOne{builder}
}

// Query returns a query builder for CWE.
func (c *CWEClient) Query() *CWEQuery {
	return &CWEQuery{
		config: c.config,
	}
}

// Get returns a CWE entity by its id.
func (c *CWEClient) Get(ctx context.Context, id int) (*CWE, error) {
	return c.Query().Where(cwe.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CWEClient) GetX(ctx context.Context, id int) *CWE {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssues queries the issues edge of a CWE.
func (c *CWEClient) QueryIssues(cw *CWE) *CodeIssueQuery {
	query := &CodeIssueQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cw.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cwe.Table, cwe.FieldID, id),
			sqlgraph.To(codeissue.Table, codeissue.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, cwe.IssuesTable, cwe.IssuesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cw.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CWEClient) Hooks() []Hook {
	return c.hooks.CWE
}

// CodeIssueClient is a client for the CodeIssue schema.
type CodeIssueClient struct {
	config
}

// NewCodeIssueClient returns a client for the CodeIssue from the given config.
func NewCodeIssueClient(c config) *CodeIssueClient {
	return &CodeIssueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `codeissue.Hooks(f(g(h())))`.
func (c *CodeIssueClient) Use(hooks ...Hook) {
	c.hooks.CodeIssue = append(c.hooks.CodeIssue, hooks...)
}

// Create returns a create builder for CodeIssue.
func (c *CodeIssueClient) Create() *CodeIssueCreate {
	mutation := newCodeIssueMutation(c.config, OpCreate)
	return &CodeIssueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CodeIssue entities.
func (c *CodeIssueClient) CreateBulk(builders ...*CodeIssueCreate) *CodeIssueCreateBulk {
	return &CodeIssueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CodeIssue.
func (c *CodeIssueClient) Update() *CodeIssueUpdate {
	mutation := newCodeIssueMutation(c.config, OpUpdate)
	return &CodeIssueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CodeIssueClient) UpdateOne(ci *CodeIssue) *CodeIssueUpdateOne {
	mutation := newCodeIssueMutation(c.config, OpUpdateOne, withCodeIssue(ci))
	return &CodeIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CodeIssueClient) UpdateOneID(id int) *CodeIssueUpdateOne {
	mutation := newCodeIssueMutation(c.config, OpUpdateOne, withCodeIssueID(id))
	return &CodeIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CodeIssue.
func (c *CodeIssueClient) Delete() *CodeIssueDelete {
	mutation := newCodeIssueMutation(c.config, OpDelete)
	return &CodeIssueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CodeIssueClient) DeleteOne(ci *CodeIssue) *CodeIssueDeleteOne {
	return c.DeleteOneID(ci.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CodeIssueClient) DeleteOneID(id int) *CodeIssueDeleteOne {
	builder := c.Delete().Where(codeissue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CodeIssueDeleteOne{builder}
}

// Query returns a query builder for CodeIssue.
func (c *CodeIssueClient) Query() *CodeIssueQuery {
	return &CodeIssueQuery{
		config: c.config,
	}
}

// Get returns a CodeIssue entity by its id.
func (c *CodeIssueClient) Get(ctx context.Context, id int) (*CodeIssue, error) {
	return c.Query().Where(codeissue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CodeIssueClient) GetX(ctx context.Context, id int) *CodeIssue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCwe queries the cwe edge of a CodeIssue.
func (c *CodeIssueClient) QueryCwe(ci *CodeIssue) *CWEQuery {
	query := &CWEQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codeissue.Table, codeissue.FieldID, id),
			sqlgraph.To(cwe.Table, cwe.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, codeissue.CweTable, codeissue.CwePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScan queries the scan edge of a CodeIssue.
func (c *CodeIssueClient) QueryScan(ci *CodeIssue) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codeissue.Table, codeissue.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, codeissue.ScanTable, codeissue.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CodeIssueClient) Hooks() []Hook {
	return c.hooks.CodeIssue
}

// CodeScanClient is a client for the CodeScan schema.
type CodeScanClient struct {
	config
}

// NewCodeScanClient returns a client for the CodeScan from the given config.
func NewCodeScanClient(c config) *CodeScanClient {
	return &CodeScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `codescan.Hooks(f(g(h())))`.
func (c *CodeScanClient) Use(hooks ...Hook) {
	c.hooks.CodeScan = append(c.hooks.CodeScan, hooks...)
}

// Create returns a create builder for CodeScan.
func (c *CodeScanClient) Create() *CodeScanCreate {
	mutation := newCodeScanMutation(c.config, OpCreate)
	return &CodeScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CodeScan entities.
func (c *CodeScanClient) CreateBulk(builders ...*CodeScanCreate) *CodeScanCreateBulk {
	return &CodeScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CodeScan.
func (c *CodeScanClient) Update() *CodeScanUpdate {
	mutation := newCodeScanMutation(c.config, OpUpdate)
	return &CodeScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CodeScanClient) UpdateOne(cs *CodeScan) *CodeScanUpdateOne {
	mutation := newCodeScanMutation(c.config, OpUpdateOne, withCodeScan(cs))
	return &CodeScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CodeScanClient) UpdateOneID(id int) *CodeScanUpdateOne {
	mutation := newCodeScanMutation(c.config, OpUpdateOne, withCodeScanID(id))
	return &CodeScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CodeScan.
func (c *CodeScanClient) Delete() *CodeScanDelete {
	mutation := newCodeScanMutation(c.config, OpDelete)
	return &CodeScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CodeScanClient) DeleteOne(cs *CodeScan) *CodeScanDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CodeScanClient) DeleteOneID(id int) *CodeScanDeleteOne {
	builder := c.Delete().Where(codescan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CodeScanDeleteOne{builder}
}

// Query returns a query builder for CodeScan.
func (c *CodeScanClient) Query() *CodeScanQuery {
	return &CodeScanQuery{
		config: c.config,
	}
}

// Get returns a CodeScan entity by its id.
func (c *CodeScanClient) Get(ctx context.Context, id int) (*CodeScan, error) {
	return c.Query().Where(codescan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CodeScanClient) GetX(ctx context.Context, id int) *CodeScan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a CodeScan.
func (c *CodeScanClient) QueryRelease(cs *CodeScan) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, codescan.ReleaseTable, codescan.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a CodeScan.
func (c *CodeScanClient) QueryEntry(cs *CodeScan) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, codescan.EntryTable, codescan.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIssues queries the issues edge of a CodeScan.
func (c *CodeScanClient) QueryIssues(cs *CodeScan) *CodeIssueQuery {
	query := &CodeIssueQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(codeissue.Table, codeissue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, codescan.IssuesTable, codescan.IssuesColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a CodeScan.
func (c *CodeScanClient) QueryVulnerabilities(cs *CodeScan) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, codescan.VulnerabilitiesTable, codescan.VulnerabilitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a CodeScan.
func (c *CodeScanClient) QueryComponents(cs *CodeScan) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, codescan.ComponentsTable, codescan.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CodeScanClient) Hooks() []Hook {
	hooks := c.hooks.CodeScan
	return append(hooks[:len(hooks):len(hooks)], codescan.Hooks[:]...)
}

// ComponentClient is a client for the Component schema.
type ComponentClient struct {
	config
}

// NewComponentClient returns a client for the Component from the given config.
func NewComponentClient(c config) *ComponentClient {
	return &ComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `component.Hooks(f(g(h())))`.
func (c *ComponentClient) Use(hooks ...Hook) {
	c.hooks.Component = append(c.hooks.Component, hooks...)
}

// Create returns a create builder for Component.
func (c *ComponentClient) Create() *ComponentCreate {
	mutation := newComponentMutation(c.config, OpCreate)
	return &ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Component entities.
func (c *ComponentClient) CreateBulk(builders ...*ComponentCreate) *ComponentCreateBulk {
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Component.
func (c *ComponentClient) Update() *ComponentUpdate {
	mutation := newComponentMutation(c.config, OpUpdate)
	return &ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentClient) UpdateOne(co *Component) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponent(co))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentClient) UpdateOneID(id int) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponentID(id))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Component.
func (c *ComponentClient) Delete() *ComponentDelete {
	mutation := newComponentMutation(c.config, OpDelete)
	return &ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ComponentClient) DeleteOne(co *Component) *ComponentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ComponentClient) DeleteOneID(id int) *ComponentDeleteOne {
	builder := c.Delete().Where(component.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDeleteOne{builder}
}

// Query returns a query builder for Component.
func (c *ComponentClient) Query() *ComponentQuery {
	return &ComponentQuery{
		config: c.config,
	}
}

// Get returns a Component entity by its id.
func (c *ComponentClient) Get(ctx context.Context, id int) (*Component, error) {
	return c.Query().Where(component.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentClient) GetX(ctx context.Context, id int) *Component {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerabilities queries the vulnerabilities edge of a Component.
func (c *ComponentClient) QueryVulnerabilities(co *Component) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, component.VulnerabilitiesTable, component.VulnerabilitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenses queries the licenses edge of a Component.
func (c *ComponentClient) QueryLicenses(co *Component) *LicenseQuery {
	query := &LicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, component.LicensesTable, component.LicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUses queries the uses edge of a Component.
func (c *ComponentClient) QueryUses(co *Component) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, component.UsesTable, component.UsesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentClient) Hooks() []Hook {
	return c.hooks.Component
}

// GitCommitClient is a client for the GitCommit schema.
type GitCommitClient struct {
	config
}

// NewGitCommitClient returns a client for the GitCommit from the given config.
func NewGitCommitClient(c config) *GitCommitClient {
	return &GitCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gitcommit.Hooks(f(g(h())))`.
func (c *GitCommitClient) Use(hooks ...Hook) {
	c.hooks.GitCommit = append(c.hooks.GitCommit, hooks...)
}

// Create returns a create builder for GitCommit.
func (c *GitCommitClient) Create() *GitCommitCreate {
	mutation := newGitCommitMutation(c.config, OpCreate)
	return &GitCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GitCommit entities.
func (c *GitCommitClient) CreateBulk(builders ...*GitCommitCreate) *GitCommitCreateBulk {
	return &GitCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GitCommit.
func (c *GitCommitClient) Update() *GitCommitUpdate {
	mutation := newGitCommitMutation(c.config, OpUpdate)
	return &GitCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GitCommitClient) UpdateOne(gc *GitCommit) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommit(gc))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GitCommitClient) UpdateOneID(id int) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommitID(id))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GitCommit.
func (c *GitCommitClient) Delete() *GitCommitDelete {
	mutation := newGitCommitMutation(c.config, OpDelete)
	return &GitCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GitCommitClient) DeleteOne(gc *GitCommit) *GitCommitDeleteOne {
	return c.DeleteOneID(gc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GitCommitClient) DeleteOneID(id int) *GitCommitDeleteOne {
	builder := c.Delete().Where(gitcommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GitCommitDeleteOne{builder}
}

// Query returns a query builder for GitCommit.
func (c *GitCommitClient) Query() *GitCommitQuery {
	return &GitCommitQuery{
		config: c.config,
	}
}

// Get returns a GitCommit entity by its id.
func (c *GitCommitClient) Get(ctx context.Context, id int) (*GitCommit, error) {
	return c.Query().Where(gitcommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GitCommitClient) GetX(ctx context.Context, id int) *GitCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepo queries the repo edge of a GitCommit.
func (c *GitCommitClient) QueryRepo(gc *GitCommit) *RepoQuery {
	query := &RepoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gitcommit.Table, gitcommit.FieldID, id),
			sqlgraph.To(repo.Table, repo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, gitcommit.RepoTable, gitcommit.RepoColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a GitCommit.
func (c *GitCommitClient) QueryRelease(gc *GitCommit) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gitcommit.Table, gitcommit.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, gitcommit.ReleaseTable, gitcommit.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GitCommitClient) Hooks() []Hook {
	return c.hooks.GitCommit
}

// LicenseClient is a client for the License schema.
type LicenseClient struct {
	config
}

// NewLicenseClient returns a client for the License from the given config.
func NewLicenseClient(c config) *LicenseClient {
	return &LicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `license.Hooks(f(g(h())))`.
func (c *LicenseClient) Use(hooks ...Hook) {
	c.hooks.License = append(c.hooks.License, hooks...)
}

// Create returns a create builder for License.
func (c *LicenseClient) Create() *LicenseCreate {
	mutation := newLicenseMutation(c.config, OpCreate)
	return &LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of License entities.
func (c *LicenseClient) CreateBulk(builders ...*LicenseCreate) *LicenseCreateBulk {
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for License.
func (c *LicenseClient) Update() *LicenseUpdate {
	mutation := newLicenseMutation(c.config, OpUpdate)
	return &LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseClient) UpdateOne(l *License) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicense(l))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseClient) UpdateOneID(id int) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicenseID(id))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for License.
func (c *LicenseClient) Delete() *LicenseDelete {
	mutation := newLicenseMutation(c.config, OpDelete)
	return &LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LicenseClient) DeleteOne(l *License) *LicenseDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LicenseClient) DeleteOneID(id int) *LicenseDeleteOne {
	builder := c.Delete().Where(license.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseDeleteOne{builder}
}

// Query returns a query builder for License.
func (c *LicenseClient) Query() *LicenseQuery {
	return &LicenseQuery{
		config: c.config,
	}
}

// Get returns a License entity by its id.
func (c *LicenseClient) Get(ctx context.Context, id int) (*License, error) {
	return c.Query().Where(license.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseClient) GetX(ctx context.Context, id int) *License {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a License.
func (c *LicenseClient) QueryComponents(l *License) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, license.ComponentsTable, license.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUses queries the uses edge of a License.
func (c *LicenseClient) QueryUses(l *License) *LicenseUseQuery {
	query := &LicenseUseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(licenseuse.Table, licenseuse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, license.UsesTable, license.UsesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseClient) Hooks() []Hook {
	return c.hooks.License
}

// LicenseUseClient is a client for the LicenseUse schema.
type LicenseUseClient struct {
	config
}

// NewLicenseUseClient returns a client for the LicenseUse from the given config.
func NewLicenseUseClient(c config) *LicenseUseClient {
	return &LicenseUseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `licenseuse.Hooks(f(g(h())))`.
func (c *LicenseUseClient) Use(hooks ...Hook) {
	c.hooks.LicenseUse = append(c.hooks.LicenseUse, hooks...)
}

// Create returns a create builder for LicenseUse.
func (c *LicenseUseClient) Create() *LicenseUseCreate {
	mutation := newLicenseUseMutation(c.config, OpCreate)
	return &LicenseUseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LicenseUse entities.
func (c *LicenseUseClient) CreateBulk(builders ...*LicenseUseCreate) *LicenseUseCreateBulk {
	return &LicenseUseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LicenseUse.
func (c *LicenseUseClient) Update() *LicenseUseUpdate {
	mutation := newLicenseUseMutation(c.config, OpUpdate)
	return &LicenseUseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseUseClient) UpdateOne(lu *LicenseUse) *LicenseUseUpdateOne {
	mutation := newLicenseUseMutation(c.config, OpUpdateOne, withLicenseUse(lu))
	return &LicenseUseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseUseClient) UpdateOneID(id int) *LicenseUseUpdateOne {
	mutation := newLicenseUseMutation(c.config, OpUpdateOne, withLicenseUseID(id))
	return &LicenseUseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LicenseUse.
func (c *LicenseUseClient) Delete() *LicenseUseDelete {
	mutation := newLicenseUseMutation(c.config, OpDelete)
	return &LicenseUseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LicenseUseClient) DeleteOne(lu *LicenseUse) *LicenseUseDeleteOne {
	return c.DeleteOneID(lu.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LicenseUseClient) DeleteOneID(id int) *LicenseUseDeleteOne {
	builder := c.Delete().Where(licenseuse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseUseDeleteOne{builder}
}

// Query returns a query builder for LicenseUse.
func (c *LicenseUseClient) Query() *LicenseUseQuery {
	return &LicenseUseQuery{
		config: c.config,
	}
}

// Get returns a LicenseUse entity by its id.
func (c *LicenseUseClient) Get(ctx context.Context, id int) (*LicenseUse, error) {
	return c.Query().Where(licenseuse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseUseClient) GetX(ctx context.Context, id int) *LicenseUse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLicense queries the license edge of a LicenseUse.
func (c *LicenseUseClient) QueryLicense(lu *LicenseUse) *LicenseQuery {
	query := &LicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := lu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(licenseuse.Table, licenseuse.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, licenseuse.LicenseTable, licenseuse.LicenseColumn),
		)
		fromV = sqlgraph.Neighbors(lu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseUseClient) Hooks() []Hook {
	return c.hooks.LicenseUse
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Create returns a create builder for Project.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepos queries the repos edge of a Project.
func (c *ProjectClient) QueryRepos(pr *Project) *RepoQuery {
	query := &RepoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(repo.Table, repo.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, project.ReposTable, project.ReposPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilityReviews queries the vulnerability_reviews edge of a Project.
func (c *ProjectClient) QueryVulnerabilityReviews(pr *Project) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, project.VulnerabilityReviewsTable, project.VulnerabilityReviewsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// ReleaseClient is a client for the Release schema.
type ReleaseClient struct {
	config
}

// NewReleaseClient returns a client for the Release from the given config.
func NewReleaseClient(c config) *ReleaseClient {
	return &ReleaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `release.Hooks(f(g(h())))`.
func (c *ReleaseClient) Use(hooks ...Hook) {
	c.hooks.Release = append(c.hooks.Release, hooks...)
}

// Create returns a create builder for Release.
func (c *ReleaseClient) Create() *ReleaseCreate {
	mutation := newReleaseMutation(c.config, OpCreate)
	return &ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Release entities.
func (c *ReleaseClient) CreateBulk(builders ...*ReleaseCreate) *ReleaseCreateBulk {
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Release.
func (c *ReleaseClient) Update() *ReleaseUpdate {
	mutation := newReleaseMutation(c.config, OpUpdate)
	return &ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseClient) UpdateOne(r *Release) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withRelease(r))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseClient) UpdateOneID(id int) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withReleaseID(id))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Release.
func (c *ReleaseClient) Delete() *ReleaseDelete {
	mutation := newReleaseMutation(c.config, OpDelete)
	return &ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseClient) DeleteOne(r *Release) *ReleaseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseClient) DeleteOneID(id int) *ReleaseDeleteOne {
	builder := c.Delete().Where(release.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseDeleteOne{builder}
}

// Query returns a query builder for Release.
func (c *ReleaseClient) Query() *ReleaseQuery {
	return &ReleaseQuery{
		config: c.config,
	}
}

// Get returns a Release entity by its id.
func (c *ReleaseClient) Get(ctx context.Context, id int) (*Release, error) {
	return c.Query().Where(release.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseClient) GetX(ctx context.Context, id int) *Release {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubreleases queries the subreleases edge of a Release.
func (c *ReleaseClient) QuerySubreleases(r *Release) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, release.SubreleasesTable, release.SubreleasesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Release.
func (c *ReleaseClient) QueryDependencies(r *Release) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, release.DependenciesTable, release.DependenciesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommit queries the commit edge of a Release.
func (c *ReleaseClient) QueryCommit(r *Release) *GitCommitQuery {
	query := &GitCommitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(gitcommit.Table, gitcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, release.CommitTable, release.CommitColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHeadOf queries the head_of edge of a Release.
func (c *ReleaseClient) QueryHeadOf(r *Release) *RepoQuery {
	query := &RepoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(repo.Table, repo.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, release.HeadOfTable, release.HeadOfColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLog queries the log edge of a Release.
func (c *ReleaseClient) QueryLog(r *Release) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.LogTable, release.LogColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Release.
func (c *ReleaseClient) QueryArtifacts(r *Release) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.ArtifactsTable, release.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a Release.
func (c *ReleaseClient) QueryComponents(r *Release) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.ComponentsTable, release.ComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a Release.
func (c *ReleaseClient) QueryVulnerabilities(r *Release) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.VulnerabilitiesTable, release.VulnerabilitiesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCodeScans queries the code_scans edge of a Release.
func (c *ReleaseClient) QueryCodeScans(r *Release) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.CodeScansTable, release.CodeScansColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestRuns queries the test_runs edge of a Release.
func (c *ReleaseClient) QueryTestRuns(r *Release) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.TestRunsTable, release.TestRunsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilityReviews queries the vulnerability_reviews edge of a Release.
func (c *ReleaseClient) QueryVulnerabilityReviews(r *Release) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, release.VulnerabilityReviewsTable, release.VulnerabilityReviewsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseClient) Hooks() []Hook {
	hooks := c.hooks.Release
	return append(hooks[:len(hooks):len(hooks)], release.Hooks[:]...)
}

// ReleaseComponentClient is a client for the ReleaseComponent schema.
type ReleaseComponentClient struct {
	config
}

// NewReleaseComponentClient returns a client for the ReleaseComponent from the given config.
func NewReleaseComponentClient(c config) *ReleaseComponentClient {
	return &ReleaseComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releasecomponent.Hooks(f(g(h())))`.
func (c *ReleaseComponentClient) Use(hooks ...Hook) {
	c.hooks.ReleaseComponent = append(c.hooks.ReleaseComponent, hooks...)
}

// Create returns a create builder for ReleaseComponent.
func (c *ReleaseComponentClient) Create() *ReleaseComponentCreate {
	mutation := newReleaseComponentMutation(c.config, OpCreate)
	return &ReleaseComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseComponent entities.
func (c *ReleaseComponentClient) CreateBulk(builders ...*ReleaseComponentCreate) *ReleaseComponentCreateBulk {
	return &ReleaseComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseComponent.
func (c *ReleaseComponentClient) Update() *ReleaseComponentUpdate {
	mutation := newReleaseComponentMutation(c.config, OpUpdate)
	return &ReleaseComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseComponentClient) UpdateOne(rc *ReleaseComponent) *ReleaseComponentUpdateOne {
	mutation := newReleaseComponentMutation(c.config, OpUpdateOne, withReleaseComponent(rc))
	return &ReleaseComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseComponentClient) UpdateOneID(id int) *ReleaseComponentUpdateOne {
	mutation := newReleaseComponentMutation(c.config, OpUpdateOne, withReleaseComponentID(id))
	return &ReleaseComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseComponent.
func (c *ReleaseComponentClient) Delete() *ReleaseComponentDelete {
	mutation := newReleaseComponentMutation(c.config, OpDelete)
	return &ReleaseComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseComponentClient) DeleteOne(rc *ReleaseComponent) *ReleaseComponentDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseComponentClient) DeleteOneID(id int) *ReleaseComponentDeleteOne {
	builder := c.Delete().Where(releasecomponent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseComponentDeleteOne{builder}
}

// Query returns a query builder for ReleaseComponent.
func (c *ReleaseComponentClient) Query() *ReleaseComponentQuery {
	return &ReleaseComponentQuery{
		config: c.config,
	}
}

// Get returns a ReleaseComponent entity by its id.
func (c *ReleaseComponentClient) Get(ctx context.Context, id int) (*ReleaseComponent, error) {
	return c.Query().Where(releasecomponent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseComponentClient) GetX(ctx context.Context, id int) *ReleaseComponent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryRelease(rc *ReleaseComponent) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasecomponent.ReleaseTable, releasecomponent.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryScans(rc *ReleaseComponent) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, releasecomponent.ScansTable, releasecomponent.ScansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryComponent(rc *ReleaseComponent) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasecomponent.ComponentTable, releasecomponent.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a ReleaseComponent.
func (c *ReleaseComponentClient) QueryVulnerabilities(rc *ReleaseComponent) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecomponent.Table, releasecomponent.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, releasecomponent.VulnerabilitiesTable, releasecomponent.VulnerabilitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseComponentClient) Hooks() []Hook {
	hooks := c.hooks.ReleaseComponent
	return append(hooks[:len(hooks):len(hooks)], releasecomponent.Hooks[:]...)
}

// ReleaseEntryClient is a client for the ReleaseEntry schema.
type ReleaseEntryClient struct {
	config
}

// NewReleaseEntryClient returns a client for the ReleaseEntry from the given config.
func NewReleaseEntryClient(c config) *ReleaseEntryClient {
	return &ReleaseEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releaseentry.Hooks(f(g(h())))`.
func (c *ReleaseEntryClient) Use(hooks ...Hook) {
	c.hooks.ReleaseEntry = append(c.hooks.ReleaseEntry, hooks...)
}

// Create returns a create builder for ReleaseEntry.
func (c *ReleaseEntryClient) Create() *ReleaseEntryCreate {
	mutation := newReleaseEntryMutation(c.config, OpCreate)
	return &ReleaseEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseEntry entities.
func (c *ReleaseEntryClient) CreateBulk(builders ...*ReleaseEntryCreate) *ReleaseEntryCreateBulk {
	return &ReleaseEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseEntry.
func (c *ReleaseEntryClient) Update() *ReleaseEntryUpdate {
	mutation := newReleaseEntryMutation(c.config, OpUpdate)
	return &ReleaseEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseEntryClient) UpdateOne(re *ReleaseEntry) *ReleaseEntryUpdateOne {
	mutation := newReleaseEntryMutation(c.config, OpUpdateOne, withReleaseEntry(re))
	return &ReleaseEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseEntryClient) UpdateOneID(id int) *ReleaseEntryUpdateOne {
	mutation := newReleaseEntryMutation(c.config, OpUpdateOne, withReleaseEntryID(id))
	return &ReleaseEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseEntry.
func (c *ReleaseEntryClient) Delete() *ReleaseEntryDelete {
	mutation := newReleaseEntryMutation(c.config, OpDelete)
	return &ReleaseEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseEntryClient) DeleteOne(re *ReleaseEntry) *ReleaseEntryDeleteOne {
	return c.DeleteOneID(re.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseEntryClient) DeleteOneID(id int) *ReleaseEntryDeleteOne {
	builder := c.Delete().Where(releaseentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseEntryDeleteOne{builder}
}

// Query returns a query builder for ReleaseEntry.
func (c *ReleaseEntryClient) Query() *ReleaseEntryQuery {
	return &ReleaseEntryQuery{
		config: c.config,
	}
}

// Get returns a ReleaseEntry entity by its id.
func (c *ReleaseEntryClient) Get(ctx context.Context, id int) (*ReleaseEntry, error) {
	return c.Query().Where(releaseentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseEntryClient) GetX(ctx context.Context, id int) *ReleaseEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifact queries the artifact edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryArtifact(re *ReleaseEntry) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.ArtifactTable, releaseentry.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCodeScan queries the code_scan edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryCodeScan(re *ReleaseEntry) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.CodeScanTable, releaseentry.CodeScanColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestRun queries the test_run edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryTestRun(re *ReleaseEntry) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.TestRunTable, releaseentry.TestRunColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryRelease(re *ReleaseEntry) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releaseentry.ReleaseTable, releaseentry.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseEntryClient) Hooks() []Hook {
	return c.hooks.ReleaseEntry
}

// ReleaseVulnerabilityClient is a client for the ReleaseVulnerability schema.
type ReleaseVulnerabilityClient struct {
	config
}

// NewReleaseVulnerabilityClient returns a client for the ReleaseVulnerability from the given config.
func NewReleaseVulnerabilityClient(c config) *ReleaseVulnerabilityClient {
	return &ReleaseVulnerabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releasevulnerability.Hooks(f(g(h())))`.
func (c *ReleaseVulnerabilityClient) Use(hooks ...Hook) {
	c.hooks.ReleaseVulnerability = append(c.hooks.ReleaseVulnerability, hooks...)
}

// Create returns a create builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Create() *ReleaseVulnerabilityCreate {
	mutation := newReleaseVulnerabilityMutation(c.config, OpCreate)
	return &ReleaseVulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseVulnerability entities.
func (c *ReleaseVulnerabilityClient) CreateBulk(builders ...*ReleaseVulnerabilityCreate) *ReleaseVulnerabilityCreateBulk {
	return &ReleaseVulnerabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Update() *ReleaseVulnerabilityUpdate {
	mutation := newReleaseVulnerabilityMutation(c.config, OpUpdate)
	return &ReleaseVulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseVulnerabilityClient) UpdateOne(rv *ReleaseVulnerability) *ReleaseVulnerabilityUpdateOne {
	mutation := newReleaseVulnerabilityMutation(c.config, OpUpdateOne, withReleaseVulnerability(rv))
	return &ReleaseVulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseVulnerabilityClient) UpdateOneID(id int) *ReleaseVulnerabilityUpdateOne {
	mutation := newReleaseVulnerabilityMutation(c.config, OpUpdateOne, withReleaseVulnerabilityID(id))
	return &ReleaseVulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Delete() *ReleaseVulnerabilityDelete {
	mutation := newReleaseVulnerabilityMutation(c.config, OpDelete)
	return &ReleaseVulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseVulnerabilityClient) DeleteOne(rv *ReleaseVulnerability) *ReleaseVulnerabilityDeleteOne {
	return c.DeleteOneID(rv.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseVulnerabilityClient) DeleteOneID(id int) *ReleaseVulnerabilityDeleteOne {
	builder := c.Delete().Where(releasevulnerability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseVulnerabilityDeleteOne{builder}
}

// Query returns a query builder for ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) Query() *ReleaseVulnerabilityQuery {
	return &ReleaseVulnerabilityQuery{
		config: c.config,
	}
}

// Get returns a ReleaseVulnerability entity by its id.
func (c *ReleaseVulnerabilityClient) Get(ctx context.Context, id int) (*ReleaseVulnerability, error) {
	return c.Query().Where(releasevulnerability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseVulnerabilityClient) GetX(ctx context.Context, id int) *ReleaseVulnerability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerability queries the vulnerability edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryVulnerability(rv *ReleaseVulnerability) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasevulnerability.VulnerabilityTable, releasevulnerability.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryComponents(rv *ReleaseVulnerability) *ReleaseComponentQuery {
	query := &ReleaseComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(releasecomponent.Table, releasecomponent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, releasevulnerability.ComponentsTable, releasevulnerability.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryRelease(rv *ReleaseVulnerability) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasevulnerability.ReleaseTable, releasevulnerability.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryReviews(rv *ReleaseVulnerability) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, releasevulnerability.ReviewsTable, releasevulnerability.ReviewsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScans queries the scans edge of a ReleaseVulnerability.
func (c *ReleaseVulnerabilityClient) QueryScans(rv *ReleaseVulnerability) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasevulnerability.Table, releasevulnerability.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, releasevulnerability.ScansTable, releasevulnerability.ScansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseVulnerabilityClient) Hooks() []Hook {
	return c.hooks.ReleaseVulnerability
}

// RepoClient is a client for the Repo schema.
type RepoClient struct {
	config
}

// NewRepoClient returns a client for the Repo from the given config.
func NewRepoClient(c config) *RepoClient {
	return &RepoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repo.Hooks(f(g(h())))`.
func (c *RepoClient) Use(hooks ...Hook) {
	c.hooks.Repo = append(c.hooks.Repo, hooks...)
}

// Create returns a create builder for Repo.
func (c *RepoClient) Create() *RepoCreate {
	mutation := newRepoMutation(c.config, OpCreate)
	return &RepoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Repo entities.
func (c *RepoClient) CreateBulk(builders ...*RepoCreate) *RepoCreateBulk {
	return &RepoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Repo.
func (c *RepoClient) Update() *RepoUpdate {
	mutation := newRepoMutation(c.config, OpUpdate)
	return &RepoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepoClient) UpdateOne(r *Repo) *RepoUpdateOne {
	mutation := newRepoMutation(c.config, OpUpdateOne, withRepo(r))
	return &RepoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepoClient) UpdateOneID(id int) *RepoUpdateOne {
	mutation := newRepoMutation(c.config, OpUpdateOne, withRepoID(id))
	return &RepoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Repo.
func (c *RepoClient) Delete() *RepoDelete {
	mutation := newRepoMutation(c.config, OpDelete)
	return &RepoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RepoClient) DeleteOne(r *Repo) *RepoDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RepoClient) DeleteOneID(id int) *RepoDeleteOne {
	builder := c.Delete().Where(repo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepoDeleteOne{builder}
}

// Query returns a query builder for Repo.
func (c *RepoClient) Query() *RepoQuery {
	return &RepoQuery{
		config: c.config,
	}
}

// Get returns a Repo entity by its id.
func (c *RepoClient) Get(ctx context.Context, id int) (*Repo, error) {
	return c.Query().Where(repo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepoClient) GetX(ctx context.Context, id int) *Repo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProjects queries the projects edge of a Repo.
func (c *RepoClient) QueryProjects(r *Repo) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repo.Table, repo.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, repo.ProjectsTable, repo.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHead queries the head edge of a Repo.
func (c *RepoClient) QueryHead(r *Repo) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repo.Table, repo.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, repo.HeadTable, repo.HeadColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommits queries the commits edge of a Repo.
func (c *RepoClient) QueryCommits(r *Repo) *GitCommitQuery {
	query := &GitCommitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repo.Table, repo.FieldID, id),
			sqlgraph.To(gitcommit.Table, gitcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, repo.CommitsTable, repo.CommitsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilityReviews queries the vulnerability_reviews edge of a Repo.
func (c *RepoClient) QueryVulnerabilityReviews(r *Repo) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repo.Table, repo.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, repo.VulnerabilityReviewsTable, repo.VulnerabilityReviewsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepoClient) Hooks() []Hook {
	return c.hooks.Repo
}

// TestCaseClient is a client for the TestCase schema.
type TestCaseClient struct {
	config
}

// NewTestCaseClient returns a client for the TestCase from the given config.
func NewTestCaseClient(c config) *TestCaseClient {
	return &TestCaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testcase.Hooks(f(g(h())))`.
func (c *TestCaseClient) Use(hooks ...Hook) {
	c.hooks.TestCase = append(c.hooks.TestCase, hooks...)
}

// Create returns a create builder for TestCase.
func (c *TestCaseClient) Create() *TestCaseCreate {
	mutation := newTestCaseMutation(c.config, OpCreate)
	return &TestCaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestCase entities.
func (c *TestCaseClient) CreateBulk(builders ...*TestCaseCreate) *TestCaseCreateBulk {
	return &TestCaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestCase.
func (c *TestCaseClient) Update() *TestCaseUpdate {
	mutation := newTestCaseMutation(c.config, OpUpdate)
	return &TestCaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestCaseClient) UpdateOne(tc *TestCase) *TestCaseUpdateOne {
	mutation := newTestCaseMutation(c.config, OpUpdateOne, withTestCase(tc))
	return &TestCaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestCaseClient) UpdateOneID(id int) *TestCaseUpdateOne {
	mutation := newTestCaseMutation(c.config, OpUpdateOne, withTestCaseID(id))
	return &TestCaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestCase.
func (c *TestCaseClient) Delete() *TestCaseDelete {
	mutation := newTestCaseMutation(c.config, OpDelete)
	return &TestCaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TestCaseClient) DeleteOne(tc *TestCase) *TestCaseDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TestCaseClient) DeleteOneID(id int) *TestCaseDeleteOne {
	builder := c.Delete().Where(testcase.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestCaseDeleteOne{builder}
}

// Query returns a query builder for TestCase.
func (c *TestCaseClient) Query() *TestCaseQuery {
	return &TestCaseQuery{
		config: c.config,
	}
}

// Get returns a TestCase entity by its id.
func (c *TestCaseClient) Get(ctx context.Context, id int) (*TestCase, error) {
	return c.Query().Where(testcase.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestCaseClient) GetX(ctx context.Context, id int) *TestCase {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRun queries the run edge of a TestCase.
func (c *TestCaseClient) QueryRun(tc *TestCase) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testcase.Table, testcase.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testcase.RunTable, testcase.RunColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestCaseClient) Hooks() []Hook {
	return c.hooks.TestCase
}

// TestRunClient is a client for the TestRun schema.
type TestRunClient struct {
	config
}

// NewTestRunClient returns a client for the TestRun from the given config.
func NewTestRunClient(c config) *TestRunClient {
	return &TestRunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testrun.Hooks(f(g(h())))`.
func (c *TestRunClient) Use(hooks ...Hook) {
	c.hooks.TestRun = append(c.hooks.TestRun, hooks...)
}

// Create returns a create builder for TestRun.
func (c *TestRunClient) Create() *TestRunCreate {
	mutation := newTestRunMutation(c.config, OpCreate)
	return &TestRunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestRun entities.
func (c *TestRunClient) CreateBulk(builders ...*TestRunCreate) *TestRunCreateBulk {
	return &TestRunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestRun.
func (c *TestRunClient) Update() *TestRunUpdate {
	mutation := newTestRunMutation(c.config, OpUpdate)
	return &TestRunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestRunClient) UpdateOne(tr *TestRun) *TestRunUpdateOne {
	mutation := newTestRunMutation(c.config, OpUpdateOne, withTestRun(tr))
	return &TestRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestRunClient) UpdateOneID(id int) *TestRunUpdateOne {
	mutation := newTestRunMutation(c.config, OpUpdateOne, withTestRunID(id))
	return &TestRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestRun.
func (c *TestRunClient) Delete() *TestRunDelete {
	mutation := newTestRunMutation(c.config, OpDelete)
	return &TestRunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TestRunClient) DeleteOne(tr *TestRun) *TestRunDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TestRunClient) DeleteOneID(id int) *TestRunDeleteOne {
	builder := c.Delete().Where(testrun.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestRunDeleteOne{builder}
}

// Query returns a query builder for TestRun.
func (c *TestRunClient) Query() *TestRunQuery {
	return &TestRunQuery{
		config: c.config,
	}
}

// Get returns a TestRun entity by its id.
func (c *TestRunClient) Get(ctx context.Context, id int) (*TestRun, error) {
	return c.Query().Where(testrun.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestRunClient) GetX(ctx context.Context, id int) *TestRun {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a TestRun.
func (c *TestRunClient) QueryRelease(tr *TestRun) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testrun.ReleaseTable, testrun.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a TestRun.
func (c *TestRunClient) QueryEntry(tr *TestRun) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, testrun.EntryTable, testrun.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a TestRun.
func (c *TestRunClient) QueryTests(tr *TestRun) *TestCaseQuery {
	query := &TestCaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(testcase.Table, testcase.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, testrun.TestsTable, testrun.TestsColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestRunClient) Hooks() []Hook {
	hooks := c.hooks.TestRun
	return append(hooks[:len(hooks):len(hooks)], testrun.Hooks[:]...)
}

// VulnerabilityClient is a client for the Vulnerability schema.
type VulnerabilityClient struct {
	config
}

// NewVulnerabilityClient returns a client for the Vulnerability from the given config.
func NewVulnerabilityClient(c config) *VulnerabilityClient {
	return &VulnerabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerability.Hooks(f(g(h())))`.
func (c *VulnerabilityClient) Use(hooks ...Hook) {
	c.hooks.Vulnerability = append(c.hooks.Vulnerability, hooks...)
}

// Create returns a create builder for Vulnerability.
func (c *VulnerabilityClient) Create() *VulnerabilityCreate {
	mutation := newVulnerabilityMutation(c.config, OpCreate)
	return &VulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vulnerability entities.
func (c *VulnerabilityClient) CreateBulk(builders ...*VulnerabilityCreate) *VulnerabilityCreateBulk {
	return &VulnerabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vulnerability.
func (c *VulnerabilityClient) Update() *VulnerabilityUpdate {
	mutation := newVulnerabilityMutation(c.config, OpUpdate)
	return &VulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityClient) UpdateOne(v *Vulnerability) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerability(v))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityClient) UpdateOneID(id int) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerabilityID(id))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vulnerability.
func (c *VulnerabilityClient) Delete() *VulnerabilityDelete {
	mutation := newVulnerabilityMutation(c.config, OpDelete)
	return &VulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VulnerabilityClient) DeleteOne(v *Vulnerability) *VulnerabilityDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VulnerabilityClient) DeleteOneID(id int) *VulnerabilityDeleteOne {
	builder := c.Delete().Where(vulnerability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityDeleteOne{builder}
}

// Query returns a query builder for Vulnerability.
func (c *VulnerabilityClient) Query() *VulnerabilityQuery {
	return &VulnerabilityQuery{
		config: c.config,
	}
}

// Get returns a Vulnerability entity by its id.
func (c *VulnerabilityClient) Get(ctx context.Context, id int) (*Vulnerability, error) {
	return c.Query().Where(vulnerability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityClient) GetX(ctx context.Context, id int) *Vulnerability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a Vulnerability.
func (c *VulnerabilityClient) QueryComponents(v *Vulnerability) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, vulnerability.ComponentsTable, vulnerability.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReviews queries the reviews edge of a Vulnerability.
func (c *VulnerabilityClient) QueryReviews(v *Vulnerability) *VulnerabilityReviewQuery {
	query := &VulnerabilityReviewQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(vulnerabilityreview.Table, vulnerabilityreview.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerability.ReviewsTable, vulnerability.ReviewsColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a Vulnerability.
func (c *VulnerabilityClient) QueryInstances(v *Vulnerability) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, vulnerability.InstancesTable, vulnerability.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityClient) Hooks() []Hook {
	hooks := c.hooks.Vulnerability
	return append(hooks[:len(hooks):len(hooks)], vulnerability.Hooks[:]...)
}

// VulnerabilityReviewClient is a client for the VulnerabilityReview schema.
type VulnerabilityReviewClient struct {
	config
}

// NewVulnerabilityReviewClient returns a client for the VulnerabilityReview from the given config.
func NewVulnerabilityReviewClient(c config) *VulnerabilityReviewClient {
	return &VulnerabilityReviewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerabilityreview.Hooks(f(g(h())))`.
func (c *VulnerabilityReviewClient) Use(hooks ...Hook) {
	c.hooks.VulnerabilityReview = append(c.hooks.VulnerabilityReview, hooks...)
}

// Create returns a create builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Create() *VulnerabilityReviewCreate {
	mutation := newVulnerabilityReviewMutation(c.config, OpCreate)
	return &VulnerabilityReviewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VulnerabilityReview entities.
func (c *VulnerabilityReviewClient) CreateBulk(builders ...*VulnerabilityReviewCreate) *VulnerabilityReviewCreateBulk {
	return &VulnerabilityReviewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Update() *VulnerabilityReviewUpdate {
	mutation := newVulnerabilityReviewMutation(c.config, OpUpdate)
	return &VulnerabilityReviewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityReviewClient) UpdateOne(vr *VulnerabilityReview) *VulnerabilityReviewUpdateOne {
	mutation := newVulnerabilityReviewMutation(c.config, OpUpdateOne, withVulnerabilityReview(vr))
	return &VulnerabilityReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityReviewClient) UpdateOneID(id int) *VulnerabilityReviewUpdateOne {
	mutation := newVulnerabilityReviewMutation(c.config, OpUpdateOne, withVulnerabilityReviewID(id))
	return &VulnerabilityReviewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Delete() *VulnerabilityReviewDelete {
	mutation := newVulnerabilityReviewMutation(c.config, OpDelete)
	return &VulnerabilityReviewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VulnerabilityReviewClient) DeleteOne(vr *VulnerabilityReview) *VulnerabilityReviewDeleteOne {
	return c.DeleteOneID(vr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VulnerabilityReviewClient) DeleteOneID(id int) *VulnerabilityReviewDeleteOne {
	builder := c.Delete().Where(vulnerabilityreview.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityReviewDeleteOne{builder}
}

// Query returns a query builder for VulnerabilityReview.
func (c *VulnerabilityReviewClient) Query() *VulnerabilityReviewQuery {
	return &VulnerabilityReviewQuery{
		config: c.config,
	}
}

// Get returns a VulnerabilityReview entity by its id.
func (c *VulnerabilityReviewClient) Get(ctx context.Context, id int) (*VulnerabilityReview, error) {
	return c.Query().Where(vulnerabilityreview.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityReviewClient) GetX(ctx context.Context, id int) *VulnerabilityReview {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerability queries the vulnerability edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryVulnerability(vr *VulnerabilityReview) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnerabilityreview.VulnerabilityTable, vulnerabilityreview.VulnerabilityColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjects queries the projects edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryProjects(vr *VulnerabilityReview) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, vulnerabilityreview.ProjectsTable, vulnerabilityreview.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepos queries the repos edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryRepos(vr *VulnerabilityReview) *RepoQuery {
	query := &RepoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(repo.Table, repo.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, vulnerabilityreview.ReposTable, vulnerabilityreview.ReposPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReleases queries the releases edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryReleases(vr *VulnerabilityReview) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, vulnerabilityreview.ReleasesTable, vulnerabilityreview.ReleasesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a VulnerabilityReview.
func (c *VulnerabilityReviewClient) QueryInstances(vr *VulnerabilityReview) *ReleaseVulnerabilityQuery {
	query := &ReleaseVulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerabilityreview.Table, vulnerabilityreview.FieldID, id),
			sqlgraph.To(releasevulnerability.Table, releasevulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, vulnerabilityreview.InstancesTable, vulnerabilityreview.InstancesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityReviewClient) Hooks() []Hook {
	return c.hooks.VulnerabilityReview
}
