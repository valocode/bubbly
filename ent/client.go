// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/valocode/bubbly/ent/migrate"

	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/cve"
	"github.com/valocode/bubbly/ent/cverule"
	"github.com/valocode/bubbly/ent/cvescan"
	"github.com/valocode/bubbly/ent/cwe"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/licensescan"
	"github.com/valocode/bubbly/ent/licenseusage"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecheck"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Artifact is the client for interacting with the Artifact builders.
	Artifact *ArtifactClient
	// CVE is the client for interacting with the CVE builders.
	CVE *CVEClient
	// CVERule is the client for interacting with the CVERule builders.
	CVERule *CVERuleClient
	// CVEScan is the client for interacting with the CVEScan builders.
	CVEScan *CVEScanClient
	// CWE is the client for interacting with the CWE builders.
	CWE *CWEClient
	// CodeIssue is the client for interacting with the CodeIssue builders.
	CodeIssue *CodeIssueClient
	// CodeScan is the client for interacting with the CodeScan builders.
	CodeScan *CodeScanClient
	// Component is the client for interacting with the Component builders.
	Component *ComponentClient
	// GitCommit is the client for interacting with the GitCommit builders.
	GitCommit *GitCommitClient
	// License is the client for interacting with the License builders.
	License *LicenseClient
	// LicenseScan is the client for interacting with the LicenseScan builders.
	LicenseScan *LicenseScanClient
	// LicenseUsage is the client for interacting with the LicenseUsage builders.
	LicenseUsage *LicenseUsageClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Release is the client for interacting with the Release builders.
	Release *ReleaseClient
	// ReleaseCheck is the client for interacting with the ReleaseCheck builders.
	ReleaseCheck *ReleaseCheckClient
	// ReleaseEntry is the client for interacting with the ReleaseEntry builders.
	ReleaseEntry *ReleaseEntryClient
	// Repo is the client for interacting with the Repo builders.
	Repo *RepoClient
	// TestCase is the client for interacting with the TestCase builders.
	TestCase *TestCaseClient
	// TestRun is the client for interacting with the TestRun builders.
	TestRun *TestRunClient
	// Vulnerability is the client for interacting with the Vulnerability builders.
	Vulnerability *VulnerabilityClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Artifact = NewArtifactClient(c.config)
	c.CVE = NewCVEClient(c.config)
	c.CVERule = NewCVERuleClient(c.config)
	c.CVEScan = NewCVEScanClient(c.config)
	c.CWE = NewCWEClient(c.config)
	c.CodeIssue = NewCodeIssueClient(c.config)
	c.CodeScan = NewCodeScanClient(c.config)
	c.Component = NewComponentClient(c.config)
	c.GitCommit = NewGitCommitClient(c.config)
	c.License = NewLicenseClient(c.config)
	c.LicenseScan = NewLicenseScanClient(c.config)
	c.LicenseUsage = NewLicenseUsageClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Release = NewReleaseClient(c.config)
	c.ReleaseCheck = NewReleaseCheckClient(c.config)
	c.ReleaseEntry = NewReleaseEntryClient(c.config)
	c.Repo = NewRepoClient(c.config)
	c.TestCase = NewTestCaseClient(c.config)
	c.TestRun = NewTestRunClient(c.config)
	c.Vulnerability = NewVulnerabilityClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Artifact:      NewArtifactClient(cfg),
		CVE:           NewCVEClient(cfg),
		CVERule:       NewCVERuleClient(cfg),
		CVEScan:       NewCVEScanClient(cfg),
		CWE:           NewCWEClient(cfg),
		CodeIssue:     NewCodeIssueClient(cfg),
		CodeScan:      NewCodeScanClient(cfg),
		Component:     NewComponentClient(cfg),
		GitCommit:     NewGitCommitClient(cfg),
		License:       NewLicenseClient(cfg),
		LicenseScan:   NewLicenseScanClient(cfg),
		LicenseUsage:  NewLicenseUsageClient(cfg),
		Project:       NewProjectClient(cfg),
		Release:       NewReleaseClient(cfg),
		ReleaseCheck:  NewReleaseCheckClient(cfg),
		ReleaseEntry:  NewReleaseEntryClient(cfg),
		Repo:          NewRepoClient(cfg),
		TestCase:      NewTestCaseClient(cfg),
		TestRun:       NewTestRunClient(cfg),
		Vulnerability: NewVulnerabilityClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:        cfg,
		Artifact:      NewArtifactClient(cfg),
		CVE:           NewCVEClient(cfg),
		CVERule:       NewCVERuleClient(cfg),
		CVEScan:       NewCVEScanClient(cfg),
		CWE:           NewCWEClient(cfg),
		CodeIssue:     NewCodeIssueClient(cfg),
		CodeScan:      NewCodeScanClient(cfg),
		Component:     NewComponentClient(cfg),
		GitCommit:     NewGitCommitClient(cfg),
		License:       NewLicenseClient(cfg),
		LicenseScan:   NewLicenseScanClient(cfg),
		LicenseUsage:  NewLicenseUsageClient(cfg),
		Project:       NewProjectClient(cfg),
		Release:       NewReleaseClient(cfg),
		ReleaseCheck:  NewReleaseCheckClient(cfg),
		ReleaseEntry:  NewReleaseEntryClient(cfg),
		Repo:          NewRepoClient(cfg),
		TestCase:      NewTestCaseClient(cfg),
		TestRun:       NewTestRunClient(cfg),
		Vulnerability: NewVulnerabilityClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Artifact.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Artifact.Use(hooks...)
	c.CVE.Use(hooks...)
	c.CVERule.Use(hooks...)
	c.CVEScan.Use(hooks...)
	c.CWE.Use(hooks...)
	c.CodeIssue.Use(hooks...)
	c.CodeScan.Use(hooks...)
	c.Component.Use(hooks...)
	c.GitCommit.Use(hooks...)
	c.License.Use(hooks...)
	c.LicenseScan.Use(hooks...)
	c.LicenseUsage.Use(hooks...)
	c.Project.Use(hooks...)
	c.Release.Use(hooks...)
	c.ReleaseCheck.Use(hooks...)
	c.ReleaseEntry.Use(hooks...)
	c.Repo.Use(hooks...)
	c.TestCase.Use(hooks...)
	c.TestRun.Use(hooks...)
	c.Vulnerability.Use(hooks...)
}

// ArtifactClient is a client for the Artifact schema.
type ArtifactClient struct {
	config
}

// NewArtifactClient returns a client for the Artifact from the given config.
func NewArtifactClient(c config) *ArtifactClient {
	return &ArtifactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `artifact.Hooks(f(g(h())))`.
func (c *ArtifactClient) Use(hooks ...Hook) {
	c.hooks.Artifact = append(c.hooks.Artifact, hooks...)
}

// Create returns a create builder for Artifact.
func (c *ArtifactClient) Create() *ArtifactCreate {
	mutation := newArtifactMutation(c.config, OpCreate)
	return &ArtifactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Artifact entities.
func (c *ArtifactClient) CreateBulk(builders ...*ArtifactCreate) *ArtifactCreateBulk {
	return &ArtifactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Artifact.
func (c *ArtifactClient) Update() *ArtifactUpdate {
	mutation := newArtifactMutation(c.config, OpUpdate)
	return &ArtifactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ArtifactClient) UpdateOne(a *Artifact) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifact(a))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ArtifactClient) UpdateOneID(id int) *ArtifactUpdateOne {
	mutation := newArtifactMutation(c.config, OpUpdateOne, withArtifactID(id))
	return &ArtifactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Artifact.
func (c *ArtifactClient) Delete() *ArtifactDelete {
	mutation := newArtifactMutation(c.config, OpDelete)
	return &ArtifactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ArtifactClient) DeleteOne(a *Artifact) *ArtifactDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ArtifactClient) DeleteOneID(id int) *ArtifactDeleteOne {
	builder := c.Delete().Where(artifact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ArtifactDeleteOne{builder}
}

// Query returns a query builder for Artifact.
func (c *ArtifactClient) Query() *ArtifactQuery {
	return &ArtifactQuery{
		config: c.config,
	}
}

// Get returns a Artifact entity by its id.
func (c *ArtifactClient) Get(ctx context.Context, id int) (*Artifact, error) {
	return c.Query().Where(artifact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ArtifactClient) GetX(ctx context.Context, id int) *Artifact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a Artifact.
func (c *ArtifactClient) QueryRelease(a *Artifact) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, artifact.ReleaseTable, artifact.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a Artifact.
func (c *ArtifactClient) QueryEntry(a *Artifact) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(artifact.Table, artifact.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, artifact.EntryTable, artifact.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ArtifactClient) Hooks() []Hook {
	hooks := c.hooks.Artifact
	return append(hooks[:len(hooks):len(hooks)], artifact.Hooks[:]...)
}

// CVEClient is a client for the CVE schema.
type CVEClient struct {
	config
}

// NewCVEClient returns a client for the CVE from the given config.
func NewCVEClient(c config) *CVEClient {
	return &CVEClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cve.Hooks(f(g(h())))`.
func (c *CVEClient) Use(hooks ...Hook) {
	c.hooks.CVE = append(c.hooks.CVE, hooks...)
}

// Create returns a create builder for CVE.
func (c *CVEClient) Create() *CVECreate {
	mutation := newCVEMutation(c.config, OpCreate)
	return &CVECreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CVE entities.
func (c *CVEClient) CreateBulk(builders ...*CVECreate) *CVECreateBulk {
	return &CVECreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CVE.
func (c *CVEClient) Update() *CVEUpdate {
	mutation := newCVEMutation(c.config, OpUpdate)
	return &CVEUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CVEClient) UpdateOne(cv *CVE) *CVEUpdateOne {
	mutation := newCVEMutation(c.config, OpUpdateOne, withCVE(cv))
	return &CVEUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CVEClient) UpdateOneID(id int) *CVEUpdateOne {
	mutation := newCVEMutation(c.config, OpUpdateOne, withCVEID(id))
	return &CVEUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CVE.
func (c *CVEClient) Delete() *CVEDelete {
	mutation := newCVEMutation(c.config, OpDelete)
	return &CVEDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CVEClient) DeleteOne(cv *CVE) *CVEDeleteOne {
	return c.DeleteOneID(cv.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CVEClient) DeleteOneID(id int) *CVEDeleteOne {
	builder := c.Delete().Where(cve.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CVEDeleteOne{builder}
}

// Query returns a query builder for CVE.
func (c *CVEClient) Query() *CVEQuery {
	return &CVEQuery{
		config: c.config,
	}
}

// Get returns a CVE entity by its id.
func (c *CVEClient) Get(ctx context.Context, id int) (*CVE, error) {
	return c.Query().Where(cve.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CVEClient) GetX(ctx context.Context, id int) *CVE {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFound queries the found edge of a CVE.
func (c *CVEClient) QueryFound(cv *CVE) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cve.Table, cve.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, cve.FoundTable, cve.FoundColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRules queries the rules edge of a CVE.
func (c *CVEClient) QueryRules(cv *CVE) *CVERuleQuery {
	query := &CVERuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cve.Table, cve.FieldID, id),
			sqlgraph.To(cverule.Table, cverule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, cve.RulesTable, cve.RulesColumn),
		)
		fromV = sqlgraph.Neighbors(cv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CVEClient) Hooks() []Hook {
	hooks := c.hooks.CVE
	return append(hooks[:len(hooks):len(hooks)], cve.Hooks[:]...)
}

// CVERuleClient is a client for the CVERule schema.
type CVERuleClient struct {
	config
}

// NewCVERuleClient returns a client for the CVERule from the given config.
func NewCVERuleClient(c config) *CVERuleClient {
	return &CVERuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cverule.Hooks(f(g(h())))`.
func (c *CVERuleClient) Use(hooks ...Hook) {
	c.hooks.CVERule = append(c.hooks.CVERule, hooks...)
}

// Create returns a create builder for CVERule.
func (c *CVERuleClient) Create() *CVERuleCreate {
	mutation := newCVERuleMutation(c.config, OpCreate)
	return &CVERuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CVERule entities.
func (c *CVERuleClient) CreateBulk(builders ...*CVERuleCreate) *CVERuleCreateBulk {
	return &CVERuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CVERule.
func (c *CVERuleClient) Update() *CVERuleUpdate {
	mutation := newCVERuleMutation(c.config, OpUpdate)
	return &CVERuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CVERuleClient) UpdateOne(cr *CVERule) *CVERuleUpdateOne {
	mutation := newCVERuleMutation(c.config, OpUpdateOne, withCVERule(cr))
	return &CVERuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CVERuleClient) UpdateOneID(id int) *CVERuleUpdateOne {
	mutation := newCVERuleMutation(c.config, OpUpdateOne, withCVERuleID(id))
	return &CVERuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CVERule.
func (c *CVERuleClient) Delete() *CVERuleDelete {
	mutation := newCVERuleMutation(c.config, OpDelete)
	return &CVERuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CVERuleClient) DeleteOne(cr *CVERule) *CVERuleDeleteOne {
	return c.DeleteOneID(cr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CVERuleClient) DeleteOneID(id int) *CVERuleDeleteOne {
	builder := c.Delete().Where(cverule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CVERuleDeleteOne{builder}
}

// Query returns a query builder for CVERule.
func (c *CVERuleClient) Query() *CVERuleQuery {
	return &CVERuleQuery{
		config: c.config,
	}
}

// Get returns a CVERule entity by its id.
func (c *CVERuleClient) Get(ctx context.Context, id int) (*CVERule, error) {
	return c.Query().Where(cverule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CVERuleClient) GetX(ctx context.Context, id int) *CVERule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCve queries the cve edge of a CVERule.
func (c *CVERuleClient) QueryCve(cr *CVERule) *CVEQuery {
	query := &CVEQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cverule.Table, cverule.FieldID, id),
			sqlgraph.To(cve.Table, cve.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, cverule.CveTable, cverule.CveColumn),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a CVERule.
func (c *CVERuleClient) QueryProject(cr *CVERule) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cverule.Table, cverule.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, cverule.ProjectTable, cverule.ProjectPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepo queries the repo edge of a CVERule.
func (c *CVERuleClient) QueryRepo(cr *CVERule) *RepoQuery {
	query := &RepoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cverule.Table, cverule.FieldID, id),
			sqlgraph.To(repo.Table, repo.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, cverule.RepoTable, cverule.RepoPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CVERuleClient) Hooks() []Hook {
	hooks := c.hooks.CVERule
	return append(hooks[:len(hooks):len(hooks)], cverule.Hooks[:]...)
}

// CVEScanClient is a client for the CVEScan schema.
type CVEScanClient struct {
	config
}

// NewCVEScanClient returns a client for the CVEScan from the given config.
func NewCVEScanClient(c config) *CVEScanClient {
	return &CVEScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cvescan.Hooks(f(g(h())))`.
func (c *CVEScanClient) Use(hooks ...Hook) {
	c.hooks.CVEScan = append(c.hooks.CVEScan, hooks...)
}

// Create returns a create builder for CVEScan.
func (c *CVEScanClient) Create() *CVEScanCreate {
	mutation := newCVEScanMutation(c.config, OpCreate)
	return &CVEScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CVEScan entities.
func (c *CVEScanClient) CreateBulk(builders ...*CVEScanCreate) *CVEScanCreateBulk {
	return &CVEScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CVEScan.
func (c *CVEScanClient) Update() *CVEScanUpdate {
	mutation := newCVEScanMutation(c.config, OpUpdate)
	return &CVEScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CVEScanClient) UpdateOne(cs *CVEScan) *CVEScanUpdateOne {
	mutation := newCVEScanMutation(c.config, OpUpdateOne, withCVEScan(cs))
	return &CVEScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CVEScanClient) UpdateOneID(id int) *CVEScanUpdateOne {
	mutation := newCVEScanMutation(c.config, OpUpdateOne, withCVEScanID(id))
	return &CVEScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CVEScan.
func (c *CVEScanClient) Delete() *CVEScanDelete {
	mutation := newCVEScanMutation(c.config, OpDelete)
	return &CVEScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CVEScanClient) DeleteOne(cs *CVEScan) *CVEScanDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CVEScanClient) DeleteOneID(id int) *CVEScanDeleteOne {
	builder := c.Delete().Where(cvescan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CVEScanDeleteOne{builder}
}

// Query returns a query builder for CVEScan.
func (c *CVEScanClient) Query() *CVEScanQuery {
	return &CVEScanQuery{
		config: c.config,
	}
}

// Get returns a CVEScan entity by its id.
func (c *CVEScanClient) Get(ctx context.Context, id int) (*CVEScan, error) {
	return c.Query().Where(cvescan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CVEScanClient) GetX(ctx context.Context, id int) *CVEScan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a CVEScan.
func (c *CVEScanClient) QueryRelease(cs *CVEScan) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cvescan.Table, cvescan.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, cvescan.ReleaseTable, cvescan.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a CVEScan.
func (c *CVEScanClient) QueryEntry(cs *CVEScan) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cvescan.Table, cvescan.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, cvescan.EntryTable, cvescan.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVulnerabilities queries the vulnerabilities edge of a CVEScan.
func (c *CVEScanClient) QueryVulnerabilities(cs *CVEScan) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cvescan.Table, cvescan.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, cvescan.VulnerabilitiesTable, cvescan.VulnerabilitiesColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CVEScanClient) Hooks() []Hook {
	hooks := c.hooks.CVEScan
	return append(hooks[:len(hooks):len(hooks)], cvescan.Hooks[:]...)
}

// CWEClient is a client for the CWE schema.
type CWEClient struct {
	config
}

// NewCWEClient returns a client for the CWE from the given config.
func NewCWEClient(c config) *CWEClient {
	return &CWEClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cwe.Hooks(f(g(h())))`.
func (c *CWEClient) Use(hooks ...Hook) {
	c.hooks.CWE = append(c.hooks.CWE, hooks...)
}

// Create returns a create builder for CWE.
func (c *CWEClient) Create() *CWECreate {
	mutation := newCWEMutation(c.config, OpCreate)
	return &CWECreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CWE entities.
func (c *CWEClient) CreateBulk(builders ...*CWECreate) *CWECreateBulk {
	return &CWECreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CWE.
func (c *CWEClient) Update() *CWEUpdate {
	mutation := newCWEMutation(c.config, OpUpdate)
	return &CWEUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CWEClient) UpdateOne(cw *CWE) *CWEUpdateOne {
	mutation := newCWEMutation(c.config, OpUpdateOne, withCWE(cw))
	return &CWEUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CWEClient) UpdateOneID(id int) *CWEUpdateOne {
	mutation := newCWEMutation(c.config, OpUpdateOne, withCWEID(id))
	return &CWEUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CWE.
func (c *CWEClient) Delete() *CWEDelete {
	mutation := newCWEMutation(c.config, OpDelete)
	return &CWEDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CWEClient) DeleteOne(cw *CWE) *CWEDeleteOne {
	return c.DeleteOneID(cw.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CWEClient) DeleteOneID(id int) *CWEDeleteOne {
	builder := c.Delete().Where(cwe.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CWEDeleteOne{builder}
}

// Query returns a query builder for CWE.
func (c *CWEClient) Query() *CWEQuery {
	return &CWEQuery{
		config: c.config,
	}
}

// Get returns a CWE entity by its id.
func (c *CWEClient) Get(ctx context.Context, id int) (*CWE, error) {
	return c.Query().Where(cwe.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CWEClient) GetX(ctx context.Context, id int) *CWE {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIssues queries the issues edge of a CWE.
func (c *CWEClient) QueryIssues(cw *CWE) *CodeIssueQuery {
	query := &CodeIssueQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cw.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cwe.Table, cwe.FieldID, id),
			sqlgraph.To(codeissue.Table, codeissue.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, cwe.IssuesTable, cwe.IssuesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cw.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CWEClient) Hooks() []Hook {
	return c.hooks.CWE
}

// CodeIssueClient is a client for the CodeIssue schema.
type CodeIssueClient struct {
	config
}

// NewCodeIssueClient returns a client for the CodeIssue from the given config.
func NewCodeIssueClient(c config) *CodeIssueClient {
	return &CodeIssueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `codeissue.Hooks(f(g(h())))`.
func (c *CodeIssueClient) Use(hooks ...Hook) {
	c.hooks.CodeIssue = append(c.hooks.CodeIssue, hooks...)
}

// Create returns a create builder for CodeIssue.
func (c *CodeIssueClient) Create() *CodeIssueCreate {
	mutation := newCodeIssueMutation(c.config, OpCreate)
	return &CodeIssueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CodeIssue entities.
func (c *CodeIssueClient) CreateBulk(builders ...*CodeIssueCreate) *CodeIssueCreateBulk {
	return &CodeIssueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CodeIssue.
func (c *CodeIssueClient) Update() *CodeIssueUpdate {
	mutation := newCodeIssueMutation(c.config, OpUpdate)
	return &CodeIssueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CodeIssueClient) UpdateOne(ci *CodeIssue) *CodeIssueUpdateOne {
	mutation := newCodeIssueMutation(c.config, OpUpdateOne, withCodeIssue(ci))
	return &CodeIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CodeIssueClient) UpdateOneID(id int) *CodeIssueUpdateOne {
	mutation := newCodeIssueMutation(c.config, OpUpdateOne, withCodeIssueID(id))
	return &CodeIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CodeIssue.
func (c *CodeIssueClient) Delete() *CodeIssueDelete {
	mutation := newCodeIssueMutation(c.config, OpDelete)
	return &CodeIssueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CodeIssueClient) DeleteOne(ci *CodeIssue) *CodeIssueDeleteOne {
	return c.DeleteOneID(ci.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CodeIssueClient) DeleteOneID(id int) *CodeIssueDeleteOne {
	builder := c.Delete().Where(codeissue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CodeIssueDeleteOne{builder}
}

// Query returns a query builder for CodeIssue.
func (c *CodeIssueClient) Query() *CodeIssueQuery {
	return &CodeIssueQuery{
		config: c.config,
	}
}

// Get returns a CodeIssue entity by its id.
func (c *CodeIssueClient) Get(ctx context.Context, id int) (*CodeIssue, error) {
	return c.Query().Where(codeissue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CodeIssueClient) GetX(ctx context.Context, id int) *CodeIssue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCwe queries the cwe edge of a CodeIssue.
func (c *CodeIssueClient) QueryCwe(ci *CodeIssue) *CWEQuery {
	query := &CWEQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codeissue.Table, codeissue.FieldID, id),
			sqlgraph.To(cwe.Table, cwe.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, codeissue.CweTable, codeissue.CwePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScan queries the scan edge of a CodeIssue.
func (c *CodeIssueClient) QueryScan(ci *CodeIssue) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codeissue.Table, codeissue.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, codeissue.ScanTable, codeissue.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CodeIssueClient) Hooks() []Hook {
	return c.hooks.CodeIssue
}

// CodeScanClient is a client for the CodeScan schema.
type CodeScanClient struct {
	config
}

// NewCodeScanClient returns a client for the CodeScan from the given config.
func NewCodeScanClient(c config) *CodeScanClient {
	return &CodeScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `codescan.Hooks(f(g(h())))`.
func (c *CodeScanClient) Use(hooks ...Hook) {
	c.hooks.CodeScan = append(c.hooks.CodeScan, hooks...)
}

// Create returns a create builder for CodeScan.
func (c *CodeScanClient) Create() *CodeScanCreate {
	mutation := newCodeScanMutation(c.config, OpCreate)
	return &CodeScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CodeScan entities.
func (c *CodeScanClient) CreateBulk(builders ...*CodeScanCreate) *CodeScanCreateBulk {
	return &CodeScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CodeScan.
func (c *CodeScanClient) Update() *CodeScanUpdate {
	mutation := newCodeScanMutation(c.config, OpUpdate)
	return &CodeScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CodeScanClient) UpdateOne(cs *CodeScan) *CodeScanUpdateOne {
	mutation := newCodeScanMutation(c.config, OpUpdateOne, withCodeScan(cs))
	return &CodeScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CodeScanClient) UpdateOneID(id int) *CodeScanUpdateOne {
	mutation := newCodeScanMutation(c.config, OpUpdateOne, withCodeScanID(id))
	return &CodeScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CodeScan.
func (c *CodeScanClient) Delete() *CodeScanDelete {
	mutation := newCodeScanMutation(c.config, OpDelete)
	return &CodeScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CodeScanClient) DeleteOne(cs *CodeScan) *CodeScanDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CodeScanClient) DeleteOneID(id int) *CodeScanDeleteOne {
	builder := c.Delete().Where(codescan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CodeScanDeleteOne{builder}
}

// Query returns a query builder for CodeScan.
func (c *CodeScanClient) Query() *CodeScanQuery {
	return &CodeScanQuery{
		config: c.config,
	}
}

// Get returns a CodeScan entity by its id.
func (c *CodeScanClient) Get(ctx context.Context, id int) (*CodeScan, error) {
	return c.Query().Where(codescan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CodeScanClient) GetX(ctx context.Context, id int) *CodeScan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a CodeScan.
func (c *CodeScanClient) QueryRelease(cs *CodeScan) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, codescan.ReleaseTable, codescan.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIssues queries the issues edge of a CodeScan.
func (c *CodeScanClient) QueryIssues(cs *CodeScan) *CodeIssueQuery {
	query := &CodeIssueQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(codeissue.Table, codeissue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, codescan.IssuesTable, codescan.IssuesColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a CodeScan.
func (c *CodeScanClient) QueryEntry(cs *CodeScan) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(codescan.Table, codescan.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, codescan.EntryTable, codescan.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CodeScanClient) Hooks() []Hook {
	hooks := c.hooks.CodeScan
	return append(hooks[:len(hooks):len(hooks)], codescan.Hooks[:]...)
}

// ComponentClient is a client for the Component schema.
type ComponentClient struct {
	config
}

// NewComponentClient returns a client for the Component from the given config.
func NewComponentClient(c config) *ComponentClient {
	return &ComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `component.Hooks(f(g(h())))`.
func (c *ComponentClient) Use(hooks ...Hook) {
	c.hooks.Component = append(c.hooks.Component, hooks...)
}

// Create returns a create builder for Component.
func (c *ComponentClient) Create() *ComponentCreate {
	mutation := newComponentMutation(c.config, OpCreate)
	return &ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Component entities.
func (c *ComponentClient) CreateBulk(builders ...*ComponentCreate) *ComponentCreateBulk {
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Component.
func (c *ComponentClient) Update() *ComponentUpdate {
	mutation := newComponentMutation(c.config, OpUpdate)
	return &ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentClient) UpdateOne(co *Component) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponent(co))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentClient) UpdateOneID(id int) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponentID(id))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Component.
func (c *ComponentClient) Delete() *ComponentDelete {
	mutation := newComponentMutation(c.config, OpDelete)
	return &ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ComponentClient) DeleteOne(co *Component) *ComponentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ComponentClient) DeleteOneID(id int) *ComponentDeleteOne {
	builder := c.Delete().Where(component.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDeleteOne{builder}
}

// Query returns a query builder for Component.
func (c *ComponentClient) Query() *ComponentQuery {
	return &ComponentQuery{
		config: c.config,
	}
}

// Get returns a Component entity by its id.
func (c *ComponentClient) Get(ctx context.Context, id int) (*Component, error) {
	return c.Query().Where(component.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentClient) GetX(ctx context.Context, id int) *Component {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVulnerabilities queries the vulnerabilities edge of a Component.
func (c *ComponentClient) QueryVulnerabilities(co *Component) *VulnerabilityQuery {
	query := &VulnerabilityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(vulnerability.Table, vulnerability.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, component.VulnerabilitiesTable, component.VulnerabilitiesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenses queries the licenses edge of a Component.
func (c *ComponentClient) QueryLicenses(co *Component) *LicenseQuery {
	query := &LicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, component.LicensesTable, component.LicensesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a Component.
func (c *ComponentClient) QueryRelease(co *Component) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, component.ReleaseTable, component.ReleasePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentClient) Hooks() []Hook {
	return c.hooks.Component
}

// GitCommitClient is a client for the GitCommit schema.
type GitCommitClient struct {
	config
}

// NewGitCommitClient returns a client for the GitCommit from the given config.
func NewGitCommitClient(c config) *GitCommitClient {
	return &GitCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gitcommit.Hooks(f(g(h())))`.
func (c *GitCommitClient) Use(hooks ...Hook) {
	c.hooks.GitCommit = append(c.hooks.GitCommit, hooks...)
}

// Create returns a create builder for GitCommit.
func (c *GitCommitClient) Create() *GitCommitCreate {
	mutation := newGitCommitMutation(c.config, OpCreate)
	return &GitCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GitCommit entities.
func (c *GitCommitClient) CreateBulk(builders ...*GitCommitCreate) *GitCommitCreateBulk {
	return &GitCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GitCommit.
func (c *GitCommitClient) Update() *GitCommitUpdate {
	mutation := newGitCommitMutation(c.config, OpUpdate)
	return &GitCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GitCommitClient) UpdateOne(gc *GitCommit) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommit(gc))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GitCommitClient) UpdateOneID(id int) *GitCommitUpdateOne {
	mutation := newGitCommitMutation(c.config, OpUpdateOne, withGitCommitID(id))
	return &GitCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GitCommit.
func (c *GitCommitClient) Delete() *GitCommitDelete {
	mutation := newGitCommitMutation(c.config, OpDelete)
	return &GitCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GitCommitClient) DeleteOne(gc *GitCommit) *GitCommitDeleteOne {
	return c.DeleteOneID(gc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GitCommitClient) DeleteOneID(id int) *GitCommitDeleteOne {
	builder := c.Delete().Where(gitcommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GitCommitDeleteOne{builder}
}

// Query returns a query builder for GitCommit.
func (c *GitCommitClient) Query() *GitCommitQuery {
	return &GitCommitQuery{
		config: c.config,
	}
}

// Get returns a GitCommit entity by its id.
func (c *GitCommitClient) Get(ctx context.Context, id int) (*GitCommit, error) {
	return c.Query().Where(gitcommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GitCommitClient) GetX(ctx context.Context, id int) *GitCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepo queries the repo edge of a GitCommit.
func (c *GitCommitClient) QueryRepo(gc *GitCommit) *RepoQuery {
	query := &RepoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gitcommit.Table, gitcommit.FieldID, id),
			sqlgraph.To(repo.Table, repo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, gitcommit.RepoTable, gitcommit.RepoColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a GitCommit.
func (c *GitCommitClient) QueryRelease(gc *GitCommit) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gitcommit.Table, gitcommit.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, gitcommit.ReleaseTable, gitcommit.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(gc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GitCommitClient) Hooks() []Hook {
	return c.hooks.GitCommit
}

// LicenseClient is a client for the License schema.
type LicenseClient struct {
	config
}

// NewLicenseClient returns a client for the License from the given config.
func NewLicenseClient(c config) *LicenseClient {
	return &LicenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `license.Hooks(f(g(h())))`.
func (c *LicenseClient) Use(hooks ...Hook) {
	c.hooks.License = append(c.hooks.License, hooks...)
}

// Create returns a create builder for License.
func (c *LicenseClient) Create() *LicenseCreate {
	mutation := newLicenseMutation(c.config, OpCreate)
	return &LicenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of License entities.
func (c *LicenseClient) CreateBulk(builders ...*LicenseCreate) *LicenseCreateBulk {
	return &LicenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for License.
func (c *LicenseClient) Update() *LicenseUpdate {
	mutation := newLicenseMutation(c.config, OpUpdate)
	return &LicenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseClient) UpdateOne(l *License) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicense(l))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseClient) UpdateOneID(id int) *LicenseUpdateOne {
	mutation := newLicenseMutation(c.config, OpUpdateOne, withLicenseID(id))
	return &LicenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for License.
func (c *LicenseClient) Delete() *LicenseDelete {
	mutation := newLicenseMutation(c.config, OpDelete)
	return &LicenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LicenseClient) DeleteOne(l *License) *LicenseDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LicenseClient) DeleteOneID(id int) *LicenseDeleteOne {
	builder := c.Delete().Where(license.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseDeleteOne{builder}
}

// Query returns a query builder for License.
func (c *LicenseClient) Query() *LicenseQuery {
	return &LicenseQuery{
		config: c.config,
	}
}

// Get returns a License entity by its id.
func (c *LicenseClient) Get(ctx context.Context, id int) (*License, error) {
	return c.Query().Where(license.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseClient) GetX(ctx context.Context, id int) *License {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a License.
func (c *LicenseClient) QueryComponents(l *License) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, license.ComponentsTable, license.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsages queries the usages edge of a License.
func (c *LicenseClient) QueryUsages(l *License) *LicenseUsageQuery {
	query := &LicenseUsageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(license.Table, license.FieldID, id),
			sqlgraph.To(licenseusage.Table, licenseusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, license.UsagesTable, license.UsagesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseClient) Hooks() []Hook {
	return c.hooks.License
}

// LicenseScanClient is a client for the LicenseScan schema.
type LicenseScanClient struct {
	config
}

// NewLicenseScanClient returns a client for the LicenseScan from the given config.
func NewLicenseScanClient(c config) *LicenseScanClient {
	return &LicenseScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `licensescan.Hooks(f(g(h())))`.
func (c *LicenseScanClient) Use(hooks ...Hook) {
	c.hooks.LicenseScan = append(c.hooks.LicenseScan, hooks...)
}

// Create returns a create builder for LicenseScan.
func (c *LicenseScanClient) Create() *LicenseScanCreate {
	mutation := newLicenseScanMutation(c.config, OpCreate)
	return &LicenseScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LicenseScan entities.
func (c *LicenseScanClient) CreateBulk(builders ...*LicenseScanCreate) *LicenseScanCreateBulk {
	return &LicenseScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LicenseScan.
func (c *LicenseScanClient) Update() *LicenseScanUpdate {
	mutation := newLicenseScanMutation(c.config, OpUpdate)
	return &LicenseScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseScanClient) UpdateOne(ls *LicenseScan) *LicenseScanUpdateOne {
	mutation := newLicenseScanMutation(c.config, OpUpdateOne, withLicenseScan(ls))
	return &LicenseScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseScanClient) UpdateOneID(id int) *LicenseScanUpdateOne {
	mutation := newLicenseScanMutation(c.config, OpUpdateOne, withLicenseScanID(id))
	return &LicenseScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LicenseScan.
func (c *LicenseScanClient) Delete() *LicenseScanDelete {
	mutation := newLicenseScanMutation(c.config, OpDelete)
	return &LicenseScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LicenseScanClient) DeleteOne(ls *LicenseScan) *LicenseScanDeleteOne {
	return c.DeleteOneID(ls.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LicenseScanClient) DeleteOneID(id int) *LicenseScanDeleteOne {
	builder := c.Delete().Where(licensescan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseScanDeleteOne{builder}
}

// Query returns a query builder for LicenseScan.
func (c *LicenseScanClient) Query() *LicenseScanQuery {
	return &LicenseScanQuery{
		config: c.config,
	}
}

// Get returns a LicenseScan entity by its id.
func (c *LicenseScanClient) Get(ctx context.Context, id int) (*LicenseScan, error) {
	return c.Query().Where(licensescan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseScanClient) GetX(ctx context.Context, id int) *LicenseScan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a LicenseScan.
func (c *LicenseScanClient) QueryRelease(ls *LicenseScan) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(licensescan.Table, licensescan.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, licensescan.ReleaseTable, licensescan.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(ls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a LicenseScan.
func (c *LicenseScanClient) QueryEntry(ls *LicenseScan) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(licensescan.Table, licensescan.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, licensescan.EntryTable, licensescan.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(ls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenses queries the licenses edge of a LicenseScan.
func (c *LicenseScanClient) QueryLicenses(ls *LicenseScan) *LicenseUsageQuery {
	query := &LicenseUsageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(licensescan.Table, licensescan.FieldID, id),
			sqlgraph.To(licenseusage.Table, licenseusage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, licensescan.LicensesTable, licensescan.LicensesColumn),
		)
		fromV = sqlgraph.Neighbors(ls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseScanClient) Hooks() []Hook {
	hooks := c.hooks.LicenseScan
	return append(hooks[:len(hooks):len(hooks)], licensescan.Hooks[:]...)
}

// LicenseUsageClient is a client for the LicenseUsage schema.
type LicenseUsageClient struct {
	config
}

// NewLicenseUsageClient returns a client for the LicenseUsage from the given config.
func NewLicenseUsageClient(c config) *LicenseUsageClient {
	return &LicenseUsageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `licenseusage.Hooks(f(g(h())))`.
func (c *LicenseUsageClient) Use(hooks ...Hook) {
	c.hooks.LicenseUsage = append(c.hooks.LicenseUsage, hooks...)
}

// Create returns a create builder for LicenseUsage.
func (c *LicenseUsageClient) Create() *LicenseUsageCreate {
	mutation := newLicenseUsageMutation(c.config, OpCreate)
	return &LicenseUsageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LicenseUsage entities.
func (c *LicenseUsageClient) CreateBulk(builders ...*LicenseUsageCreate) *LicenseUsageCreateBulk {
	return &LicenseUsageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LicenseUsage.
func (c *LicenseUsageClient) Update() *LicenseUsageUpdate {
	mutation := newLicenseUsageMutation(c.config, OpUpdate)
	return &LicenseUsageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LicenseUsageClient) UpdateOne(lu *LicenseUsage) *LicenseUsageUpdateOne {
	mutation := newLicenseUsageMutation(c.config, OpUpdateOne, withLicenseUsage(lu))
	return &LicenseUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LicenseUsageClient) UpdateOneID(id int) *LicenseUsageUpdateOne {
	mutation := newLicenseUsageMutation(c.config, OpUpdateOne, withLicenseUsageID(id))
	return &LicenseUsageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LicenseUsage.
func (c *LicenseUsageClient) Delete() *LicenseUsageDelete {
	mutation := newLicenseUsageMutation(c.config, OpDelete)
	return &LicenseUsageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LicenseUsageClient) DeleteOne(lu *LicenseUsage) *LicenseUsageDeleteOne {
	return c.DeleteOneID(lu.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LicenseUsageClient) DeleteOneID(id int) *LicenseUsageDeleteOne {
	builder := c.Delete().Where(licenseusage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LicenseUsageDeleteOne{builder}
}

// Query returns a query builder for LicenseUsage.
func (c *LicenseUsageClient) Query() *LicenseUsageQuery {
	return &LicenseUsageQuery{
		config: c.config,
	}
}

// Get returns a LicenseUsage entity by its id.
func (c *LicenseUsageClient) Get(ctx context.Context, id int) (*LicenseUsage, error) {
	return c.Query().Where(licenseusage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LicenseUsageClient) GetX(ctx context.Context, id int) *LicenseUsage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLicense queries the license edge of a LicenseUsage.
func (c *LicenseUsageClient) QueryLicense(lu *LicenseUsage) *LicenseQuery {
	query := &LicenseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := lu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(licenseusage.Table, licenseusage.FieldID, id),
			sqlgraph.To(license.Table, license.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, licenseusage.LicenseTable, licenseusage.LicenseColumn),
		)
		fromV = sqlgraph.Neighbors(lu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScan queries the scan edge of a LicenseUsage.
func (c *LicenseUsageClient) QueryScan(lu *LicenseUsage) *LicenseScanQuery {
	query := &LicenseScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := lu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(licenseusage.Table, licenseusage.FieldID, id),
			sqlgraph.To(licensescan.Table, licensescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, licenseusage.ScanTable, licenseusage.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(lu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LicenseUsageClient) Hooks() []Hook {
	return c.hooks.LicenseUsage
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Create returns a create builder for Project.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ProjectClient) DeleteOneID(id int) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepos queries the repos edge of a Project.
func (c *ProjectClient) QueryRepos(pr *Project) *RepoQuery {
	query := &RepoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(repo.Table, repo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.ReposTable, project.ReposColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReleases queries the releases edge of a Project.
func (c *ProjectClient) QueryReleases(pr *Project) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, project.ReleasesTable, project.ReleasesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCveRules queries the cve_rules edge of a Project.
func (c *ProjectClient) QueryCveRules(pr *Project) *CVERuleQuery {
	query := &CVERuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(cverule.Table, cverule.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, project.CveRulesTable, project.CveRulesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// ReleaseClient is a client for the Release schema.
type ReleaseClient struct {
	config
}

// NewReleaseClient returns a client for the Release from the given config.
func NewReleaseClient(c config) *ReleaseClient {
	return &ReleaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `release.Hooks(f(g(h())))`.
func (c *ReleaseClient) Use(hooks ...Hook) {
	c.hooks.Release = append(c.hooks.Release, hooks...)
}

// Create returns a create builder for Release.
func (c *ReleaseClient) Create() *ReleaseCreate {
	mutation := newReleaseMutation(c.config, OpCreate)
	return &ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Release entities.
func (c *ReleaseClient) CreateBulk(builders ...*ReleaseCreate) *ReleaseCreateBulk {
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Release.
func (c *ReleaseClient) Update() *ReleaseUpdate {
	mutation := newReleaseMutation(c.config, OpUpdate)
	return &ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseClient) UpdateOne(r *Release) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withRelease(r))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseClient) UpdateOneID(id int) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withReleaseID(id))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Release.
func (c *ReleaseClient) Delete() *ReleaseDelete {
	mutation := newReleaseMutation(c.config, OpDelete)
	return &ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseClient) DeleteOne(r *Release) *ReleaseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseClient) DeleteOneID(id int) *ReleaseDeleteOne {
	builder := c.Delete().Where(release.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseDeleteOne{builder}
}

// Query returns a query builder for Release.
func (c *ReleaseClient) Query() *ReleaseQuery {
	return &ReleaseQuery{
		config: c.config,
	}
}

// Get returns a Release entity by its id.
func (c *ReleaseClient) Get(ctx context.Context, id int) (*Release, error) {
	return c.Query().Where(release.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseClient) GetX(ctx context.Context, id int) *Release {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubreleases queries the subreleases edge of a Release.
func (c *ReleaseClient) QuerySubreleases(r *Release) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, release.SubreleasesTable, release.SubreleasesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependencies queries the dependencies edge of a Release.
func (c *ReleaseClient) QueryDependencies(r *Release) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, release.DependenciesTable, release.DependenciesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProject queries the project edge of a Release.
func (c *ReleaseClient) QueryProject(r *Release) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, release.ProjectTable, release.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommit queries the commit edge of a Release.
func (c *ReleaseClient) QueryCommit(r *Release) *GitCommitQuery {
	query := &GitCommitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(gitcommit.Table, gitcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, release.CommitTable, release.CommitColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArtifacts queries the artifacts edge of a Release.
func (c *ReleaseClient) QueryArtifacts(r *Release) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.ArtifactsTable, release.ArtifactsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChecks queries the checks edge of a Release.
func (c *ReleaseClient) QueryChecks(r *Release) *ReleaseCheckQuery {
	query := &ReleaseCheckQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releasecheck.Table, releasecheck.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.ChecksTable, release.ChecksColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLog queries the log edge of a Release.
func (c *ReleaseClient) QueryLog(r *Release) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.LogTable, release.LogColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCodeScans queries the code_scans edge of a Release.
func (c *ReleaseClient) QueryCodeScans(r *Release) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.CodeScansTable, release.CodeScansColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCveScans queries the cve_scans edge of a Release.
func (c *ReleaseClient) QueryCveScans(r *Release) *CVEScanQuery {
	query := &CVEScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(cvescan.Table, cvescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.CveScansTable, release.CveScansColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenseScans queries the license_scans edge of a Release.
func (c *ReleaseClient) QueryLicenseScans(r *Release) *LicenseScanQuery {
	query := &LicenseScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(licensescan.Table, licensescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.LicenseScansTable, release.LicenseScansColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestRuns queries the test_runs edge of a Release.
func (c *ReleaseClient) QueryTestRuns(r *Release) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, release.TestRunsTable, release.TestRunsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponents queries the components edge of a Release.
func (c *ReleaseClient) QueryComponents(r *Release) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, release.ComponentsTable, release.ComponentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseClient) Hooks() []Hook {
	return c.hooks.Release
}

// ReleaseCheckClient is a client for the ReleaseCheck schema.
type ReleaseCheckClient struct {
	config
}

// NewReleaseCheckClient returns a client for the ReleaseCheck from the given config.
func NewReleaseCheckClient(c config) *ReleaseCheckClient {
	return &ReleaseCheckClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releasecheck.Hooks(f(g(h())))`.
func (c *ReleaseCheckClient) Use(hooks ...Hook) {
	c.hooks.ReleaseCheck = append(c.hooks.ReleaseCheck, hooks...)
}

// Create returns a create builder for ReleaseCheck.
func (c *ReleaseCheckClient) Create() *ReleaseCheckCreate {
	mutation := newReleaseCheckMutation(c.config, OpCreate)
	return &ReleaseCheckCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseCheck entities.
func (c *ReleaseCheckClient) CreateBulk(builders ...*ReleaseCheckCreate) *ReleaseCheckCreateBulk {
	return &ReleaseCheckCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseCheck.
func (c *ReleaseCheckClient) Update() *ReleaseCheckUpdate {
	mutation := newReleaseCheckMutation(c.config, OpUpdate)
	return &ReleaseCheckUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseCheckClient) UpdateOne(rc *ReleaseCheck) *ReleaseCheckUpdateOne {
	mutation := newReleaseCheckMutation(c.config, OpUpdateOne, withReleaseCheck(rc))
	return &ReleaseCheckUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseCheckClient) UpdateOneID(id int) *ReleaseCheckUpdateOne {
	mutation := newReleaseCheckMutation(c.config, OpUpdateOne, withReleaseCheckID(id))
	return &ReleaseCheckUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseCheck.
func (c *ReleaseCheckClient) Delete() *ReleaseCheckDelete {
	mutation := newReleaseCheckMutation(c.config, OpDelete)
	return &ReleaseCheckDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseCheckClient) DeleteOne(rc *ReleaseCheck) *ReleaseCheckDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseCheckClient) DeleteOneID(id int) *ReleaseCheckDeleteOne {
	builder := c.Delete().Where(releasecheck.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseCheckDeleteOne{builder}
}

// Query returns a query builder for ReleaseCheck.
func (c *ReleaseCheckClient) Query() *ReleaseCheckQuery {
	return &ReleaseCheckQuery{
		config: c.config,
	}
}

// Get returns a ReleaseCheck entity by its id.
func (c *ReleaseCheckClient) Get(ctx context.Context, id int) (*ReleaseCheck, error) {
	return c.Query().Where(releasecheck.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseCheckClient) GetX(ctx context.Context, id int) *ReleaseCheck {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a ReleaseCheck.
func (c *ReleaseCheckClient) QueryRelease(rc *ReleaseCheck) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releasecheck.Table, releasecheck.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releasecheck.ReleaseTable, releasecheck.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseCheckClient) Hooks() []Hook {
	return c.hooks.ReleaseCheck
}

// ReleaseEntryClient is a client for the ReleaseEntry schema.
type ReleaseEntryClient struct {
	config
}

// NewReleaseEntryClient returns a client for the ReleaseEntry from the given config.
func NewReleaseEntryClient(c config) *ReleaseEntryClient {
	return &ReleaseEntryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `releaseentry.Hooks(f(g(h())))`.
func (c *ReleaseEntryClient) Use(hooks ...Hook) {
	c.hooks.ReleaseEntry = append(c.hooks.ReleaseEntry, hooks...)
}

// Create returns a create builder for ReleaseEntry.
func (c *ReleaseEntryClient) Create() *ReleaseEntryCreate {
	mutation := newReleaseEntryMutation(c.config, OpCreate)
	return &ReleaseEntryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReleaseEntry entities.
func (c *ReleaseEntryClient) CreateBulk(builders ...*ReleaseEntryCreate) *ReleaseEntryCreateBulk {
	return &ReleaseEntryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReleaseEntry.
func (c *ReleaseEntryClient) Update() *ReleaseEntryUpdate {
	mutation := newReleaseEntryMutation(c.config, OpUpdate)
	return &ReleaseEntryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseEntryClient) UpdateOne(re *ReleaseEntry) *ReleaseEntryUpdateOne {
	mutation := newReleaseEntryMutation(c.config, OpUpdateOne, withReleaseEntry(re))
	return &ReleaseEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseEntryClient) UpdateOneID(id int) *ReleaseEntryUpdateOne {
	mutation := newReleaseEntryMutation(c.config, OpUpdateOne, withReleaseEntryID(id))
	return &ReleaseEntryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReleaseEntry.
func (c *ReleaseEntryClient) Delete() *ReleaseEntryDelete {
	mutation := newReleaseEntryMutation(c.config, OpDelete)
	return &ReleaseEntryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReleaseEntryClient) DeleteOne(re *ReleaseEntry) *ReleaseEntryDeleteOne {
	return c.DeleteOneID(re.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReleaseEntryClient) DeleteOneID(id int) *ReleaseEntryDeleteOne {
	builder := c.Delete().Where(releaseentry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseEntryDeleteOne{builder}
}

// Query returns a query builder for ReleaseEntry.
func (c *ReleaseEntryClient) Query() *ReleaseEntryQuery {
	return &ReleaseEntryQuery{
		config: c.config,
	}
}

// Get returns a ReleaseEntry entity by its id.
func (c *ReleaseEntryClient) Get(ctx context.Context, id int) (*ReleaseEntry, error) {
	return c.Query().Where(releaseentry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseEntryClient) GetX(ctx context.Context, id int) *ReleaseEntry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArtifact queries the artifact edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryArtifact(re *ReleaseEntry) *ArtifactQuery {
	query := &ArtifactQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(artifact.Table, artifact.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.ArtifactTable, releaseentry.ArtifactColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCodeScan queries the code_scan edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryCodeScan(re *ReleaseEntry) *CodeScanQuery {
	query := &CodeScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(codescan.Table, codescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.CodeScanTable, releaseentry.CodeScanColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestRun queries the test_run edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryTestRun(re *ReleaseEntry) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.TestRunTable, releaseentry.TestRunColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCveScan queries the cve_scan edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryCveScan(re *ReleaseEntry) *CVEScanQuery {
	query := &CVEScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(cvescan.Table, cvescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.CveScanTable, releaseentry.CveScanColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLicenseScan queries the license_scan edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryLicenseScan(re *ReleaseEntry) *LicenseScanQuery {
	query := &LicenseScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(licensescan.Table, licensescan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, releaseentry.LicenseScanTable, releaseentry.LicenseScanColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a ReleaseEntry.
func (c *ReleaseEntryClient) QueryRelease(re *ReleaseEntry) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := re.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(releaseentry.Table, releaseentry.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, releaseentry.ReleaseTable, releaseentry.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(re.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseEntryClient) Hooks() []Hook {
	hooks := c.hooks.ReleaseEntry
	return append(hooks[:len(hooks):len(hooks)], releaseentry.Hooks[:]...)
}

// RepoClient is a client for the Repo schema.
type RepoClient struct {
	config
}

// NewRepoClient returns a client for the Repo from the given config.
func NewRepoClient(c config) *RepoClient {
	return &RepoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repo.Hooks(f(g(h())))`.
func (c *RepoClient) Use(hooks ...Hook) {
	c.hooks.Repo = append(c.hooks.Repo, hooks...)
}

// Create returns a create builder for Repo.
func (c *RepoClient) Create() *RepoCreate {
	mutation := newRepoMutation(c.config, OpCreate)
	return &RepoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Repo entities.
func (c *RepoClient) CreateBulk(builders ...*RepoCreate) *RepoCreateBulk {
	return &RepoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Repo.
func (c *RepoClient) Update() *RepoUpdate {
	mutation := newRepoMutation(c.config, OpUpdate)
	return &RepoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepoClient) UpdateOne(r *Repo) *RepoUpdateOne {
	mutation := newRepoMutation(c.config, OpUpdateOne, withRepo(r))
	return &RepoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepoClient) UpdateOneID(id int) *RepoUpdateOne {
	mutation := newRepoMutation(c.config, OpUpdateOne, withRepoID(id))
	return &RepoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Repo.
func (c *RepoClient) Delete() *RepoDelete {
	mutation := newRepoMutation(c.config, OpDelete)
	return &RepoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RepoClient) DeleteOne(r *Repo) *RepoDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RepoClient) DeleteOneID(id int) *RepoDeleteOne {
	builder := c.Delete().Where(repo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepoDeleteOne{builder}
}

// Query returns a query builder for Repo.
func (c *RepoClient) Query() *RepoQuery {
	return &RepoQuery{
		config: c.config,
	}
}

// Get returns a Repo entity by its id.
func (c *RepoClient) Get(ctx context.Context, id int) (*Repo, error) {
	return c.Query().Where(repo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepoClient) GetX(ctx context.Context, id int) *Repo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProject queries the project edge of a Repo.
func (c *RepoClient) QueryProject(r *Repo) *ProjectQuery {
	query := &ProjectQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repo.Table, repo.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, repo.ProjectTable, repo.ProjectColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommits queries the commits edge of a Repo.
func (c *RepoClient) QueryCommits(r *Repo) *GitCommitQuery {
	query := &GitCommitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repo.Table, repo.FieldID, id),
			sqlgraph.To(gitcommit.Table, gitcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, repo.CommitsTable, repo.CommitsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCveRules queries the cve_rules edge of a Repo.
func (c *RepoClient) QueryCveRules(r *Repo) *CVERuleQuery {
	query := &CVERuleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repo.Table, repo.FieldID, id),
			sqlgraph.To(cverule.Table, cverule.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, repo.CveRulesTable, repo.CveRulesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepoClient) Hooks() []Hook {
	return c.hooks.Repo
}

// TestCaseClient is a client for the TestCase schema.
type TestCaseClient struct {
	config
}

// NewTestCaseClient returns a client for the TestCase from the given config.
func NewTestCaseClient(c config) *TestCaseClient {
	return &TestCaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testcase.Hooks(f(g(h())))`.
func (c *TestCaseClient) Use(hooks ...Hook) {
	c.hooks.TestCase = append(c.hooks.TestCase, hooks...)
}

// Create returns a create builder for TestCase.
func (c *TestCaseClient) Create() *TestCaseCreate {
	mutation := newTestCaseMutation(c.config, OpCreate)
	return &TestCaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestCase entities.
func (c *TestCaseClient) CreateBulk(builders ...*TestCaseCreate) *TestCaseCreateBulk {
	return &TestCaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestCase.
func (c *TestCaseClient) Update() *TestCaseUpdate {
	mutation := newTestCaseMutation(c.config, OpUpdate)
	return &TestCaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestCaseClient) UpdateOne(tc *TestCase) *TestCaseUpdateOne {
	mutation := newTestCaseMutation(c.config, OpUpdateOne, withTestCase(tc))
	return &TestCaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestCaseClient) UpdateOneID(id int) *TestCaseUpdateOne {
	mutation := newTestCaseMutation(c.config, OpUpdateOne, withTestCaseID(id))
	return &TestCaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestCase.
func (c *TestCaseClient) Delete() *TestCaseDelete {
	mutation := newTestCaseMutation(c.config, OpDelete)
	return &TestCaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TestCaseClient) DeleteOne(tc *TestCase) *TestCaseDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TestCaseClient) DeleteOneID(id int) *TestCaseDeleteOne {
	builder := c.Delete().Where(testcase.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestCaseDeleteOne{builder}
}

// Query returns a query builder for TestCase.
func (c *TestCaseClient) Query() *TestCaseQuery {
	return &TestCaseQuery{
		config: c.config,
	}
}

// Get returns a TestCase entity by its id.
func (c *TestCaseClient) Get(ctx context.Context, id int) (*TestCase, error) {
	return c.Query().Where(testcase.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestCaseClient) GetX(ctx context.Context, id int) *TestCase {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRun queries the run edge of a TestCase.
func (c *TestCaseClient) QueryRun(tc *TestCase) *TestRunQuery {
	query := &TestRunQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testcase.Table, testcase.FieldID, id),
			sqlgraph.To(testrun.Table, testrun.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testcase.RunTable, testcase.RunColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestCaseClient) Hooks() []Hook {
	return c.hooks.TestCase
}

// TestRunClient is a client for the TestRun schema.
type TestRunClient struct {
	config
}

// NewTestRunClient returns a client for the TestRun from the given config.
func NewTestRunClient(c config) *TestRunClient {
	return &TestRunClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testrun.Hooks(f(g(h())))`.
func (c *TestRunClient) Use(hooks ...Hook) {
	c.hooks.TestRun = append(c.hooks.TestRun, hooks...)
}

// Create returns a create builder for TestRun.
func (c *TestRunClient) Create() *TestRunCreate {
	mutation := newTestRunMutation(c.config, OpCreate)
	return &TestRunCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestRun entities.
func (c *TestRunClient) CreateBulk(builders ...*TestRunCreate) *TestRunCreateBulk {
	return &TestRunCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestRun.
func (c *TestRunClient) Update() *TestRunUpdate {
	mutation := newTestRunMutation(c.config, OpUpdate)
	return &TestRunUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestRunClient) UpdateOne(tr *TestRun) *TestRunUpdateOne {
	mutation := newTestRunMutation(c.config, OpUpdateOne, withTestRun(tr))
	return &TestRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestRunClient) UpdateOneID(id int) *TestRunUpdateOne {
	mutation := newTestRunMutation(c.config, OpUpdateOne, withTestRunID(id))
	return &TestRunUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestRun.
func (c *TestRunClient) Delete() *TestRunDelete {
	mutation := newTestRunMutation(c.config, OpDelete)
	return &TestRunDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TestRunClient) DeleteOne(tr *TestRun) *TestRunDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TestRunClient) DeleteOneID(id int) *TestRunDeleteOne {
	builder := c.Delete().Where(testrun.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestRunDeleteOne{builder}
}

// Query returns a query builder for TestRun.
func (c *TestRunClient) Query() *TestRunQuery {
	return &TestRunQuery{
		config: c.config,
	}
}

// Get returns a TestRun entity by its id.
func (c *TestRunClient) Get(ctx context.Context, id int) (*TestRun, error) {
	return c.Query().Where(testrun.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestRunClient) GetX(ctx context.Context, id int) *TestRun {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRelease queries the release edge of a TestRun.
func (c *TestRunClient) QueryRelease(tr *TestRun) *ReleaseQuery {
	query := &ReleaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testrun.ReleaseTable, testrun.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEntry queries the entry edge of a TestRun.
func (c *TestRunClient) QueryEntry(tr *TestRun) *ReleaseEntryQuery {
	query := &ReleaseEntryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(releaseentry.Table, releaseentry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, testrun.EntryTable, testrun.EntryColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTests queries the tests edge of a TestRun.
func (c *TestRunClient) QueryTests(tr *TestRun) *TestCaseQuery {
	query := &TestCaseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testrun.Table, testrun.FieldID, id),
			sqlgraph.To(testcase.Table, testcase.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, testrun.TestsTable, testrun.TestsColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestRunClient) Hooks() []Hook {
	hooks := c.hooks.TestRun
	return append(hooks[:len(hooks):len(hooks)], testrun.Hooks[:]...)
}

// VulnerabilityClient is a client for the Vulnerability schema.
type VulnerabilityClient struct {
	config
}

// NewVulnerabilityClient returns a client for the Vulnerability from the given config.
func NewVulnerabilityClient(c config) *VulnerabilityClient {
	return &VulnerabilityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vulnerability.Hooks(f(g(h())))`.
func (c *VulnerabilityClient) Use(hooks ...Hook) {
	c.hooks.Vulnerability = append(c.hooks.Vulnerability, hooks...)
}

// Create returns a create builder for Vulnerability.
func (c *VulnerabilityClient) Create() *VulnerabilityCreate {
	mutation := newVulnerabilityMutation(c.config, OpCreate)
	return &VulnerabilityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vulnerability entities.
func (c *VulnerabilityClient) CreateBulk(builders ...*VulnerabilityCreate) *VulnerabilityCreateBulk {
	return &VulnerabilityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vulnerability.
func (c *VulnerabilityClient) Update() *VulnerabilityUpdate {
	mutation := newVulnerabilityMutation(c.config, OpUpdate)
	return &VulnerabilityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VulnerabilityClient) UpdateOne(v *Vulnerability) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerability(v))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VulnerabilityClient) UpdateOneID(id int) *VulnerabilityUpdateOne {
	mutation := newVulnerabilityMutation(c.config, OpUpdateOne, withVulnerabilityID(id))
	return &VulnerabilityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vulnerability.
func (c *VulnerabilityClient) Delete() *VulnerabilityDelete {
	mutation := newVulnerabilityMutation(c.config, OpDelete)
	return &VulnerabilityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VulnerabilityClient) DeleteOne(v *Vulnerability) *VulnerabilityDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VulnerabilityClient) DeleteOneID(id int) *VulnerabilityDeleteOne {
	builder := c.Delete().Where(vulnerability.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VulnerabilityDeleteOne{builder}
}

// Query returns a query builder for Vulnerability.
func (c *VulnerabilityClient) Query() *VulnerabilityQuery {
	return &VulnerabilityQuery{
		config: c.config,
	}
}

// Get returns a Vulnerability entity by its id.
func (c *VulnerabilityClient) Get(ctx context.Context, id int) (*Vulnerability, error) {
	return c.Query().Where(vulnerability.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VulnerabilityClient) GetX(ctx context.Context, id int) *Vulnerability {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCve queries the cve edge of a Vulnerability.
func (c *VulnerabilityClient) QueryCve(v *Vulnerability) *CVEQuery {
	query := &CVEQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(cve.Table, cve.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnerability.CveTable, vulnerability.CveColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScan queries the scan edge of a Vulnerability.
func (c *VulnerabilityClient) QueryScan(v *Vulnerability) *CVEScanQuery {
	query := &CVEScanQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(cvescan.Table, cvescan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, vulnerability.ScanTable, vulnerability.ScanColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a Vulnerability.
func (c *VulnerabilityClient) QueryComponent(v *Vulnerability) *ComponentQuery {
	query := &ComponentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := v.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vulnerability.Table, vulnerability.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vulnerability.ComponentTable, vulnerability.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(v.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VulnerabilityClient) Hooks() []Hook {
	return c.hooks.Vulnerability
}
