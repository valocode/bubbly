// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/valocode/bubbly/ent/adapter"
	"github.com/valocode/bubbly/ent/artifact"
	"github.com/valocode/bubbly/ent/codeissue"
	"github.com/valocode/bubbly/ent/codescan"
	"github.com/valocode/bubbly/ent/component"
	"github.com/valocode/bubbly/ent/event"
	"github.com/valocode/bubbly/ent/gitcommit"
	"github.com/valocode/bubbly/ent/license"
	"github.com/valocode/bubbly/ent/organization"
	"github.com/valocode/bubbly/ent/project"
	"github.com/valocode/bubbly/ent/release"
	"github.com/valocode/bubbly/ent/releasecomponent"
	"github.com/valocode/bubbly/ent/releaseentry"
	"github.com/valocode/bubbly/ent/releaselicense"
	"github.com/valocode/bubbly/ent/releasepolicy"
	"github.com/valocode/bubbly/ent/releasepolicyviolation"
	"github.com/valocode/bubbly/ent/releasevulnerability"
	"github.com/valocode/bubbly/ent/repo"
	"github.com/valocode/bubbly/ent/testcase"
	"github.com/valocode/bubbly/ent/testrun"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/valocode/bubbly/ent/vulnerabilityreview"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// AdapterEdge is the edge representation of Adapter.
type AdapterEdge struct {
	Node   *Adapter `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// AdapterConnection is the connection containing edges to Adapter.
type AdapterConnection struct {
	Edges      []*AdapterEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// AdapterPaginateOption enables pagination customization.
type AdapterPaginateOption func(*adapterPager) error

// WithAdapterOrder configures pagination ordering.
func WithAdapterOrder(order *AdapterOrder) AdapterPaginateOption {
	if order == nil {
		order = DefaultAdapterOrder
	}
	o := *order
	return func(pager *adapterPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAdapterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAdapterFilter configures pagination filter.
func WithAdapterFilter(filter func(*AdapterQuery) (*AdapterQuery, error)) AdapterPaginateOption {
	return func(pager *adapterPager) error {
		if filter == nil {
			return errors.New("AdapterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type adapterPager struct {
	order  *AdapterOrder
	filter func(*AdapterQuery) (*AdapterQuery, error)
}

func newAdapterPager(opts []AdapterPaginateOption) (*adapterPager, error) {
	pager := &adapterPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAdapterOrder
	}
	return pager, nil
}

func (p *adapterPager) applyFilter(query *AdapterQuery) (*AdapterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *adapterPager) toCursor(a *Adapter) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *adapterPager) applyCursors(query *AdapterQuery, after, before *Cursor) *AdapterQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAdapterOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *adapterPager) applyOrder(query *AdapterQuery, reverse bool) *AdapterQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAdapterOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAdapterOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Adapter.
func (a *AdapterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AdapterPaginateOption,
) (*AdapterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAdapterPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &AdapterConnection{Edges: []*AdapterEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Adapter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Adapter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Adapter {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AdapterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AdapterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// AdapterOrderFieldName orders Adapter by name.
	AdapterOrderFieldName = &AdapterOrderField{
		field: adapter.FieldName,
		toCursor: func(a *Adapter) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Name,
			}
		},
	}
	// AdapterOrderFieldTag orders Adapter by tag.
	AdapterOrderFieldTag = &AdapterOrderField{
		field: adapter.FieldTag,
		toCursor: func(a *Adapter) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Tag,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AdapterOrderField) String() string {
	var str string
	switch f.field {
	case adapter.FieldName:
		str = "name"
	case adapter.FieldTag:
		str = "tag"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AdapterOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AdapterOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AdapterOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *AdapterOrderFieldName
	case "tag":
		*f = *AdapterOrderFieldTag
	default:
		return fmt.Errorf("%s is not a valid AdapterOrderField", str)
	}
	return nil
}

// AdapterOrderField defines the ordering field of Adapter.
type AdapterOrderField struct {
	field    string
	toCursor func(*Adapter) Cursor
}

// AdapterOrder defines the ordering of Adapter.
type AdapterOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *AdapterOrderField `json:"field"`
}

// DefaultAdapterOrder is the default ordering of Adapter.
var DefaultAdapterOrder = &AdapterOrder{
	Direction: OrderDirectionAsc,
	Field: &AdapterOrderField{
		field: adapter.FieldID,
		toCursor: func(a *Adapter) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Adapter into AdapterEdge.
func (a *Adapter) ToEdge(order *AdapterOrder) *AdapterEdge {
	if order == nil {
		order = DefaultAdapterOrder
	}
	return &AdapterEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// ArtifactEdge is the edge representation of Artifact.
type ArtifactEdge struct {
	Node   *Artifact `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ArtifactConnection is the connection containing edges to Artifact.
type ArtifactConnection struct {
	Edges      []*ArtifactEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// ArtifactPaginateOption enables pagination customization.
type ArtifactPaginateOption func(*artifactPager) error

// WithArtifactOrder configures pagination ordering.
func WithArtifactOrder(order *ArtifactOrder) ArtifactPaginateOption {
	if order == nil {
		order = DefaultArtifactOrder
	}
	o := *order
	return func(pager *artifactPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultArtifactOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithArtifactFilter configures pagination filter.
func WithArtifactFilter(filter func(*ArtifactQuery) (*ArtifactQuery, error)) ArtifactPaginateOption {
	return func(pager *artifactPager) error {
		if filter == nil {
			return errors.New("ArtifactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type artifactPager struct {
	order  *ArtifactOrder
	filter func(*ArtifactQuery) (*ArtifactQuery, error)
}

func newArtifactPager(opts []ArtifactPaginateOption) (*artifactPager, error) {
	pager := &artifactPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultArtifactOrder
	}
	return pager, nil
}

func (p *artifactPager) applyFilter(query *ArtifactQuery) (*ArtifactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *artifactPager) toCursor(a *Artifact) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *artifactPager) applyCursors(query *ArtifactQuery, after, before *Cursor) *ArtifactQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultArtifactOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *artifactPager) applyOrder(query *ArtifactQuery, reverse bool) *ArtifactQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultArtifactOrder.Field {
		query = query.Order(direction.orderFunc(DefaultArtifactOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Artifact.
func (a *ArtifactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ArtifactPaginateOption,
) (*ArtifactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newArtifactPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &ArtifactConnection{Edges: []*ArtifactEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Artifact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Artifact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Artifact {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ArtifactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ArtifactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ArtifactOrderFieldName orders Artifact by name.
	ArtifactOrderFieldName = &ArtifactOrderField{
		field: artifact.FieldName,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Name,
			}
		},
	}
	// ArtifactOrderFieldSha256 orders Artifact by sha256.
	ArtifactOrderFieldSha256 = &ArtifactOrderField{
		field: artifact.FieldSha256,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Sha256,
			}
		},
	}
	// ArtifactOrderFieldType orders Artifact by type.
	ArtifactOrderFieldType = &ArtifactOrderField{
		field: artifact.FieldType,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Type,
			}
		},
	}
	// ArtifactOrderFieldTime orders Artifact by time.
	ArtifactOrderFieldTime = &ArtifactOrderField{
		field: artifact.FieldTime,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ArtifactOrderField) String() string {
	var str string
	switch f.field {
	case artifact.FieldName:
		str = "name"
	case artifact.FieldSha256:
		str = "sha256"
	case artifact.FieldType:
		str = "type"
	case artifact.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ArtifactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ArtifactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ArtifactOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ArtifactOrderFieldName
	case "sha256":
		*f = *ArtifactOrderFieldSha256
	case "type":
		*f = *ArtifactOrderFieldType
	case "time":
		*f = *ArtifactOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid ArtifactOrderField", str)
	}
	return nil
}

// ArtifactOrderField defines the ordering field of Artifact.
type ArtifactOrderField struct {
	field    string
	toCursor func(*Artifact) Cursor
}

// ArtifactOrder defines the ordering of Artifact.
type ArtifactOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ArtifactOrderField `json:"field"`
}

// DefaultArtifactOrder is the default ordering of Artifact.
var DefaultArtifactOrder = &ArtifactOrder{
	Direction: OrderDirectionAsc,
	Field: &ArtifactOrderField{
		field: artifact.FieldID,
		toCursor: func(a *Artifact) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Artifact into ArtifactEdge.
func (a *Artifact) ToEdge(order *ArtifactOrder) *ArtifactEdge {
	if order == nil {
		order = DefaultArtifactOrder
	}
	return &ArtifactEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// CodeIssueEdge is the edge representation of CodeIssue.
type CodeIssueEdge struct {
	Node   *CodeIssue `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// CodeIssueConnection is the connection containing edges to CodeIssue.
type CodeIssueConnection struct {
	Edges      []*CodeIssueEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// CodeIssuePaginateOption enables pagination customization.
type CodeIssuePaginateOption func(*codeIssuePager) error

// WithCodeIssueOrder configures pagination ordering.
func WithCodeIssueOrder(order *CodeIssueOrder) CodeIssuePaginateOption {
	if order == nil {
		order = DefaultCodeIssueOrder
	}
	o := *order
	return func(pager *codeIssuePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCodeIssueOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCodeIssueFilter configures pagination filter.
func WithCodeIssueFilter(filter func(*CodeIssueQuery) (*CodeIssueQuery, error)) CodeIssuePaginateOption {
	return func(pager *codeIssuePager) error {
		if filter == nil {
			return errors.New("CodeIssueQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type codeIssuePager struct {
	order  *CodeIssueOrder
	filter func(*CodeIssueQuery) (*CodeIssueQuery, error)
}

func newCodeIssuePager(opts []CodeIssuePaginateOption) (*codeIssuePager, error) {
	pager := &codeIssuePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCodeIssueOrder
	}
	return pager, nil
}

func (p *codeIssuePager) applyFilter(query *CodeIssueQuery) (*CodeIssueQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *codeIssuePager) toCursor(ci *CodeIssue) Cursor {
	return p.order.Field.toCursor(ci)
}

func (p *codeIssuePager) applyCursors(query *CodeIssueQuery, after, before *Cursor) *CodeIssueQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCodeIssueOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *codeIssuePager) applyOrder(query *CodeIssueQuery, reverse bool) *CodeIssueQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCodeIssueOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCodeIssueOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CodeIssue.
func (ci *CodeIssueQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CodeIssuePaginateOption,
) (*CodeIssueConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCodeIssuePager(opts)
	if err != nil {
		return nil, err
	}

	if ci, err = pager.applyFilter(ci); err != nil {
		return nil, err
	}

	conn := &CodeIssueConnection{Edges: []*CodeIssueEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ci.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ci.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ci = pager.applyCursors(ci, after, before)
	ci = pager.applyOrder(ci, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ci = ci.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ci = ci.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ci.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CodeIssue
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CodeIssue {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CodeIssue {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CodeIssueEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CodeIssueEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CodeIssueOrderFieldRuleID orders CodeIssue by rule_id.
	CodeIssueOrderFieldRuleID = &CodeIssueOrderField{
		field: codeissue.FieldRuleID,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.RuleID,
			}
		},
	}
	// CodeIssueOrderFieldSeverity orders CodeIssue by severity.
	CodeIssueOrderFieldSeverity = &CodeIssueOrderField{
		field: codeissue.FieldSeverity,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.Severity,
			}
		},
	}
	// CodeIssueOrderFieldType orders CodeIssue by type.
	CodeIssueOrderFieldType = &CodeIssueOrderField{
		field: codeissue.FieldType,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.Type,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CodeIssueOrderField) String() string {
	var str string
	switch f.field {
	case codeissue.FieldRuleID:
		str = "rule_id"
	case codeissue.FieldSeverity:
		str = "severity"
	case codeissue.FieldType:
		str = "type"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CodeIssueOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CodeIssueOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CodeIssueOrderField %T must be a string", v)
	}
	switch str {
	case "rule_id":
		*f = *CodeIssueOrderFieldRuleID
	case "severity":
		*f = *CodeIssueOrderFieldSeverity
	case "type":
		*f = *CodeIssueOrderFieldType
	default:
		return fmt.Errorf("%s is not a valid CodeIssueOrderField", str)
	}
	return nil
}

// CodeIssueOrderField defines the ordering field of CodeIssue.
type CodeIssueOrderField struct {
	field    string
	toCursor func(*CodeIssue) Cursor
}

// CodeIssueOrder defines the ordering of CodeIssue.
type CodeIssueOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *CodeIssueOrderField `json:"field"`
}

// DefaultCodeIssueOrder is the default ordering of CodeIssue.
var DefaultCodeIssueOrder = &CodeIssueOrder{
	Direction: OrderDirectionAsc,
	Field: &CodeIssueOrderField{
		field: codeissue.FieldID,
		toCursor: func(ci *CodeIssue) Cursor {
			return Cursor{ID: ci.ID}
		},
	},
}

// ToEdge converts CodeIssue into CodeIssueEdge.
func (ci *CodeIssue) ToEdge(order *CodeIssueOrder) *CodeIssueEdge {
	if order == nil {
		order = DefaultCodeIssueOrder
	}
	return &CodeIssueEdge{
		Node:   ci,
		Cursor: order.Field.toCursor(ci),
	}
}

// CodeScanEdge is the edge representation of CodeScan.
type CodeScanEdge struct {
	Node   *CodeScan `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CodeScanConnection is the connection containing edges to CodeScan.
type CodeScanConnection struct {
	Edges      []*CodeScanEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// CodeScanPaginateOption enables pagination customization.
type CodeScanPaginateOption func(*codeScanPager) error

// WithCodeScanOrder configures pagination ordering.
func WithCodeScanOrder(order *CodeScanOrder) CodeScanPaginateOption {
	if order == nil {
		order = DefaultCodeScanOrder
	}
	o := *order
	return func(pager *codeScanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCodeScanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCodeScanFilter configures pagination filter.
func WithCodeScanFilter(filter func(*CodeScanQuery) (*CodeScanQuery, error)) CodeScanPaginateOption {
	return func(pager *codeScanPager) error {
		if filter == nil {
			return errors.New("CodeScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type codeScanPager struct {
	order  *CodeScanOrder
	filter func(*CodeScanQuery) (*CodeScanQuery, error)
}

func newCodeScanPager(opts []CodeScanPaginateOption) (*codeScanPager, error) {
	pager := &codeScanPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCodeScanOrder
	}
	return pager, nil
}

func (p *codeScanPager) applyFilter(query *CodeScanQuery) (*CodeScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *codeScanPager) toCursor(cs *CodeScan) Cursor {
	return p.order.Field.toCursor(cs)
}

func (p *codeScanPager) applyCursors(query *CodeScanQuery, after, before *Cursor) *CodeScanQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCodeScanOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *codeScanPager) applyOrder(query *CodeScanQuery, reverse bool) *CodeScanQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCodeScanOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCodeScanOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CodeScan.
func (cs *CodeScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CodeScanPaginateOption,
) (*CodeScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCodeScanPager(opts)
	if err != nil {
		return nil, err
	}

	if cs, err = pager.applyFilter(cs); err != nil {
		return nil, err
	}

	conn := &CodeScanConnection{Edges: []*CodeScanEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := cs.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := cs.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	cs = pager.applyCursors(cs, after, before)
	cs = pager.applyOrder(cs, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		cs = cs.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		cs = cs.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := cs.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CodeScan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CodeScan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CodeScan {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CodeScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CodeScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CodeScanOrderFieldTool orders CodeScan by tool.
	CodeScanOrderFieldTool = &CodeScanOrderField{
		field: codescan.FieldTool,
		toCursor: func(cs *CodeScan) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.Tool,
			}
		},
	}
	// CodeScanOrderFieldTime orders CodeScan by time.
	CodeScanOrderFieldTime = &CodeScanOrderField{
		field: codescan.FieldTime,
		toCursor: func(cs *CodeScan) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CodeScanOrderField) String() string {
	var str string
	switch f.field {
	case codescan.FieldTool:
		str = "tool"
	case codescan.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CodeScanOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CodeScanOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CodeScanOrderField %T must be a string", v)
	}
	switch str {
	case "tool":
		*f = *CodeScanOrderFieldTool
	case "time":
		*f = *CodeScanOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid CodeScanOrderField", str)
	}
	return nil
}

// CodeScanOrderField defines the ordering field of CodeScan.
type CodeScanOrderField struct {
	field    string
	toCursor func(*CodeScan) Cursor
}

// CodeScanOrder defines the ordering of CodeScan.
type CodeScanOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CodeScanOrderField `json:"field"`
}

// DefaultCodeScanOrder is the default ordering of CodeScan.
var DefaultCodeScanOrder = &CodeScanOrder{
	Direction: OrderDirectionAsc,
	Field: &CodeScanOrderField{
		field: codescan.FieldID,
		toCursor: func(cs *CodeScan) Cursor {
			return Cursor{ID: cs.ID}
		},
	},
}

// ToEdge converts CodeScan into CodeScanEdge.
func (cs *CodeScan) ToEdge(order *CodeScanOrder) *CodeScanEdge {
	if order == nil {
		order = DefaultCodeScanOrder
	}
	return &CodeScanEdge{
		Node:   cs,
		Cursor: order.Field.toCursor(cs),
	}
}

// ComponentEdge is the edge representation of Component.
type ComponentEdge struct {
	Node   *Component `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ComponentConnection is the connection containing edges to Component.
type ComponentConnection struct {
	Edges      []*ComponentEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// ComponentPaginateOption enables pagination customization.
type ComponentPaginateOption func(*componentPager) error

// WithComponentOrder configures pagination ordering.
func WithComponentOrder(order *ComponentOrder) ComponentPaginateOption {
	if order == nil {
		order = DefaultComponentOrder
	}
	o := *order
	return func(pager *componentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultComponentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithComponentFilter configures pagination filter.
func WithComponentFilter(filter func(*ComponentQuery) (*ComponentQuery, error)) ComponentPaginateOption {
	return func(pager *componentPager) error {
		if filter == nil {
			return errors.New("ComponentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type componentPager struct {
	order  *ComponentOrder
	filter func(*ComponentQuery) (*ComponentQuery, error)
}

func newComponentPager(opts []ComponentPaginateOption) (*componentPager, error) {
	pager := &componentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultComponentOrder
	}
	return pager, nil
}

func (p *componentPager) applyFilter(query *ComponentQuery) (*ComponentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *componentPager) toCursor(c *Component) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *componentPager) applyCursors(query *ComponentQuery, after, before *Cursor) *ComponentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultComponentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *componentPager) applyOrder(query *ComponentQuery, reverse bool) *ComponentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultComponentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultComponentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Component.
func (c *ComponentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ComponentPaginateOption,
) (*ComponentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newComponentPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &ComponentConnection{Edges: []*ComponentEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Component
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Component {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Component {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ComponentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ComponentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ComponentOrderFieldName orders Component by name.
	ComponentOrderFieldName = &ComponentOrderField{
		field: component.FieldName,
		toCursor: func(c *Component) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// ComponentOrderFieldVendor orders Component by vendor.
	ComponentOrderFieldVendor = &ComponentOrderField{
		field: component.FieldVendor,
		toCursor: func(c *Component) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Vendor,
			}
		},
	}
	// ComponentOrderFieldVersion orders Component by version.
	ComponentOrderFieldVersion = &ComponentOrderField{
		field: component.FieldVersion,
		toCursor: func(c *Component) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Version,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ComponentOrderField) String() string {
	var str string
	switch f.field {
	case component.FieldName:
		str = "name"
	case component.FieldVendor:
		str = "vendor"
	case component.FieldVersion:
		str = "version"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ComponentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ComponentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ComponentOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ComponentOrderFieldName
	case "vendor":
		*f = *ComponentOrderFieldVendor
	case "version":
		*f = *ComponentOrderFieldVersion
	default:
		return fmt.Errorf("%s is not a valid ComponentOrderField", str)
	}
	return nil
}

// ComponentOrderField defines the ordering field of Component.
type ComponentOrderField struct {
	field    string
	toCursor func(*Component) Cursor
}

// ComponentOrder defines the ordering of Component.
type ComponentOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ComponentOrderField `json:"field"`
}

// DefaultComponentOrder is the default ordering of Component.
var DefaultComponentOrder = &ComponentOrder{
	Direction: OrderDirectionAsc,
	Field: &ComponentOrderField{
		field: component.FieldID,
		toCursor: func(c *Component) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Component into ComponentEdge.
func (c *Component) ToEdge(order *ComponentOrder) *ComponentEdge {
	if order == nil {
		order = DefaultComponentOrder
	}
	return &ComponentEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// EventEdge is the edge representation of Event.
type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EventConnection is the connection containing edges to Event.
type EventConnection struct {
	Edges      []*EventEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// EventPaginateOption enables pagination customization.
type EventPaginateOption func(*eventPager) error

// WithEventOrder configures pagination ordering.
func WithEventOrder(order *EventOrder) EventPaginateOption {
	if order == nil {
		order = DefaultEventOrder
	}
	o := *order
	return func(pager *eventPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventFilter configures pagination filter.
func WithEventFilter(filter func(*EventQuery) (*EventQuery, error)) EventPaginateOption {
	return func(pager *eventPager) error {
		if filter == nil {
			return errors.New("EventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventPager struct {
	order  *EventOrder
	filter func(*EventQuery) (*EventQuery, error)
}

func newEventPager(opts []EventPaginateOption) (*eventPager, error) {
	pager := &eventPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventOrder
	}
	return pager, nil
}

func (p *eventPager) applyFilter(query *EventQuery) (*EventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventPager) toCursor(e *Event) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *eventPager) applyCursors(query *EventQuery, after, before *Cursor) *EventQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEventOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *eventPager) applyOrder(query *EventQuery, reverse bool) *EventQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEventOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEventOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Event.
func (e *EventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventPaginateOption,
) (*EventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}

	conn := &EventConnection{Edges: []*EventEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := e.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := e.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		e = e.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := e.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Event
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Event {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Event {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// EventOrderFieldType orders Event by type.
	EventOrderFieldType = &EventOrderField{
		field: event.FieldType,
		toCursor: func(e *Event) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Type,
			}
		},
	}
	// EventOrderFieldTime orders Event by time.
	EventOrderFieldTime = &EventOrderField{
		field: event.FieldTime,
		toCursor: func(e *Event) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EventOrderField) String() string {
	var str string
	switch f.field {
	case event.FieldType:
		str = "type"
	case event.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EventOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EventOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EventOrderField %T must be a string", v)
	}
	switch str {
	case "type":
		*f = *EventOrderFieldType
	case "time":
		*f = *EventOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid EventOrderField", str)
	}
	return nil
}

// EventOrderField defines the ordering field of Event.
type EventOrderField struct {
	field    string
	toCursor func(*Event) Cursor
}

// EventOrder defines the ordering of Event.
type EventOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EventOrderField `json:"field"`
}

// DefaultEventOrder is the default ordering of Event.
var DefaultEventOrder = &EventOrder{
	Direction: OrderDirectionAsc,
	Field: &EventOrderField{
		field: event.FieldID,
		toCursor: func(e *Event) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Event into EventEdge.
func (e *Event) ToEdge(order *EventOrder) *EventEdge {
	if order == nil {
		order = DefaultEventOrder
	}
	return &EventEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// GitCommitEdge is the edge representation of GitCommit.
type GitCommitEdge struct {
	Node   *GitCommit `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// GitCommitConnection is the connection containing edges to GitCommit.
type GitCommitConnection struct {
	Edges      []*GitCommitEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// GitCommitPaginateOption enables pagination customization.
type GitCommitPaginateOption func(*gitCommitPager) error

// WithGitCommitOrder configures pagination ordering.
func WithGitCommitOrder(order *GitCommitOrder) GitCommitPaginateOption {
	if order == nil {
		order = DefaultGitCommitOrder
	}
	o := *order
	return func(pager *gitCommitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGitCommitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGitCommitFilter configures pagination filter.
func WithGitCommitFilter(filter func(*GitCommitQuery) (*GitCommitQuery, error)) GitCommitPaginateOption {
	return func(pager *gitCommitPager) error {
		if filter == nil {
			return errors.New("GitCommitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gitCommitPager struct {
	order  *GitCommitOrder
	filter func(*GitCommitQuery) (*GitCommitQuery, error)
}

func newGitCommitPager(opts []GitCommitPaginateOption) (*gitCommitPager, error) {
	pager := &gitCommitPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGitCommitOrder
	}
	return pager, nil
}

func (p *gitCommitPager) applyFilter(query *GitCommitQuery) (*GitCommitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gitCommitPager) toCursor(gc *GitCommit) Cursor {
	return p.order.Field.toCursor(gc)
}

func (p *gitCommitPager) applyCursors(query *GitCommitQuery, after, before *Cursor) *GitCommitQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultGitCommitOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *gitCommitPager) applyOrder(query *GitCommitQuery, reverse bool) *GitCommitQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultGitCommitOrder.Field {
		query = query.Order(direction.orderFunc(DefaultGitCommitOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to GitCommit.
func (gc *GitCommitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GitCommitPaginateOption,
) (*GitCommitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGitCommitPager(opts)
	if err != nil {
		return nil, err
	}

	if gc, err = pager.applyFilter(gc); err != nil {
		return nil, err
	}

	conn := &GitCommitConnection{Edges: []*GitCommitEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := gc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := gc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	gc = pager.applyCursors(gc, after, before)
	gc = pager.applyOrder(gc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		gc = gc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		gc = gc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := gc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *GitCommit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GitCommit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GitCommit {
			return nodes[i]
		}
	}

	conn.Edges = make([]*GitCommitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &GitCommitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// GitCommitOrderFieldHash orders GitCommit by hash.
	GitCommitOrderFieldHash = &GitCommitOrderField{
		field: gitcommit.FieldHash,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Hash,
			}
		},
	}
	// GitCommitOrderFieldBranch orders GitCommit by branch.
	GitCommitOrderFieldBranch = &GitCommitOrderField{
		field: gitcommit.FieldBranch,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Branch,
			}
		},
	}
	// GitCommitOrderFieldTag orders GitCommit by tag.
	GitCommitOrderFieldTag = &GitCommitOrderField{
		field: gitcommit.FieldTag,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Tag,
			}
		},
	}
	// GitCommitOrderFieldTime orders GitCommit by time.
	GitCommitOrderFieldTime = &GitCommitOrderField{
		field: gitcommit.FieldTime,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{
				ID:    gc.ID,
				Value: gc.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GitCommitOrderField) String() string {
	var str string
	switch f.field {
	case gitcommit.FieldHash:
		str = "hash"
	case gitcommit.FieldBranch:
		str = "branch"
	case gitcommit.FieldTag:
		str = "tag"
	case gitcommit.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GitCommitOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GitCommitOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GitCommitOrderField %T must be a string", v)
	}
	switch str {
	case "hash":
		*f = *GitCommitOrderFieldHash
	case "branch":
		*f = *GitCommitOrderFieldBranch
	case "tag":
		*f = *GitCommitOrderFieldTag
	case "time":
		*f = *GitCommitOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid GitCommitOrderField", str)
	}
	return nil
}

// GitCommitOrderField defines the ordering field of GitCommit.
type GitCommitOrderField struct {
	field    string
	toCursor func(*GitCommit) Cursor
}

// GitCommitOrder defines the ordering of GitCommit.
type GitCommitOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *GitCommitOrderField `json:"field"`
}

// DefaultGitCommitOrder is the default ordering of GitCommit.
var DefaultGitCommitOrder = &GitCommitOrder{
	Direction: OrderDirectionAsc,
	Field: &GitCommitOrderField{
		field: gitcommit.FieldID,
		toCursor: func(gc *GitCommit) Cursor {
			return Cursor{ID: gc.ID}
		},
	},
}

// ToEdge converts GitCommit into GitCommitEdge.
func (gc *GitCommit) ToEdge(order *GitCommitOrder) *GitCommitEdge {
	if order == nil {
		order = DefaultGitCommitOrder
	}
	return &GitCommitEdge{
		Node:   gc,
		Cursor: order.Field.toCursor(gc),
	}
}

// LicenseEdge is the edge representation of License.
type LicenseEdge struct {
	Node   *License `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// LicenseConnection is the connection containing edges to License.
type LicenseConnection struct {
	Edges      []*LicenseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// LicensePaginateOption enables pagination customization.
type LicensePaginateOption func(*licensePager) error

// WithLicenseOrder configures pagination ordering.
func WithLicenseOrder(order *LicenseOrder) LicensePaginateOption {
	if order == nil {
		order = DefaultLicenseOrder
	}
	o := *order
	return func(pager *licensePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLicenseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLicenseFilter configures pagination filter.
func WithLicenseFilter(filter func(*LicenseQuery) (*LicenseQuery, error)) LicensePaginateOption {
	return func(pager *licensePager) error {
		if filter == nil {
			return errors.New("LicenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type licensePager struct {
	order  *LicenseOrder
	filter func(*LicenseQuery) (*LicenseQuery, error)
}

func newLicensePager(opts []LicensePaginateOption) (*licensePager, error) {
	pager := &licensePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLicenseOrder
	}
	return pager, nil
}

func (p *licensePager) applyFilter(query *LicenseQuery) (*LicenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *licensePager) toCursor(l *License) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *licensePager) applyCursors(query *LicenseQuery, after, before *Cursor) *LicenseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLicenseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *licensePager) applyOrder(query *LicenseQuery, reverse bool) *LicenseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLicenseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLicenseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to License.
func (l *LicenseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LicensePaginateOption,
) (*LicenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLicensePager(opts)
	if err != nil {
		return nil, err
	}

	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}

	conn := &LicenseConnection{Edges: []*LicenseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := l.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := l.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	l = pager.applyCursors(l, after, before)
	l = pager.applyOrder(l, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		l = l.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		l = l.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := l.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *License
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *License {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *License {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LicenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LicenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// LicenseOrderFieldSpdxID orders License by spdx_id.
	LicenseOrderFieldSpdxID = &LicenseOrderField{
		field: license.FieldSpdxID,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.SpdxID,
			}
		},
	}
	// LicenseOrderFieldName orders License by name.
	LicenseOrderFieldName = &LicenseOrderField{
		field: license.FieldName,
		toCursor: func(l *License) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LicenseOrderField) String() string {
	var str string
	switch f.field {
	case license.FieldSpdxID:
		str = "spdx_id"
	case license.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LicenseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LicenseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LicenseOrderField %T must be a string", v)
	}
	switch str {
	case "spdx_id":
		*f = *LicenseOrderFieldSpdxID
	case "name":
		*f = *LicenseOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid LicenseOrderField", str)
	}
	return nil
}

// LicenseOrderField defines the ordering field of License.
type LicenseOrderField struct {
	field    string
	toCursor func(*License) Cursor
}

// LicenseOrder defines the ordering of License.
type LicenseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *LicenseOrderField `json:"field"`
}

// DefaultLicenseOrder is the default ordering of License.
var DefaultLicenseOrder = &LicenseOrder{
	Direction: OrderDirectionAsc,
	Field: &LicenseOrderField{
		field: license.FieldID,
		toCursor: func(l *License) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts License into LicenseEdge.
func (l *License) ToEdge(order *LicenseOrder) *LicenseEdge {
	if order == nil {
		order = DefaultLicenseOrder
	}
	return &LicenseEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order *OrganizationOrder) OrganizationPaginateOption {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	o := *order
	return func(pager *organizationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	order  *OrganizationOrder
	filter func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption) (*organizationPager, error) {
	pager := &organizationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationOrder
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) *OrganizationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultOrganizationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *organizationPager) applyOrder(query *OrganizationQuery, reverse bool) *OrganizationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultOrganizationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultOrganizationOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts)
	if err != nil {
		return nil, err
	}

	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}

	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := o.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := o.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	o = pager.applyCursors(o, after, before)
	o = pager.applyOrder(o, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		o = o.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		o = o.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := o.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}

	conn.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	field    string
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: OrderDirectionAsc,
	Field: &OrganizationOrderField{
		field: organization.FieldID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (o *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// ProjectEdge is the edge representation of Project.
type ProjectEdge struct {
	Node   *Project `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProjectConnection is the connection containing edges to Project.
type ProjectConnection struct {
	Edges      []*ProjectEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ProjectPaginateOption enables pagination customization.
type ProjectPaginateOption func(*projectPager) error

// WithProjectOrder configures pagination ordering.
func WithProjectOrder(order *ProjectOrder) ProjectPaginateOption {
	if order == nil {
		order = DefaultProjectOrder
	}
	o := *order
	return func(pager *projectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProjectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProjectFilter configures pagination filter.
func WithProjectFilter(filter func(*ProjectQuery) (*ProjectQuery, error)) ProjectPaginateOption {
	return func(pager *projectPager) error {
		if filter == nil {
			return errors.New("ProjectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type projectPager struct {
	order  *ProjectOrder
	filter func(*ProjectQuery) (*ProjectQuery, error)
}

func newProjectPager(opts []ProjectPaginateOption) (*projectPager, error) {
	pager := &projectPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProjectOrder
	}
	return pager, nil
}

func (p *projectPager) applyFilter(query *ProjectQuery) (*ProjectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *projectPager) toCursor(pr *Project) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *projectPager) applyCursors(query *ProjectQuery, after, before *Cursor) *ProjectQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProjectOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *projectPager) applyOrder(query *ProjectQuery, reverse bool) *ProjectQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProjectOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProjectOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Project.
func (pr *ProjectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProjectPaginateOption,
) (*ProjectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProjectPager(opts)
	if err != nil {
		return nil, err
	}

	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}

	conn := &ProjectConnection{Edges: []*ProjectEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pr = pr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Project
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Project {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Project {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProjectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProjectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ProjectOrderFieldName orders Project by name.
	ProjectOrderFieldName = &ProjectOrderField{
		field: project.FieldName,
		toCursor: func(pr *Project) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProjectOrderField) String() string {
	var str string
	switch f.field {
	case project.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProjectOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProjectOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProjectOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ProjectOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ProjectOrderField", str)
	}
	return nil
}

// ProjectOrderField defines the ordering field of Project.
type ProjectOrderField struct {
	field    string
	toCursor func(*Project) Cursor
}

// ProjectOrder defines the ordering of Project.
type ProjectOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProjectOrderField `json:"field"`
}

// DefaultProjectOrder is the default ordering of Project.
var DefaultProjectOrder = &ProjectOrder{
	Direction: OrderDirectionAsc,
	Field: &ProjectOrderField{
		field: project.FieldID,
		toCursor: func(pr *Project) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Project into ProjectEdge.
func (pr *Project) ToEdge(order *ProjectOrder) *ProjectEdge {
	if order == nil {
		order = DefaultProjectOrder
	}
	return &ProjectEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ReleaseEdge is the edge representation of Release.
type ReleaseEdge struct {
	Node   *Release `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ReleaseConnection is the connection containing edges to Release.
type ReleaseConnection struct {
	Edges      []*ReleaseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ReleasePaginateOption enables pagination customization.
type ReleasePaginateOption func(*releasePager) error

// WithReleaseOrder configures pagination ordering.
func WithReleaseOrder(order *ReleaseOrder) ReleasePaginateOption {
	if order == nil {
		order = DefaultReleaseOrder
	}
	o := *order
	return func(pager *releasePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseFilter configures pagination filter.
func WithReleaseFilter(filter func(*ReleaseQuery) (*ReleaseQuery, error)) ReleasePaginateOption {
	return func(pager *releasePager) error {
		if filter == nil {
			return errors.New("ReleaseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releasePager struct {
	order  *ReleaseOrder
	filter func(*ReleaseQuery) (*ReleaseQuery, error)
}

func newReleasePager(opts []ReleasePaginateOption) (*releasePager, error) {
	pager := &releasePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseOrder
	}
	return pager, nil
}

func (p *releasePager) applyFilter(query *ReleaseQuery) (*ReleaseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releasePager) toCursor(r *Release) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *releasePager) applyCursors(query *ReleaseQuery, after, before *Cursor) *ReleaseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releasePager) applyOrder(query *ReleaseQuery, reverse bool) *ReleaseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Release.
func (r *ReleaseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleasePaginateOption,
) (*ReleaseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleasePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &ReleaseConnection{Edges: []*ReleaseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Release
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Release {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Release {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ReleaseOrderFieldName orders Release by name.
	ReleaseOrderFieldName = &ReleaseOrderField{
		field: release.FieldName,
		toCursor: func(r *Release) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Name,
			}
		},
	}
	// ReleaseOrderFieldVersion orders Release by version.
	ReleaseOrderFieldVersion = &ReleaseOrderField{
		field: release.FieldVersion,
		toCursor: func(r *Release) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Version,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReleaseOrderField) String() string {
	var str string
	switch f.field {
	case release.FieldName:
		str = "name"
	case release.FieldVersion:
		str = "version"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReleaseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReleaseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReleaseOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ReleaseOrderFieldName
	case "version":
		*f = *ReleaseOrderFieldVersion
	default:
		return fmt.Errorf("%s is not a valid ReleaseOrderField", str)
	}
	return nil
}

// ReleaseOrderField defines the ordering field of Release.
type ReleaseOrderField struct {
	field    string
	toCursor func(*Release) Cursor
}

// ReleaseOrder defines the ordering of Release.
type ReleaseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ReleaseOrderField `json:"field"`
}

// DefaultReleaseOrder is the default ordering of Release.
var DefaultReleaseOrder = &ReleaseOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseOrderField{
		field: release.FieldID,
		toCursor: func(r *Release) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Release into ReleaseEdge.
func (r *Release) ToEdge(order *ReleaseOrder) *ReleaseEdge {
	if order == nil {
		order = DefaultReleaseOrder
	}
	return &ReleaseEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// ReleaseComponentEdge is the edge representation of ReleaseComponent.
type ReleaseComponentEdge struct {
	Node   *ReleaseComponent `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ReleaseComponentConnection is the connection containing edges to ReleaseComponent.
type ReleaseComponentConnection struct {
	Edges      []*ReleaseComponentEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// ReleaseComponentPaginateOption enables pagination customization.
type ReleaseComponentPaginateOption func(*releaseComponentPager) error

// WithReleaseComponentOrder configures pagination ordering.
func WithReleaseComponentOrder(order *ReleaseComponentOrder) ReleaseComponentPaginateOption {
	if order == nil {
		order = DefaultReleaseComponentOrder
	}
	o := *order
	return func(pager *releaseComponentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseComponentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseComponentFilter configures pagination filter.
func WithReleaseComponentFilter(filter func(*ReleaseComponentQuery) (*ReleaseComponentQuery, error)) ReleaseComponentPaginateOption {
	return func(pager *releaseComponentPager) error {
		if filter == nil {
			return errors.New("ReleaseComponentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releaseComponentPager struct {
	order  *ReleaseComponentOrder
	filter func(*ReleaseComponentQuery) (*ReleaseComponentQuery, error)
}

func newReleaseComponentPager(opts []ReleaseComponentPaginateOption) (*releaseComponentPager, error) {
	pager := &releaseComponentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseComponentOrder
	}
	return pager, nil
}

func (p *releaseComponentPager) applyFilter(query *ReleaseComponentQuery) (*ReleaseComponentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releaseComponentPager) toCursor(rc *ReleaseComponent) Cursor {
	return p.order.Field.toCursor(rc)
}

func (p *releaseComponentPager) applyCursors(query *ReleaseComponentQuery, after, before *Cursor) *ReleaseComponentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseComponentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releaseComponentPager) applyOrder(query *ReleaseComponentQuery, reverse bool) *ReleaseComponentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseComponentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseComponentOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReleaseComponent.
func (rc *ReleaseComponentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleaseComponentPaginateOption,
) (*ReleaseComponentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleaseComponentPager(opts)
	if err != nil {
		return nil, err
	}

	if rc, err = pager.applyFilter(rc); err != nil {
		return nil, err
	}

	conn := &ReleaseComponentConnection{Edges: []*ReleaseComponentEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := rc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rc = pager.applyCursors(rc, after, before)
	rc = pager.applyOrder(rc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rc = rc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rc = rc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReleaseComponent
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReleaseComponent {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReleaseComponent {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseComponentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseComponentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ReleaseComponentOrderField defines the ordering field of ReleaseComponent.
type ReleaseComponentOrderField struct {
	field    string
	toCursor func(*ReleaseComponent) Cursor
}

// ReleaseComponentOrder defines the ordering of ReleaseComponent.
type ReleaseComponentOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ReleaseComponentOrderField `json:"field"`
}

// DefaultReleaseComponentOrder is the default ordering of ReleaseComponent.
var DefaultReleaseComponentOrder = &ReleaseComponentOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseComponentOrderField{
		field: releasecomponent.FieldID,
		toCursor: func(rc *ReleaseComponent) Cursor {
			return Cursor{ID: rc.ID}
		},
	},
}

// ToEdge converts ReleaseComponent into ReleaseComponentEdge.
func (rc *ReleaseComponent) ToEdge(order *ReleaseComponentOrder) *ReleaseComponentEdge {
	if order == nil {
		order = DefaultReleaseComponentOrder
	}
	return &ReleaseComponentEdge{
		Node:   rc,
		Cursor: order.Field.toCursor(rc),
	}
}

// ReleaseEntryEdge is the edge representation of ReleaseEntry.
type ReleaseEntryEdge struct {
	Node   *ReleaseEntry `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ReleaseEntryConnection is the connection containing edges to ReleaseEntry.
type ReleaseEntryConnection struct {
	Edges      []*ReleaseEntryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// ReleaseEntryPaginateOption enables pagination customization.
type ReleaseEntryPaginateOption func(*releaseEntryPager) error

// WithReleaseEntryOrder configures pagination ordering.
func WithReleaseEntryOrder(order *ReleaseEntryOrder) ReleaseEntryPaginateOption {
	if order == nil {
		order = DefaultReleaseEntryOrder
	}
	o := *order
	return func(pager *releaseEntryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseEntryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseEntryFilter configures pagination filter.
func WithReleaseEntryFilter(filter func(*ReleaseEntryQuery) (*ReleaseEntryQuery, error)) ReleaseEntryPaginateOption {
	return func(pager *releaseEntryPager) error {
		if filter == nil {
			return errors.New("ReleaseEntryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releaseEntryPager struct {
	order  *ReleaseEntryOrder
	filter func(*ReleaseEntryQuery) (*ReleaseEntryQuery, error)
}

func newReleaseEntryPager(opts []ReleaseEntryPaginateOption) (*releaseEntryPager, error) {
	pager := &releaseEntryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseEntryOrder
	}
	return pager, nil
}

func (p *releaseEntryPager) applyFilter(query *ReleaseEntryQuery) (*ReleaseEntryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releaseEntryPager) toCursor(re *ReleaseEntry) Cursor {
	return p.order.Field.toCursor(re)
}

func (p *releaseEntryPager) applyCursors(query *ReleaseEntryQuery, after, before *Cursor) *ReleaseEntryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseEntryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releaseEntryPager) applyOrder(query *ReleaseEntryQuery, reverse bool) *ReleaseEntryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseEntryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseEntryOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReleaseEntry.
func (re *ReleaseEntryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleaseEntryPaginateOption,
) (*ReleaseEntryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleaseEntryPager(opts)
	if err != nil {
		return nil, err
	}

	if re, err = pager.applyFilter(re); err != nil {
		return nil, err
	}

	conn := &ReleaseEntryConnection{Edges: []*ReleaseEntryEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := re.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := re.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	re = pager.applyCursors(re, after, before)
	re = pager.applyOrder(re, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		re = re.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		re = re.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := re.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReleaseEntry
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReleaseEntry {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReleaseEntry {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseEntryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseEntryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ReleaseEntryOrderFieldType orders ReleaseEntry by type.
	ReleaseEntryOrderFieldType = &ReleaseEntryOrderField{
		field: releaseentry.FieldType,
		toCursor: func(re *ReleaseEntry) Cursor {
			return Cursor{
				ID:    re.ID,
				Value: re.Type,
			}
		},
	}
	// ReleaseEntryOrderFieldTime orders ReleaseEntry by time.
	ReleaseEntryOrderFieldTime = &ReleaseEntryOrderField{
		field: releaseentry.FieldTime,
		toCursor: func(re *ReleaseEntry) Cursor {
			return Cursor{
				ID:    re.ID,
				Value: re.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReleaseEntryOrderField) String() string {
	var str string
	switch f.field {
	case releaseentry.FieldType:
		str = "type"
	case releaseentry.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReleaseEntryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReleaseEntryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReleaseEntryOrderField %T must be a string", v)
	}
	switch str {
	case "type":
		*f = *ReleaseEntryOrderFieldType
	case "time":
		*f = *ReleaseEntryOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid ReleaseEntryOrderField", str)
	}
	return nil
}

// ReleaseEntryOrderField defines the ordering field of ReleaseEntry.
type ReleaseEntryOrderField struct {
	field    string
	toCursor func(*ReleaseEntry) Cursor
}

// ReleaseEntryOrder defines the ordering of ReleaseEntry.
type ReleaseEntryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ReleaseEntryOrderField `json:"field"`
}

// DefaultReleaseEntryOrder is the default ordering of ReleaseEntry.
var DefaultReleaseEntryOrder = &ReleaseEntryOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseEntryOrderField{
		field: releaseentry.FieldID,
		toCursor: func(re *ReleaseEntry) Cursor {
			return Cursor{ID: re.ID}
		},
	},
}

// ToEdge converts ReleaseEntry into ReleaseEntryEdge.
func (re *ReleaseEntry) ToEdge(order *ReleaseEntryOrder) *ReleaseEntryEdge {
	if order == nil {
		order = DefaultReleaseEntryOrder
	}
	return &ReleaseEntryEdge{
		Node:   re,
		Cursor: order.Field.toCursor(re),
	}
}

// ReleaseLicenseEdge is the edge representation of ReleaseLicense.
type ReleaseLicenseEdge struct {
	Node   *ReleaseLicense `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ReleaseLicenseConnection is the connection containing edges to ReleaseLicense.
type ReleaseLicenseConnection struct {
	Edges      []*ReleaseLicenseEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// ReleaseLicensePaginateOption enables pagination customization.
type ReleaseLicensePaginateOption func(*releaseLicensePager) error

// WithReleaseLicenseOrder configures pagination ordering.
func WithReleaseLicenseOrder(order *ReleaseLicenseOrder) ReleaseLicensePaginateOption {
	if order == nil {
		order = DefaultReleaseLicenseOrder
	}
	o := *order
	return func(pager *releaseLicensePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseLicenseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseLicenseFilter configures pagination filter.
func WithReleaseLicenseFilter(filter func(*ReleaseLicenseQuery) (*ReleaseLicenseQuery, error)) ReleaseLicensePaginateOption {
	return func(pager *releaseLicensePager) error {
		if filter == nil {
			return errors.New("ReleaseLicenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releaseLicensePager struct {
	order  *ReleaseLicenseOrder
	filter func(*ReleaseLicenseQuery) (*ReleaseLicenseQuery, error)
}

func newReleaseLicensePager(opts []ReleaseLicensePaginateOption) (*releaseLicensePager, error) {
	pager := &releaseLicensePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseLicenseOrder
	}
	return pager, nil
}

func (p *releaseLicensePager) applyFilter(query *ReleaseLicenseQuery) (*ReleaseLicenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releaseLicensePager) toCursor(rl *ReleaseLicense) Cursor {
	return p.order.Field.toCursor(rl)
}

func (p *releaseLicensePager) applyCursors(query *ReleaseLicenseQuery, after, before *Cursor) *ReleaseLicenseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseLicenseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releaseLicensePager) applyOrder(query *ReleaseLicenseQuery, reverse bool) *ReleaseLicenseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseLicenseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseLicenseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReleaseLicense.
func (rl *ReleaseLicenseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleaseLicensePaginateOption,
) (*ReleaseLicenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleaseLicensePager(opts)
	if err != nil {
		return nil, err
	}

	if rl, err = pager.applyFilter(rl); err != nil {
		return nil, err
	}

	conn := &ReleaseLicenseConnection{Edges: []*ReleaseLicenseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := rl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rl = pager.applyCursors(rl, after, before)
	rl = pager.applyOrder(rl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rl = rl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rl = rl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReleaseLicense
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReleaseLicense {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReleaseLicense {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseLicenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseLicenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ReleaseLicenseOrderField defines the ordering field of ReleaseLicense.
type ReleaseLicenseOrderField struct {
	field    string
	toCursor func(*ReleaseLicense) Cursor
}

// ReleaseLicenseOrder defines the ordering of ReleaseLicense.
type ReleaseLicenseOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ReleaseLicenseOrderField `json:"field"`
}

// DefaultReleaseLicenseOrder is the default ordering of ReleaseLicense.
var DefaultReleaseLicenseOrder = &ReleaseLicenseOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseLicenseOrderField{
		field: releaselicense.FieldID,
		toCursor: func(rl *ReleaseLicense) Cursor {
			return Cursor{ID: rl.ID}
		},
	},
}

// ToEdge converts ReleaseLicense into ReleaseLicenseEdge.
func (rl *ReleaseLicense) ToEdge(order *ReleaseLicenseOrder) *ReleaseLicenseEdge {
	if order == nil {
		order = DefaultReleaseLicenseOrder
	}
	return &ReleaseLicenseEdge{
		Node:   rl,
		Cursor: order.Field.toCursor(rl),
	}
}

// ReleasePolicyEdge is the edge representation of ReleasePolicy.
type ReleasePolicyEdge struct {
	Node   *ReleasePolicy `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ReleasePolicyConnection is the connection containing edges to ReleasePolicy.
type ReleasePolicyConnection struct {
	Edges      []*ReleasePolicyEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// ReleasePolicyPaginateOption enables pagination customization.
type ReleasePolicyPaginateOption func(*releasePolicyPager) error

// WithReleasePolicyOrder configures pagination ordering.
func WithReleasePolicyOrder(order *ReleasePolicyOrder) ReleasePolicyPaginateOption {
	if order == nil {
		order = DefaultReleasePolicyOrder
	}
	o := *order
	return func(pager *releasePolicyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleasePolicyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleasePolicyFilter configures pagination filter.
func WithReleasePolicyFilter(filter func(*ReleasePolicyQuery) (*ReleasePolicyQuery, error)) ReleasePolicyPaginateOption {
	return func(pager *releasePolicyPager) error {
		if filter == nil {
			return errors.New("ReleasePolicyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releasePolicyPager struct {
	order  *ReleasePolicyOrder
	filter func(*ReleasePolicyQuery) (*ReleasePolicyQuery, error)
}

func newReleasePolicyPager(opts []ReleasePolicyPaginateOption) (*releasePolicyPager, error) {
	pager := &releasePolicyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleasePolicyOrder
	}
	return pager, nil
}

func (p *releasePolicyPager) applyFilter(query *ReleasePolicyQuery) (*ReleasePolicyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releasePolicyPager) toCursor(rp *ReleasePolicy) Cursor {
	return p.order.Field.toCursor(rp)
}

func (p *releasePolicyPager) applyCursors(query *ReleasePolicyQuery, after, before *Cursor) *ReleasePolicyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleasePolicyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releasePolicyPager) applyOrder(query *ReleasePolicyQuery, reverse bool) *ReleasePolicyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleasePolicyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleasePolicyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReleasePolicy.
func (rp *ReleasePolicyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleasePolicyPaginateOption,
) (*ReleasePolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleasePolicyPager(opts)
	if err != nil {
		return nil, err
	}

	if rp, err = pager.applyFilter(rp); err != nil {
		return nil, err
	}

	conn := &ReleasePolicyConnection{Edges: []*ReleasePolicyEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rp.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := rp.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rp = pager.applyCursors(rp, after, before)
	rp = pager.applyOrder(rp, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rp = rp.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rp = rp.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rp.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReleasePolicy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReleasePolicy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReleasePolicy {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleasePolicyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleasePolicyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ReleasePolicyOrderFieldName orders ReleasePolicy by name.
	ReleasePolicyOrderFieldName = &ReleasePolicyOrderField{
		field: releasepolicy.FieldName,
		toCursor: func(rp *ReleasePolicy) Cursor {
			return Cursor{
				ID:    rp.ID,
				Value: rp.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReleasePolicyOrderField) String() string {
	var str string
	switch f.field {
	case releasepolicy.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReleasePolicyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReleasePolicyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReleasePolicyOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *ReleasePolicyOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ReleasePolicyOrderField", str)
	}
	return nil
}

// ReleasePolicyOrderField defines the ordering field of ReleasePolicy.
type ReleasePolicyOrderField struct {
	field    string
	toCursor func(*ReleasePolicy) Cursor
}

// ReleasePolicyOrder defines the ordering of ReleasePolicy.
type ReleasePolicyOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ReleasePolicyOrderField `json:"field"`
}

// DefaultReleasePolicyOrder is the default ordering of ReleasePolicy.
var DefaultReleasePolicyOrder = &ReleasePolicyOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleasePolicyOrderField{
		field: releasepolicy.FieldID,
		toCursor: func(rp *ReleasePolicy) Cursor {
			return Cursor{ID: rp.ID}
		},
	},
}

// ToEdge converts ReleasePolicy into ReleasePolicyEdge.
func (rp *ReleasePolicy) ToEdge(order *ReleasePolicyOrder) *ReleasePolicyEdge {
	if order == nil {
		order = DefaultReleasePolicyOrder
	}
	return &ReleasePolicyEdge{
		Node:   rp,
		Cursor: order.Field.toCursor(rp),
	}
}

// ReleasePolicyViolationEdge is the edge representation of ReleasePolicyViolation.
type ReleasePolicyViolationEdge struct {
	Node   *ReleasePolicyViolation `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// ReleasePolicyViolationConnection is the connection containing edges to ReleasePolicyViolation.
type ReleasePolicyViolationConnection struct {
	Edges      []*ReleasePolicyViolationEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

// ReleasePolicyViolationPaginateOption enables pagination customization.
type ReleasePolicyViolationPaginateOption func(*releasePolicyViolationPager) error

// WithReleasePolicyViolationOrder configures pagination ordering.
func WithReleasePolicyViolationOrder(order *ReleasePolicyViolationOrder) ReleasePolicyViolationPaginateOption {
	if order == nil {
		order = DefaultReleasePolicyViolationOrder
	}
	o := *order
	return func(pager *releasePolicyViolationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleasePolicyViolationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleasePolicyViolationFilter configures pagination filter.
func WithReleasePolicyViolationFilter(filter func(*ReleasePolicyViolationQuery) (*ReleasePolicyViolationQuery, error)) ReleasePolicyViolationPaginateOption {
	return func(pager *releasePolicyViolationPager) error {
		if filter == nil {
			return errors.New("ReleasePolicyViolationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releasePolicyViolationPager struct {
	order  *ReleasePolicyViolationOrder
	filter func(*ReleasePolicyViolationQuery) (*ReleasePolicyViolationQuery, error)
}

func newReleasePolicyViolationPager(opts []ReleasePolicyViolationPaginateOption) (*releasePolicyViolationPager, error) {
	pager := &releasePolicyViolationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleasePolicyViolationOrder
	}
	return pager, nil
}

func (p *releasePolicyViolationPager) applyFilter(query *ReleasePolicyViolationQuery) (*ReleasePolicyViolationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releasePolicyViolationPager) toCursor(rpv *ReleasePolicyViolation) Cursor {
	return p.order.Field.toCursor(rpv)
}

func (p *releasePolicyViolationPager) applyCursors(query *ReleasePolicyViolationQuery, after, before *Cursor) *ReleasePolicyViolationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleasePolicyViolationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releasePolicyViolationPager) applyOrder(query *ReleasePolicyViolationQuery, reverse bool) *ReleasePolicyViolationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleasePolicyViolationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleasePolicyViolationOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReleasePolicyViolation.
func (rpv *ReleasePolicyViolationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleasePolicyViolationPaginateOption,
) (*ReleasePolicyViolationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleasePolicyViolationPager(opts)
	if err != nil {
		return nil, err
	}

	if rpv, err = pager.applyFilter(rpv); err != nil {
		return nil, err
	}

	conn := &ReleasePolicyViolationConnection{Edges: []*ReleasePolicyViolationEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rpv.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := rpv.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rpv = pager.applyCursors(rpv, after, before)
	rpv = pager.applyOrder(rpv, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rpv = rpv.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rpv = rpv.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rpv.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReleasePolicyViolation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReleasePolicyViolation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReleasePolicyViolation {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleasePolicyViolationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleasePolicyViolationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ReleasePolicyViolationOrderField defines the ordering field of ReleasePolicyViolation.
type ReleasePolicyViolationOrderField struct {
	field    string
	toCursor func(*ReleasePolicyViolation) Cursor
}

// ReleasePolicyViolationOrder defines the ordering of ReleasePolicyViolation.
type ReleasePolicyViolationOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *ReleasePolicyViolationOrderField `json:"field"`
}

// DefaultReleasePolicyViolationOrder is the default ordering of ReleasePolicyViolation.
var DefaultReleasePolicyViolationOrder = &ReleasePolicyViolationOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleasePolicyViolationOrderField{
		field: releasepolicyviolation.FieldID,
		toCursor: func(rpv *ReleasePolicyViolation) Cursor {
			return Cursor{ID: rpv.ID}
		},
	},
}

// ToEdge converts ReleasePolicyViolation into ReleasePolicyViolationEdge.
func (rpv *ReleasePolicyViolation) ToEdge(order *ReleasePolicyViolationOrder) *ReleasePolicyViolationEdge {
	if order == nil {
		order = DefaultReleasePolicyViolationOrder
	}
	return &ReleasePolicyViolationEdge{
		Node:   rpv,
		Cursor: order.Field.toCursor(rpv),
	}
}

// ReleaseVulnerabilityEdge is the edge representation of ReleaseVulnerability.
type ReleaseVulnerabilityEdge struct {
	Node   *ReleaseVulnerability `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// ReleaseVulnerabilityConnection is the connection containing edges to ReleaseVulnerability.
type ReleaseVulnerabilityConnection struct {
	Edges      []*ReleaseVulnerabilityEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

// ReleaseVulnerabilityPaginateOption enables pagination customization.
type ReleaseVulnerabilityPaginateOption func(*releaseVulnerabilityPager) error

// WithReleaseVulnerabilityOrder configures pagination ordering.
func WithReleaseVulnerabilityOrder(order *ReleaseVulnerabilityOrder) ReleaseVulnerabilityPaginateOption {
	if order == nil {
		order = DefaultReleaseVulnerabilityOrder
	}
	o := *order
	return func(pager *releaseVulnerabilityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseVulnerabilityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseVulnerabilityFilter configures pagination filter.
func WithReleaseVulnerabilityFilter(filter func(*ReleaseVulnerabilityQuery) (*ReleaseVulnerabilityQuery, error)) ReleaseVulnerabilityPaginateOption {
	return func(pager *releaseVulnerabilityPager) error {
		if filter == nil {
			return errors.New("ReleaseVulnerabilityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releaseVulnerabilityPager struct {
	order  *ReleaseVulnerabilityOrder
	filter func(*ReleaseVulnerabilityQuery) (*ReleaseVulnerabilityQuery, error)
}

func newReleaseVulnerabilityPager(opts []ReleaseVulnerabilityPaginateOption) (*releaseVulnerabilityPager, error) {
	pager := &releaseVulnerabilityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseVulnerabilityOrder
	}
	return pager, nil
}

func (p *releaseVulnerabilityPager) applyFilter(query *ReleaseVulnerabilityQuery) (*ReleaseVulnerabilityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releaseVulnerabilityPager) toCursor(rv *ReleaseVulnerability) Cursor {
	return p.order.Field.toCursor(rv)
}

func (p *releaseVulnerabilityPager) applyCursors(query *ReleaseVulnerabilityQuery, after, before *Cursor) *ReleaseVulnerabilityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseVulnerabilityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releaseVulnerabilityPager) applyOrder(query *ReleaseVulnerabilityQuery, reverse bool) *ReleaseVulnerabilityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseVulnerabilityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseVulnerabilityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ReleaseVulnerability.
func (rv *ReleaseVulnerabilityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleaseVulnerabilityPaginateOption,
) (*ReleaseVulnerabilityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleaseVulnerabilityPager(opts)
	if err != nil {
		return nil, err
	}

	if rv, err = pager.applyFilter(rv); err != nil {
		return nil, err
	}

	conn := &ReleaseVulnerabilityConnection{Edges: []*ReleaseVulnerabilityEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := rv.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := rv.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	rv = pager.applyCursors(rv, after, before)
	rv = pager.applyOrder(rv, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		rv = rv.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		rv = rv.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := rv.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ReleaseVulnerability
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReleaseVulnerability {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReleaseVulnerability {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseVulnerabilityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseVulnerabilityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ReleaseVulnerabilityOrderField defines the ordering field of ReleaseVulnerability.
type ReleaseVulnerabilityOrderField struct {
	field    string
	toCursor func(*ReleaseVulnerability) Cursor
}

// ReleaseVulnerabilityOrder defines the ordering of ReleaseVulnerability.
type ReleaseVulnerabilityOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *ReleaseVulnerabilityOrderField `json:"field"`
}

// DefaultReleaseVulnerabilityOrder is the default ordering of ReleaseVulnerability.
var DefaultReleaseVulnerabilityOrder = &ReleaseVulnerabilityOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseVulnerabilityOrderField{
		field: releasevulnerability.FieldID,
		toCursor: func(rv *ReleaseVulnerability) Cursor {
			return Cursor{ID: rv.ID}
		},
	},
}

// ToEdge converts ReleaseVulnerability into ReleaseVulnerabilityEdge.
func (rv *ReleaseVulnerability) ToEdge(order *ReleaseVulnerabilityOrder) *ReleaseVulnerabilityEdge {
	if order == nil {
		order = DefaultReleaseVulnerabilityOrder
	}
	return &ReleaseVulnerabilityEdge{
		Node:   rv,
		Cursor: order.Field.toCursor(rv),
	}
}

// RepoEdge is the edge representation of Repo.
type RepoEdge struct {
	Node   *Repo  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RepoConnection is the connection containing edges to Repo.
type RepoConnection struct {
	Edges      []*RepoEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// RepoPaginateOption enables pagination customization.
type RepoPaginateOption func(*repoPager) error

// WithRepoOrder configures pagination ordering.
func WithRepoOrder(order *RepoOrder) RepoPaginateOption {
	if order == nil {
		order = DefaultRepoOrder
	}
	o := *order
	return func(pager *repoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRepoOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRepoFilter configures pagination filter.
func WithRepoFilter(filter func(*RepoQuery) (*RepoQuery, error)) RepoPaginateOption {
	return func(pager *repoPager) error {
		if filter == nil {
			return errors.New("RepoQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type repoPager struct {
	order  *RepoOrder
	filter func(*RepoQuery) (*RepoQuery, error)
}

func newRepoPager(opts []RepoPaginateOption) (*repoPager, error) {
	pager := &repoPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRepoOrder
	}
	return pager, nil
}

func (p *repoPager) applyFilter(query *RepoQuery) (*RepoQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *repoPager) toCursor(r *Repo) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *repoPager) applyCursors(query *RepoQuery, after, before *Cursor) *RepoQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRepoOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *repoPager) applyOrder(query *RepoQuery, reverse bool) *RepoQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRepoOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRepoOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Repo.
func (r *RepoQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RepoPaginateOption,
) (*RepoConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRepoPager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RepoConnection{Edges: []*RepoEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Repo
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Repo {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Repo {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RepoEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RepoEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RepoOrderFieldName orders Repo by name.
	RepoOrderFieldName = &RepoOrderField{
		field: repo.FieldName,
		toCursor: func(r *Repo) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RepoOrderField) String() string {
	var str string
	switch f.field {
	case repo.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RepoOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RepoOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RepoOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *RepoOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid RepoOrderField", str)
	}
	return nil
}

// RepoOrderField defines the ordering field of Repo.
type RepoOrderField struct {
	field    string
	toCursor func(*Repo) Cursor
}

// RepoOrder defines the ordering of Repo.
type RepoOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RepoOrderField `json:"field"`
}

// DefaultRepoOrder is the default ordering of Repo.
var DefaultRepoOrder = &RepoOrder{
	Direction: OrderDirectionAsc,
	Field: &RepoOrderField{
		field: repo.FieldID,
		toCursor: func(r *Repo) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Repo into RepoEdge.
func (r *Repo) ToEdge(order *RepoOrder) *RepoEdge {
	if order == nil {
		order = DefaultRepoOrder
	}
	return &RepoEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// TestCaseEdge is the edge representation of TestCase.
type TestCaseEdge struct {
	Node   *TestCase `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// TestCaseConnection is the connection containing edges to TestCase.
type TestCaseConnection struct {
	Edges      []*TestCaseEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// TestCasePaginateOption enables pagination customization.
type TestCasePaginateOption func(*testCasePager) error

// WithTestCaseOrder configures pagination ordering.
func WithTestCaseOrder(order *TestCaseOrder) TestCasePaginateOption {
	if order == nil {
		order = DefaultTestCaseOrder
	}
	o := *order
	return func(pager *testCasePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTestCaseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTestCaseFilter configures pagination filter.
func WithTestCaseFilter(filter func(*TestCaseQuery) (*TestCaseQuery, error)) TestCasePaginateOption {
	return func(pager *testCasePager) error {
		if filter == nil {
			return errors.New("TestCaseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type testCasePager struct {
	order  *TestCaseOrder
	filter func(*TestCaseQuery) (*TestCaseQuery, error)
}

func newTestCasePager(opts []TestCasePaginateOption) (*testCasePager, error) {
	pager := &testCasePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTestCaseOrder
	}
	return pager, nil
}

func (p *testCasePager) applyFilter(query *TestCaseQuery) (*TestCaseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *testCasePager) toCursor(tc *TestCase) Cursor {
	return p.order.Field.toCursor(tc)
}

func (p *testCasePager) applyCursors(query *TestCaseQuery, after, before *Cursor) *TestCaseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTestCaseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *testCasePager) applyOrder(query *TestCaseQuery, reverse bool) *TestCaseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTestCaseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTestCaseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to TestCase.
func (tc *TestCaseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TestCasePaginateOption,
) (*TestCaseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTestCasePager(opts)
	if err != nil {
		return nil, err
	}

	if tc, err = pager.applyFilter(tc); err != nil {
		return nil, err
	}

	conn := &TestCaseConnection{Edges: []*TestCaseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := tc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := tc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	tc = pager.applyCursors(tc, after, before)
	tc = pager.applyOrder(tc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		tc = tc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		tc = tc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := tc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *TestCase
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TestCase {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TestCase {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TestCaseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TestCaseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TestCaseOrderFieldName orders TestCase by name.
	TestCaseOrderFieldName = &TestCaseOrderField{
		field: testcase.FieldName,
		toCursor: func(tc *TestCase) Cursor {
			return Cursor{
				ID:    tc.ID,
				Value: tc.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TestCaseOrderField) String() string {
	var str string
	switch f.field {
	case testcase.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TestCaseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TestCaseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TestCaseOrderField %T must be a string", v)
	}
	switch str {
	case "name":
		*f = *TestCaseOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TestCaseOrderField", str)
	}
	return nil
}

// TestCaseOrderField defines the ordering field of TestCase.
type TestCaseOrderField struct {
	field    string
	toCursor func(*TestCase) Cursor
}

// TestCaseOrder defines the ordering of TestCase.
type TestCaseOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *TestCaseOrderField `json:"field"`
}

// DefaultTestCaseOrder is the default ordering of TestCase.
var DefaultTestCaseOrder = &TestCaseOrder{
	Direction: OrderDirectionAsc,
	Field: &TestCaseOrderField{
		field: testcase.FieldID,
		toCursor: func(tc *TestCase) Cursor {
			return Cursor{ID: tc.ID}
		},
	},
}

// ToEdge converts TestCase into TestCaseEdge.
func (tc *TestCase) ToEdge(order *TestCaseOrder) *TestCaseEdge {
	if order == nil {
		order = DefaultTestCaseOrder
	}
	return &TestCaseEdge{
		Node:   tc,
		Cursor: order.Field.toCursor(tc),
	}
}

// TestRunEdge is the edge representation of TestRun.
type TestRunEdge struct {
	Node   *TestRun `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// TestRunConnection is the connection containing edges to TestRun.
type TestRunConnection struct {
	Edges      []*TestRunEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// TestRunPaginateOption enables pagination customization.
type TestRunPaginateOption func(*testRunPager) error

// WithTestRunOrder configures pagination ordering.
func WithTestRunOrder(order *TestRunOrder) TestRunPaginateOption {
	if order == nil {
		order = DefaultTestRunOrder
	}
	o := *order
	return func(pager *testRunPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTestRunOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTestRunFilter configures pagination filter.
func WithTestRunFilter(filter func(*TestRunQuery) (*TestRunQuery, error)) TestRunPaginateOption {
	return func(pager *testRunPager) error {
		if filter == nil {
			return errors.New("TestRunQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type testRunPager struct {
	order  *TestRunOrder
	filter func(*TestRunQuery) (*TestRunQuery, error)
}

func newTestRunPager(opts []TestRunPaginateOption) (*testRunPager, error) {
	pager := &testRunPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTestRunOrder
	}
	return pager, nil
}

func (p *testRunPager) applyFilter(query *TestRunQuery) (*TestRunQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *testRunPager) toCursor(tr *TestRun) Cursor {
	return p.order.Field.toCursor(tr)
}

func (p *testRunPager) applyCursors(query *TestRunQuery, after, before *Cursor) *TestRunQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTestRunOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *testRunPager) applyOrder(query *TestRunQuery, reverse bool) *TestRunQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTestRunOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTestRunOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to TestRun.
func (tr *TestRunQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TestRunPaginateOption,
) (*TestRunConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTestRunPager(opts)
	if err != nil {
		return nil, err
	}

	if tr, err = pager.applyFilter(tr); err != nil {
		return nil, err
	}

	conn := &TestRunConnection{Edges: []*TestRunEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := tr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := tr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	tr = pager.applyCursors(tr, after, before)
	tr = pager.applyOrder(tr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		tr = tr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		tr = tr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := tr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *TestRun
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TestRun {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TestRun {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TestRunEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TestRunEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// TestRunOrderFieldTool orders TestRun by tool.
	TestRunOrderFieldTool = &TestRunOrderField{
		field: testrun.FieldTool,
		toCursor: func(tr *TestRun) Cursor {
			return Cursor{
				ID:    tr.ID,
				Value: tr.Tool,
			}
		},
	}
	// TestRunOrderFieldTime orders TestRun by time.
	TestRunOrderFieldTime = &TestRunOrderField{
		field: testrun.FieldTime,
		toCursor: func(tr *TestRun) Cursor {
			return Cursor{
				ID:    tr.ID,
				Value: tr.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TestRunOrderField) String() string {
	var str string
	switch f.field {
	case testrun.FieldTool:
		str = "tool"
	case testrun.FieldTime:
		str = "time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TestRunOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TestRunOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TestRunOrderField %T must be a string", v)
	}
	switch str {
	case "tool":
		*f = *TestRunOrderFieldTool
	case "time":
		*f = *TestRunOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid TestRunOrderField", str)
	}
	return nil
}

// TestRunOrderField defines the ordering field of TestRun.
type TestRunOrderField struct {
	field    string
	toCursor func(*TestRun) Cursor
}

// TestRunOrder defines the ordering of TestRun.
type TestRunOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *TestRunOrderField `json:"field"`
}

// DefaultTestRunOrder is the default ordering of TestRun.
var DefaultTestRunOrder = &TestRunOrder{
	Direction: OrderDirectionAsc,
	Field: &TestRunOrderField{
		field: testrun.FieldID,
		toCursor: func(tr *TestRun) Cursor {
			return Cursor{ID: tr.ID}
		},
	},
}

// ToEdge converts TestRun into TestRunEdge.
func (tr *TestRun) ToEdge(order *TestRunOrder) *TestRunEdge {
	if order == nil {
		order = DefaultTestRunOrder
	}
	return &TestRunEdge{
		Node:   tr,
		Cursor: order.Field.toCursor(tr),
	}
}

// VulnerabilityEdge is the edge representation of Vulnerability.
type VulnerabilityEdge struct {
	Node   *Vulnerability `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// VulnerabilityConnection is the connection containing edges to Vulnerability.
type VulnerabilityConnection struct {
	Edges      []*VulnerabilityEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

// VulnerabilityPaginateOption enables pagination customization.
type VulnerabilityPaginateOption func(*vulnerabilityPager) error

// WithVulnerabilityOrder configures pagination ordering.
func WithVulnerabilityOrder(order *VulnerabilityOrder) VulnerabilityPaginateOption {
	if order == nil {
		order = DefaultVulnerabilityOrder
	}
	o := *order
	return func(pager *vulnerabilityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVulnerabilityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVulnerabilityFilter configures pagination filter.
func WithVulnerabilityFilter(filter func(*VulnerabilityQuery) (*VulnerabilityQuery, error)) VulnerabilityPaginateOption {
	return func(pager *vulnerabilityPager) error {
		if filter == nil {
			return errors.New("VulnerabilityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vulnerabilityPager struct {
	order  *VulnerabilityOrder
	filter func(*VulnerabilityQuery) (*VulnerabilityQuery, error)
}

func newVulnerabilityPager(opts []VulnerabilityPaginateOption) (*vulnerabilityPager, error) {
	pager := &vulnerabilityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVulnerabilityOrder
	}
	return pager, nil
}

func (p *vulnerabilityPager) applyFilter(query *VulnerabilityQuery) (*VulnerabilityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vulnerabilityPager) toCursor(v *Vulnerability) Cursor {
	return p.order.Field.toCursor(v)
}

func (p *vulnerabilityPager) applyCursors(query *VulnerabilityQuery, after, before *Cursor) *VulnerabilityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVulnerabilityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vulnerabilityPager) applyOrder(query *VulnerabilityQuery, reverse bool) *VulnerabilityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVulnerabilityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVulnerabilityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Vulnerability.
func (v *VulnerabilityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VulnerabilityPaginateOption,
) (*VulnerabilityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVulnerabilityPager(opts)
	if err != nil {
		return nil, err
	}

	if v, err = pager.applyFilter(v); err != nil {
		return nil, err
	}

	conn := &VulnerabilityConnection{Edges: []*VulnerabilityEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := v.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := v.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	v = pager.applyCursors(v, after, before)
	v = pager.applyOrder(v, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		v = v.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		v = v.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := v.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Vulnerability
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vulnerability {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vulnerability {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VulnerabilityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VulnerabilityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VulnerabilityOrderFieldVid orders Vulnerability by vid.
	VulnerabilityOrderFieldVid = &VulnerabilityOrderField{
		field: vulnerability.FieldVid,
		toCursor: func(v *Vulnerability) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Vid,
			}
		},
	}
	// VulnerabilityOrderFieldSeverityScore orders Vulnerability by severity_score.
	VulnerabilityOrderFieldSeverityScore = &VulnerabilityOrderField{
		field: vulnerability.FieldSeverityScore,
		toCursor: func(v *Vulnerability) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.SeverityScore,
			}
		},
	}
	// VulnerabilityOrderFieldSeverity orders Vulnerability by severity.
	VulnerabilityOrderFieldSeverity = &VulnerabilityOrderField{
		field: vulnerability.FieldSeverity,
		toCursor: func(v *Vulnerability) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Severity,
			}
		},
	}
	// VulnerabilityOrderFieldPublished orders Vulnerability by published.
	VulnerabilityOrderFieldPublished = &VulnerabilityOrderField{
		field: vulnerability.FieldPublished,
		toCursor: func(v *Vulnerability) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Published,
			}
		},
	}
	// VulnerabilityOrderFieldModified orders Vulnerability by modified.
	VulnerabilityOrderFieldModified = &VulnerabilityOrderField{
		field: vulnerability.FieldModified,
		toCursor: func(v *Vulnerability) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Modified,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VulnerabilityOrderField) String() string {
	var str string
	switch f.field {
	case vulnerability.FieldVid:
		str = "vid"
	case vulnerability.FieldSeverityScore:
		str = "severity_score"
	case vulnerability.FieldSeverity:
		str = "severity"
	case vulnerability.FieldPublished:
		str = "published"
	case vulnerability.FieldModified:
		str = "modified"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VulnerabilityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VulnerabilityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VulnerabilityOrderField %T must be a string", v)
	}
	switch str {
	case "vid":
		*f = *VulnerabilityOrderFieldVid
	case "severity_score":
		*f = *VulnerabilityOrderFieldSeverityScore
	case "severity":
		*f = *VulnerabilityOrderFieldSeverity
	case "published":
		*f = *VulnerabilityOrderFieldPublished
	case "modified":
		*f = *VulnerabilityOrderFieldModified
	default:
		return fmt.Errorf("%s is not a valid VulnerabilityOrderField", str)
	}
	return nil
}

// VulnerabilityOrderField defines the ordering field of Vulnerability.
type VulnerabilityOrderField struct {
	field    string
	toCursor func(*Vulnerability) Cursor
}

// VulnerabilityOrder defines the ordering of Vulnerability.
type VulnerabilityOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *VulnerabilityOrderField `json:"field"`
}

// DefaultVulnerabilityOrder is the default ordering of Vulnerability.
var DefaultVulnerabilityOrder = &VulnerabilityOrder{
	Direction: OrderDirectionAsc,
	Field: &VulnerabilityOrderField{
		field: vulnerability.FieldID,
		toCursor: func(v *Vulnerability) Cursor {
			return Cursor{ID: v.ID}
		},
	},
}

// ToEdge converts Vulnerability into VulnerabilityEdge.
func (v *Vulnerability) ToEdge(order *VulnerabilityOrder) *VulnerabilityEdge {
	if order == nil {
		order = DefaultVulnerabilityOrder
	}
	return &VulnerabilityEdge{
		Node:   v,
		Cursor: order.Field.toCursor(v),
	}
}

// VulnerabilityReviewEdge is the edge representation of VulnerabilityReview.
type VulnerabilityReviewEdge struct {
	Node   *VulnerabilityReview `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// VulnerabilityReviewConnection is the connection containing edges to VulnerabilityReview.
type VulnerabilityReviewConnection struct {
	Edges      []*VulnerabilityReviewEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

// VulnerabilityReviewPaginateOption enables pagination customization.
type VulnerabilityReviewPaginateOption func(*vulnerabilityReviewPager) error

// WithVulnerabilityReviewOrder configures pagination ordering.
func WithVulnerabilityReviewOrder(order *VulnerabilityReviewOrder) VulnerabilityReviewPaginateOption {
	if order == nil {
		order = DefaultVulnerabilityReviewOrder
	}
	o := *order
	return func(pager *vulnerabilityReviewPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVulnerabilityReviewOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVulnerabilityReviewFilter configures pagination filter.
func WithVulnerabilityReviewFilter(filter func(*VulnerabilityReviewQuery) (*VulnerabilityReviewQuery, error)) VulnerabilityReviewPaginateOption {
	return func(pager *vulnerabilityReviewPager) error {
		if filter == nil {
			return errors.New("VulnerabilityReviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vulnerabilityReviewPager struct {
	order  *VulnerabilityReviewOrder
	filter func(*VulnerabilityReviewQuery) (*VulnerabilityReviewQuery, error)
}

func newVulnerabilityReviewPager(opts []VulnerabilityReviewPaginateOption) (*vulnerabilityReviewPager, error) {
	pager := &vulnerabilityReviewPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVulnerabilityReviewOrder
	}
	return pager, nil
}

func (p *vulnerabilityReviewPager) applyFilter(query *VulnerabilityReviewQuery) (*VulnerabilityReviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vulnerabilityReviewPager) toCursor(vr *VulnerabilityReview) Cursor {
	return p.order.Field.toCursor(vr)
}

func (p *vulnerabilityReviewPager) applyCursors(query *VulnerabilityReviewQuery, after, before *Cursor) *VulnerabilityReviewQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVulnerabilityReviewOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vulnerabilityReviewPager) applyOrder(query *VulnerabilityReviewQuery, reverse bool) *VulnerabilityReviewQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVulnerabilityReviewOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVulnerabilityReviewOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VulnerabilityReview.
func (vr *VulnerabilityReviewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VulnerabilityReviewPaginateOption,
) (*VulnerabilityReviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVulnerabilityReviewPager(opts)
	if err != nil {
		return nil, err
	}

	if vr, err = pager.applyFilter(vr); err != nil {
		return nil, err
	}

	conn := &VulnerabilityReviewConnection{Edges: []*VulnerabilityReviewEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vr = pager.applyCursors(vr, after, before)
	vr = pager.applyOrder(vr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vr = vr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vr = vr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VulnerabilityReview
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VulnerabilityReview {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VulnerabilityReview {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VulnerabilityReviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VulnerabilityReviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VulnerabilityReviewOrderFieldNote orders VulnerabilityReview by note.
	VulnerabilityReviewOrderFieldNote = &VulnerabilityReviewOrderField{
		field: vulnerabilityreview.FieldNote,
		toCursor: func(vr *VulnerabilityReview) Cursor {
			return Cursor{
				ID:    vr.ID,
				Value: vr.Note,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VulnerabilityReviewOrderField) String() string {
	var str string
	switch f.field {
	case vulnerabilityreview.FieldNote:
		str = "note"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VulnerabilityReviewOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VulnerabilityReviewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VulnerabilityReviewOrderField %T must be a string", v)
	}
	switch str {
	case "note":
		*f = *VulnerabilityReviewOrderFieldNote
	default:
		return fmt.Errorf("%s is not a valid VulnerabilityReviewOrderField", str)
	}
	return nil
}

// VulnerabilityReviewOrderField defines the ordering field of VulnerabilityReview.
type VulnerabilityReviewOrderField struct {
	field    string
	toCursor func(*VulnerabilityReview) Cursor
}

// VulnerabilityReviewOrder defines the ordering of VulnerabilityReview.
type VulnerabilityReviewOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *VulnerabilityReviewOrderField `json:"field"`
}

// DefaultVulnerabilityReviewOrder is the default ordering of VulnerabilityReview.
var DefaultVulnerabilityReviewOrder = &VulnerabilityReviewOrder{
	Direction: OrderDirectionAsc,
	Field: &VulnerabilityReviewOrderField{
		field: vulnerabilityreview.FieldID,
		toCursor: func(vr *VulnerabilityReview) Cursor {
			return Cursor{ID: vr.ID}
		},
	},
}

// ToEdge converts VulnerabilityReview into VulnerabilityReviewEdge.
func (vr *VulnerabilityReview) ToEdge(order *VulnerabilityReviewOrder) *VulnerabilityReviewEdge {
	if order == nil {
		order = DefaultVulnerabilityReviewOrder
	}
	return &VulnerabilityReviewEdge{
		Node:   vr,
		Cursor: order.Field.toCursor(vr),
	}
}
