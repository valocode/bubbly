package store

import (
	"github.com/valocode/bubbly/ent"
	"github.com/valocode/bubbly/ent/vulnerability"
	"github.com/valocode/bubbly/store/api"
)

type VulnerabilityReviewQuery struct {
	Where        *ent.VulnerabilityReviewWhereInput
	WithProjects bool
	WithRepos    bool
	// TODO: some ordering and limiting (first/last)
}

func (h *Handler) GetVulnerabilityReviews(query *VulnerabilityReviewQuery) ([]*api.VulnerabilityReview, error) {
	entQuery := h.client.VulnerabilityReview.Query().WhereInput(query.Where)
	// if query.WithProjects {
	// 	entQuery.WithProjects()
	// }
	// if query.WithRepos {
	// 	entQuery.WithRepos()
	// }

	dbVulnReviews, err := entQuery.All(h.ctx)
	if err != nil {
		return nil, HandleEntError(err, "query vulnerability reviews")
	}

	var vulnReviews = make([]*api.VulnerabilityReview, 0, len(dbVulnReviews))
	for _, review := range dbVulnReviews {
		// var (
		// 	projects = make([]*ent.ProjectModelRead, 0, len(review.Edges.Projects))
		// 	repos    = make([]*ent.RepoModelRead, 0, len(review.Edges.Repos))
		// )
		// for _, project := range review.Edges.Projects {
		// 	projects = append(projects, ent.NewProjectModelRead().FromEnt(project))
		// }
		// for _, repo := range review.Edges.Repos {
		// 	repos = append(repos, ent.NewRepoModelRead().FromEnt(repo))
		// }
		vulnReviews = append(vulnReviews, &api.VulnerabilityReview{
			VulnerabilityReviewModelRead: *ent.NewVulnerabilityReviewModelRead().FromEnt(review),
			// Projects:                     projects,
			// Repos:                        repos,
		})
	}

	return vulnReviews, nil
}

func (h *Handler) SaveVulnerabilityReview(req *api.VulnerabilityReviewSaveRequest) (*ent.VulnerabilityReview, error) {
	var dbVulnReview *ent.VulnerabilityReview
	txErr := WithTx(h.ctx, h.client, func(tx *ent.Tx) error {
		// We need to get the vulnerability for which the review relates to
		dbVulnID, err := tx.Vulnerability.Query().Where(vulnerability.Vid(*req.VulnerabilityID)).OnlyID(h.ctx)
		if err != nil {
			return HandleEntError(err, "query vulnerability id for review create")
		}
		// Create the vulnerability review. There are no unique constraints,
		// so no need to check for any existing
		dbVulnReview, err = tx.VulnerabilityReview.Create().
			SetModelCreate(req.Review).
			SetVulnerabilityID(dbVulnID).
			Save(h.ctx)
		if err != nil {
			return HandleEntError(err, "create vulnerability review")
		}

		// After creating the review, set the affects
		dbVulnReview, err = h.updateVulnerabilityReviewAffects(tx.Client(), dbVulnReview, req.Affects)
		if err != nil {
			return err
		}

		return nil
	})
	if txErr != nil {
		return nil, txErr
	}
	return dbVulnReview, nil
}

func (h *Handler) UpdateVulnerabilityReview(req *api.VulnerabilityReviewUpdateRequest) (*ent.VulnerabilityReview, error) {
	var dbVulnReview *ent.VulnerabilityReview
	txErr := WithTx(h.ctx, h.client, func(tx *ent.Tx) error {
		var err error
		// Create the vulnerability review. There are no unique constraints,
		// so no need to check for any existing
		dbVulnReview, err = tx.VulnerabilityReview.UpdateOneID(*req.ID).
			SetModelUpdate(req.Review).
			Save(h.ctx)
		if err != nil {
			return HandleEntError(err, "update vulnerability review")
		}

		// After creating the review, set the affects
		dbVulnReview, err = h.updateVulnerabilityReviewAffects(tx.Client(), dbVulnReview, req.Affects)
		if err != nil {
			return err
		}

		return nil
	})
	if txErr != nil {
		return nil, txErr
	}
	return dbVulnReview, nil

}

func (h *Handler) updateVulnerabilityReviewAffects(client *ent.Client, dbVulnReview *ent.VulnerabilityReview, affects *api.VulnerabilityReviewAffects) (*ent.VulnerabilityReview, error) {
	if affects == nil {
		return dbVulnReview, nil
	}
	// projectSetIDs, err := h.projectIDs(client, affects.Projects)
	// if err != nil {
	// 	return nil, err
	// }
	// projectSetNotIDs, err := h.projectIDs(client, affects.NotProjects)
	// if err != nil {
	// 	return nil, err
	// }
	// repoSetIDs, err := h.repoIDs(client, affects.Repos)
	// if err != nil {
	// 	return nil, err
	// }
	// repoSetNotIDs, err := h.repoIDs(client, affects.NotRepos)
	// if err != nil {
	// 	return nil, err
	// }
	// releaseSetIDs, err := h.releaseIDs(client, affects.Commits)
	// if err != nil {
	// 	return nil, err
	// }
	// releaseSetNotIDs, err := h.releaseIDs(client, affects.Commits)
	// if err != nil {
	// 	return nil, err
	// }

	// Update the policy with the entities that it affects
	dbVulnReview, err := client.VulnerabilityReview.UpdateOne(dbVulnReview).
		// AddProjectIDs(projectSetIDs...).
		// RemoveProjectIDs(projectSetNotIDs...).
		// AddRepoIDs(repoSetIDs...).
		// RemoveRepoIDs(repoSetNotIDs...).
		// AddReleaseIDs(releaseSetIDs...).
		// RemoveReleaseIDs(releaseSetNotIDs...).
		Save(h.ctx)
	if err != nil {
		return nil, HandleEntError(err, "set policy affects")
	}
	return dbVulnReview, nil
}
